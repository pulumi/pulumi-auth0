# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ActionDependency',
    'ActionSecret',
    'ActionSupportedTriggers',
    'AttackProtectionBreachedPasswordDetection',
    'AttackProtectionBreachedPasswordDetectionPreChangePassword',
    'AttackProtectionBreachedPasswordDetectionPreUserRegistration',
    'AttackProtectionBruteForceProtection',
    'AttackProtectionSuspiciousIpThrottling',
    'AttackProtectionSuspiciousIpThrottlingPreLogin',
    'AttackProtectionSuspiciousIpThrottlingPreUserRegistration',
    'BrandingColors',
    'BrandingFont',
    'BrandingThemeBorders',
    'BrandingThemeColors',
    'BrandingThemeFonts',
    'BrandingThemeFontsBodyText',
    'BrandingThemeFontsButtonsText',
    'BrandingThemeFontsInputLabels',
    'BrandingThemeFontsLinks',
    'BrandingThemeFontsSubtitle',
    'BrandingThemeFontsTitle',
    'BrandingThemePageBackground',
    'BrandingThemeWidget',
    'BrandingUniversalLogin',
    'ClientAddons',
    'ClientAddonsAws',
    'ClientAddonsAzureBlob',
    'ClientAddonsAzureSb',
    'ClientAddonsBox',
    'ClientAddonsCloudbees',
    'ClientAddonsConcur',
    'ClientAddonsDropbox',
    'ClientAddonsEchosign',
    'ClientAddonsEgnyte',
    'ClientAddonsFirebase',
    'ClientAddonsLayer',
    'ClientAddonsMscrm',
    'ClientAddonsNewrelic',
    'ClientAddonsOffice365',
    'ClientAddonsRms',
    'ClientAddonsSalesforce',
    'ClientAddonsSalesforceApi',
    'ClientAddonsSalesforceSandboxApi',
    'ClientAddonsSamlp',
    'ClientAddonsSamlpLogout',
    'ClientAddonsSapApi',
    'ClientAddonsSentry',
    'ClientAddonsSharepoint',
    'ClientAddonsSlack',
    'ClientAddonsSpringcm',
    'ClientAddonsSsoIntegration',
    'ClientAddonsWams',
    'ClientAddonsWsfed',
    'ClientAddonsZendesk',
    'ClientAddonsZoom',
    'ClientCredentialsPrivateKeyJwt',
    'ClientCredentialsPrivateKeyJwtCredential',
    'ClientCredentialsSelfSignedTlsClientAuth',
    'ClientCredentialsSelfSignedTlsClientAuthCredential',
    'ClientCredentialsSignedRequestObject',
    'ClientCredentialsSignedRequestObjectCredential',
    'ClientCredentialsTlsClientAuth',
    'ClientCredentialsTlsClientAuthCredential',
    'ClientDefaultOrganization',
    'ClientJwtConfiguration',
    'ClientMobile',
    'ClientMobileAndroid',
    'ClientMobileIos',
    'ClientNativeSocialLogin',
    'ClientNativeSocialLoginApple',
    'ClientNativeSocialLoginFacebook',
    'ClientNativeSocialLoginGoogle',
    'ClientOidcLogout',
    'ClientOidcLogoutBackchannelLogoutInitiators',
    'ClientRefreshToken',
    'ClientRefreshTokenPolicy',
    'ClientSessionTransfer',
    'ClientTokenExchange',
    'ClientTokenQuota',
    'ClientTokenQuotaClientCredentials',
    'ConnectionOptions',
    'ConnectionOptionsAttribute',
    'ConnectionOptionsAttributeEmail',
    'ConnectionOptionsAttributeEmailIdentifier',
    'ConnectionOptionsAttributeEmailSignup',
    'ConnectionOptionsAttributeEmailSignupVerification',
    'ConnectionOptionsAttributeMap',
    'ConnectionOptionsAttributePhoneNumber',
    'ConnectionOptionsAttributePhoneNumberIdentifier',
    'ConnectionOptionsAttributePhoneNumberSignup',
    'ConnectionOptionsAttributePhoneNumberSignupVerification',
    'ConnectionOptionsAttributeUsername',
    'ConnectionOptionsAttributeUsernameIdentifier',
    'ConnectionOptionsAttributeUsernameSignup',
    'ConnectionOptionsAttributeUsernameValidation',
    'ConnectionOptionsAttributeUsernameValidationAllowedType',
    'ConnectionOptionsAuthenticationMethod',
    'ConnectionOptionsAuthenticationMethodPasskey',
    'ConnectionOptionsAuthenticationMethodPassword',
    'ConnectionOptionsConnectionSettings',
    'ConnectionOptionsCustomHeader',
    'ConnectionOptionsDecryptionKey',
    'ConnectionOptionsGatewayAuthentication',
    'ConnectionOptionsIdpInitiated',
    'ConnectionOptionsMfa',
    'ConnectionOptionsPasskeyOptions',
    'ConnectionOptionsPasswordComplexityOptions',
    'ConnectionOptionsPasswordDictionary',
    'ConnectionOptionsPasswordHistory',
    'ConnectionOptionsPasswordNoPersonalInfo',
    'ConnectionOptionsSigningKey',
    'ConnectionOptionsTotp',
    'ConnectionOptionsValidation',
    'ConnectionOptionsValidationUsername',
    'ConnectionScimConfigurationMapping',
    'CustomDomainCertificate',
    'CustomDomainVerification',
    'EmailProviderCredentials',
    'EmailProviderSettings',
    'EmailProviderSettingsHeaders',
    'EmailProviderSettingsMessage',
    'EncryptionKeyManagerCustomerProvidedRootKey',
    'EncryptionKeyManagerEncryptionKey',
    'FormLanguage',
    'FormMessage',
    'GuardianDuo',
    'GuardianPhone',
    'GuardianPhoneOptions',
    'GuardianPush',
    'GuardianPushAmazonSns',
    'GuardianPushCustomApp',
    'GuardianPushDirectApns',
    'GuardianPushDirectFcm',
    'GuardianWebauthnPlatform',
    'GuardianWebauthnRoaming',
    'LogStreamSink',
    'NetworkAclRule',
    'NetworkAclRuleAction',
    'NetworkAclRuleMatch',
    'NetworkAclRuleNotMatch',
    'OrganizationBranding',
    'OrganizationConnectionsEnabledConnection',
    'OrganizationTokenQuota',
    'OrganizationTokenQuotaClientCredentials',
    'PagesChangePassword',
    'PagesError',
    'PagesGuardianMfa',
    'PagesLogin',
    'PhoneProviderConfiguration',
    'PhoneProviderCredentials',
    'PromptScreenPartialInsertionPoints',
    'PromptScreenPartialsScreenPartial',
    'PromptScreenPartialsScreenPartialInsertionPoints',
    'PromptScreenRendererFilters',
    'ResourceServerAuthorizationDetail',
    'ResourceServerProofOfPossession',
    'ResourceServerScopesScope',
    'ResourceServerTokenEncryption',
    'ResourceServerTokenEncryptionEncryptionKey',
    'RolePermissionsPermission',
    'SelfServiceProfileBranding',
    'SelfServiceProfileBrandingColors',
    'SelfServiceProfileUserAttribute',
    'TenantDefaultTokenQuota',
    'TenantDefaultTokenQuotaClients',
    'TenantDefaultTokenQuotaClientsClientCredentials',
    'TenantDefaultTokenQuotaOrganizations',
    'TenantDefaultTokenQuotaOrganizationsClientCredentials',
    'TenantErrorPage',
    'TenantFlags',
    'TenantMtls',
    'TenantOidcLogout',
    'TenantSessionCookie',
    'TenantSessions',
    'TriggerActionsAction',
    'UserPermissionsPermission',
    'GetActionDependencyResult',
    'GetActionSecretResult',
    'GetActionSupportedTriggerResult',
    'GetAttackProtectionBreachedPasswordDetectionResult',
    'GetAttackProtectionBreachedPasswordDetectionPreChangePasswordResult',
    'GetAttackProtectionBreachedPasswordDetectionPreUserRegistrationResult',
    'GetAttackProtectionBruteForceProtectionResult',
    'GetAttackProtectionSuspiciousIpThrottlingResult',
    'GetAttackProtectionSuspiciousIpThrottlingPreLoginResult',
    'GetAttackProtectionSuspiciousIpThrottlingPreUserRegistrationResult',
    'GetBrandingColorResult',
    'GetBrandingFontResult',
    'GetBrandingThemeBorderResult',
    'GetBrandingThemeColorResult',
    'GetBrandingThemeFontResult',
    'GetBrandingThemeFontBodyTextResult',
    'GetBrandingThemeFontButtonsTextResult',
    'GetBrandingThemeFontInputLabelResult',
    'GetBrandingThemeFontLinkResult',
    'GetBrandingThemeFontSubtitleResult',
    'GetBrandingThemeFontTitleResult',
    'GetBrandingThemePageBackgroundResult',
    'GetBrandingThemeWidgetResult',
    'GetBrandingUniversalLoginResult',
    'GetClientAddonResult',
    'GetClientAddonAwResult',
    'GetClientAddonAzureBlobResult',
    'GetClientAddonAzureSbResult',
    'GetClientAddonBoxResult',
    'GetClientAddonCloudbeeResult',
    'GetClientAddonConcurResult',
    'GetClientAddonDropboxResult',
    'GetClientAddonEchosignResult',
    'GetClientAddonEgnyteResult',
    'GetClientAddonFirebaseResult',
    'GetClientAddonLayerResult',
    'GetClientAddonMscrmResult',
    'GetClientAddonNewrelicResult',
    'GetClientAddonOffice365Result',
    'GetClientAddonRmResult',
    'GetClientAddonSalesforceResult',
    'GetClientAddonSalesforceApiResult',
    'GetClientAddonSalesforceSandboxApiResult',
    'GetClientAddonSamlpResult',
    'GetClientAddonSamlpLogoutResult',
    'GetClientAddonSapApiResult',
    'GetClientAddonSentryResult',
    'GetClientAddonSharepointResult',
    'GetClientAddonSlackResult',
    'GetClientAddonSpringcmResult',
    'GetClientAddonSsoIntegrationResult',
    'GetClientAddonWamResult',
    'GetClientAddonWsfedResult',
    'GetClientAddonZendeskResult',
    'GetClientAddonZoomResult',
    'GetClientClientAuthenticationMethodResult',
    'GetClientClientAuthenticationMethodPrivateKeyJwtResult',
    'GetClientClientAuthenticationMethodPrivateKeyJwtCredentialResult',
    'GetClientClientAuthenticationMethodSelfSignedTlsClientAuthResult',
    'GetClientClientAuthenticationMethodSelfSignedTlsClientAuthCredentialResult',
    'GetClientClientAuthenticationMethodTlsClientAuthResult',
    'GetClientClientAuthenticationMethodTlsClientAuthCredentialResult',
    'GetClientDefaultOrganizationResult',
    'GetClientJwtConfigurationResult',
    'GetClientMobileResult',
    'GetClientMobileAndroidResult',
    'GetClientMobileIoResult',
    'GetClientNativeSocialLoginResult',
    'GetClientNativeSocialLoginAppleResult',
    'GetClientNativeSocialLoginFacebookResult',
    'GetClientNativeSocialLoginGoogleResult',
    'GetClientOidcLogoutResult',
    'GetClientOidcLogoutBackchannelLogoutInitiatorResult',
    'GetClientRefreshTokenResult',
    'GetClientRefreshTokenPolicyResult',
    'GetClientSessionTransferResult',
    'GetClientSignedRequestObjectResult',
    'GetClientSignedRequestObjectCredentialResult',
    'GetClientTokenExchangeResult',
    'GetClientTokenQuotaResult',
    'GetClientTokenQuotaClientCredentialResult',
    'GetClientsClientResult',
    'GetClientsClientOidcLogoutResult',
    'GetClientsClientOidcLogoutBackchannelLogoutInitiatorResult',
    'GetClientsClientSessionTransferResult',
    'GetClientsClientTokenExchangeResult',
    'GetClientsClientTokenQuotaResult',
    'GetClientsClientTokenQuotaClientCredentialResult',
    'GetConnectionKeysKeyResult',
    'GetConnectionOptionResult',
    'GetConnectionOptionAttributeResult',
    'GetConnectionOptionAttributeEmailResult',
    'GetConnectionOptionAttributeEmailIdentifierResult',
    'GetConnectionOptionAttributeEmailSignupResult',
    'GetConnectionOptionAttributeEmailSignupVerificationResult',
    'GetConnectionOptionAttributeMapResult',
    'GetConnectionOptionAttributePhoneNumberResult',
    'GetConnectionOptionAttributePhoneNumberIdentifierResult',
    'GetConnectionOptionAttributePhoneNumberSignupResult',
    'GetConnectionOptionAttributePhoneNumberSignupVerificationResult',
    'GetConnectionOptionAttributeUsernameResult',
    'GetConnectionOptionAttributeUsernameIdentifierResult',
    'GetConnectionOptionAttributeUsernameSignupResult',
    'GetConnectionOptionAttributeUsernameValidationResult',
    'GetConnectionOptionAttributeUsernameValidationAllowedTypeResult',
    'GetConnectionOptionAuthenticationMethodResult',
    'GetConnectionOptionAuthenticationMethodPasskeyResult',
    'GetConnectionOptionAuthenticationMethodPasswordResult',
    'GetConnectionOptionConnectionSettingResult',
    'GetConnectionOptionCustomHeaderResult',
    'GetConnectionOptionDecryptionKeyResult',
    'GetConnectionOptionGatewayAuthenticationResult',
    'GetConnectionOptionIdpInitiatedResult',
    'GetConnectionOptionMfaResult',
    'GetConnectionOptionPasskeyOptionResult',
    'GetConnectionOptionPasswordComplexityOptionResult',
    'GetConnectionOptionPasswordDictionaryResult',
    'GetConnectionOptionPasswordHistoryResult',
    'GetConnectionOptionPasswordNoPersonalInfoResult',
    'GetConnectionOptionSigningKeyResult',
    'GetConnectionOptionTotpResult',
    'GetConnectionOptionValidationResult',
    'GetConnectionOptionValidationUsernameResult',
    'GetConnectionScimConfigurationDefaultMappingResult',
    'GetConnectionScimConfigurationMappingResult',
    'GetCustomDomainCertificateResult',
    'GetCustomDomainVerificationResult',
    'GetFormLanguageResult',
    'GetFormMessageResult',
    'GetNetworkAclRuleResult',
    'GetNetworkAclRuleActionResult',
    'GetNetworkAclRuleMatchResult',
    'GetNetworkAclRuleNotMatchResult',
    'GetOrganizationBrandingResult',
    'GetOrganizationConnectionResult',
    'GetOrganizationTokenQuotaResult',
    'GetOrganizationTokenQuotaClientCredentialResult',
    'GetPagesChangePasswordResult',
    'GetPagesErrorResult',
    'GetPagesGuardianMfaResult',
    'GetPagesLoginResult',
    'GetPhoneProviderConfigurationResult',
    'GetPhoneProviderCredentialResult',
    'GetPromptScreenPartialsScreenPartialResult',
    'GetPromptScreenPartialsScreenPartialInsertionPointResult',
    'GetPromptScreenRendererFilterResult',
    'GetResourceServerAuthorizationDetailResult',
    'GetResourceServerProofOfPossessionResult',
    'GetResourceServerScopeResult',
    'GetResourceServerTokenEncryptionResult',
    'GetResourceServerTokenEncryptionEncryptionKeyResult',
    'GetRolePermissionResult',
    'GetSelfServiceProfileBrandingResult',
    'GetSelfServiceProfileBrandingColorResult',
    'GetSelfServiceProfileUserAttributeResult',
    'GetSigningKeysSigningKeyResult',
    'GetTenantDefaultTokenQuotaResult',
    'GetTenantDefaultTokenQuotaClientResult',
    'GetTenantDefaultTokenQuotaClientClientCredentialResult',
    'GetTenantDefaultTokenQuotaOrganizationResult',
    'GetTenantDefaultTokenQuotaOrganizationClientCredentialResult',
    'GetTenantErrorPageResult',
    'GetTenantFlagResult',
    'GetTenantMtlResult',
    'GetTenantOidcLogoutResult',
    'GetTenantSessionResult',
    'GetTenantSessionCookyResult',
    'GetUserPermissionResult',
]

@pulumi.output_type
class ActionDependency(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Dependency name, e.g. `lodash`.
        :param _builtins.str version: Dependency version, e.g. `latest` or `4.17.21`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Dependency name, e.g. `lodash`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Dependency version, e.g. `latest` or `4.17.21`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ActionSecret(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Secret name.
        :param _builtins.str value: Secret value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Secret name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Secret value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ActionSupportedTriggers(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: The trigger ID.
        :param _builtins.str version: The trigger version. This regulates which `runtime` versions are supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The trigger ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The trigger version. This regulates which `runtime` versions are supported.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AttackProtectionBreachedPasswordDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminNotificationFrequencies":
            suggest = "admin_notification_frequencies"
        elif key == "preChangePassword":
            suggest = "pre_change_password"
        elif key == "preUserRegistration":
            suggest = "pre_user_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackProtectionBreachedPasswordDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackProtectionBreachedPasswordDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackProtectionBreachedPasswordDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 admin_notification_frequencies: Optional[Sequence[_builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 pre_change_password: Optional['outputs.AttackProtectionBreachedPasswordDetectionPreChangePassword'] = None,
                 pre_user_registration: Optional['outputs.AttackProtectionBreachedPasswordDetectionPreUserRegistration'] = None,
                 shields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Whether breached password detection is active.
        :param Sequence[_builtins.str] admin_notification_frequencies: When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        :param _builtins.str method: The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        :param 'AttackProtectionBreachedPasswordDetectionPreChangePasswordArgs' pre_change_password: Configuration options that apply before every password change attempt.
        :param 'AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs' pre_user_registration: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        pulumi.set(__self__, "enabled", enabled)
        if admin_notification_frequencies is not None:
            pulumi.set(__self__, "admin_notification_frequencies", admin_notification_frequencies)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if pre_change_password is not None:
            pulumi.set(__self__, "pre_change_password", pre_change_password)
        if pre_user_registration is not None:
            pulumi.set(__self__, "pre_user_registration", pre_user_registration)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether breached password detection is active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="adminNotificationFrequencies")
    def admin_notification_frequencies(self) -> Optional[Sequence[_builtins.str]]:
        """
        When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        """
        return pulumi.get(self, "admin_notification_frequencies")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="preChangePassword")
    def pre_change_password(self) -> Optional['outputs.AttackProtectionBreachedPasswordDetectionPreChangePassword']:
        """
        Configuration options that apply before every password change attempt.
        """
        return pulumi.get(self, "pre_change_password")

    @_builtins.property
    @pulumi.getter(name="preUserRegistration")
    def pre_user_registration(self) -> Optional['outputs.AttackProtectionBreachedPasswordDetectionPreUserRegistration']:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registration")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class AttackProtectionBreachedPasswordDetectionPreChangePassword(dict):
    def __init__(__self__, *,
                 shields: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected before the password is changed. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Action to take when a breached password is detected before the password is changed. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class AttackProtectionBreachedPasswordDetectionPreUserRegistration(dict):
    def __init__(__self__, *,
                 shields: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class AttackProtectionBruteForceProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackProtectionBruteForceProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackProtectionBruteForceProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackProtectionBruteForceProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 allowlists: Optional[Sequence[_builtins.str]] = None,
                 max_attempts: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 shields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Whether brute force attack protections are active.
        :param Sequence[_builtins.str] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param _builtins.int max_attempts: Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        :param _builtins.str mode: Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        :param Sequence[_builtins.str] shields: Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowlists is not None:
            pulumi.set(__self__, "allowlists", allowlists)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether brute force attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def allowlists(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[_builtins.int]:
        """
        Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class AttackProtectionSuspiciousIpThrottling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preLogin":
            suggest = "pre_login"
        elif key == "preUserRegistration":
            suggest = "pre_user_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackProtectionSuspiciousIpThrottling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackProtectionSuspiciousIpThrottling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackProtectionSuspiciousIpThrottling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 allowlists: Optional[Sequence[_builtins.str]] = None,
                 pre_login: Optional['outputs.AttackProtectionSuspiciousIpThrottlingPreLogin'] = None,
                 pre_user_registration: Optional['outputs.AttackProtectionSuspiciousIpThrottlingPreUserRegistration'] = None,
                 shields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Whether suspicious IP throttling attack protections are active.
        :param Sequence[_builtins.str] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param 'AttackProtectionSuspiciousIpThrottlingPreLoginArgs' pre_login: Configuration options that apply before every login attempt. Only available on public tenants.
        :param 'AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs' pre_user_registration: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param Sequence[_builtins.str] shields: Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowlists is not None:
            pulumi.set(__self__, "allowlists", allowlists)
        if pre_login is not None:
            pulumi.set(__self__, "pre_login", pre_login)
        if pre_user_registration is not None:
            pulumi.set(__self__, "pre_user_registration", pre_user_registration)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether suspicious IP throttling attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def allowlists(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @_builtins.property
    @pulumi.getter(name="preLogin")
    def pre_login(self) -> Optional['outputs.AttackProtectionSuspiciousIpThrottlingPreLogin']:
        """
        Configuration options that apply before every login attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_login")

    @_builtins.property
    @pulumi.getter(name="preUserRegistration")
    def pre_user_registration(self) -> Optional['outputs.AttackProtectionSuspiciousIpThrottlingPreUserRegistration']:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registration")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class AttackProtectionSuspiciousIpThrottlingPreLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackProtectionSuspiciousIpThrottlingPreLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackProtectionSuspiciousIpThrottlingPreLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackProtectionSuspiciousIpThrottlingPreLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_attempts: Optional[_builtins.int] = None,
                 rate: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_attempts: The maximum number of failed login attempts allowed from a single IP address.
        :param _builtins.int rate: Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[_builtins.int]:
        """
        The maximum number of failed login attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional[_builtins.int]:
        """
        Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")


@pulumi.output_type
class AttackProtectionSuspiciousIpThrottlingPreUserRegistration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackProtectionSuspiciousIpThrottlingPreUserRegistration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackProtectionSuspiciousIpThrottlingPreUserRegistration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackProtectionSuspiciousIpThrottlingPreUserRegistration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_attempts: Optional[_builtins.int] = None,
                 rate: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_attempts: The maximum number of sign up attempts allowed from a single IP address.
        :param _builtins.int rate: Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[_builtins.int]:
        """
        The maximum number of sign up attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional[_builtins.int]:
        """
        Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")


@pulumi.output_type
class BrandingColors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageBackground":
            suggest = "page_background"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingColors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingColors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingColors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_background: Optional[_builtins.str] = None,
                 primary: Optional[_builtins.str] = None):
        """
        :param _builtins.str page_background: Background color of login pages in hexadecimal.
        :param _builtins.str primary: Primary button background color in hexadecimal.
        """
        if page_background is not None:
            pulumi.set(__self__, "page_background", page_background)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter(name="pageBackground")
    def page_background(self) -> Optional[_builtins.str]:
        """
        Background color of login pages in hexadecimal.
        """
        return pulumi.get(self, "page_background")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[_builtins.str]:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class BrandingFont(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: URL for the custom font.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL for the custom font.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class BrandingThemeBorders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonBorderRadius":
            suggest = "button_border_radius"
        elif key == "buttonBorderWeight":
            suggest = "button_border_weight"
        elif key == "buttonsStyle":
            suggest = "buttons_style"
        elif key == "inputBorderRadius":
            suggest = "input_border_radius"
        elif key == "inputBorderWeight":
            suggest = "input_border_weight"
        elif key == "inputsStyle":
            suggest = "inputs_style"
        elif key == "showWidgetShadow":
            suggest = "show_widget_shadow"
        elif key == "widgetBorderWeight":
            suggest = "widget_border_weight"
        elif key == "widgetCornerRadius":
            suggest = "widget_corner_radius"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingThemeBorders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingThemeBorders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingThemeBorders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_border_radius: Optional[_builtins.float] = None,
                 button_border_weight: Optional[_builtins.float] = None,
                 buttons_style: Optional[_builtins.str] = None,
                 input_border_radius: Optional[_builtins.float] = None,
                 input_border_weight: Optional[_builtins.float] = None,
                 inputs_style: Optional[_builtins.str] = None,
                 show_widget_shadow: Optional[_builtins.bool] = None,
                 widget_border_weight: Optional[_builtins.float] = None,
                 widget_corner_radius: Optional[_builtins.float] = None):
        """
        :param _builtins.float button_border_radius: Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        :param _builtins.float button_border_weight: Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        :param _builtins.str buttons_style: Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param _builtins.float input_border_radius: Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        :param _builtins.float input_border_weight: Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        :param _builtins.str inputs_style: Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param _builtins.bool show_widget_shadow: Show widget shadow. Defaults to `true`.
        :param _builtins.float widget_border_weight: Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        :param _builtins.float widget_corner_radius: Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        if button_border_radius is not None:
            pulumi.set(__self__, "button_border_radius", button_border_radius)
        if button_border_weight is not None:
            pulumi.set(__self__, "button_border_weight", button_border_weight)
        if buttons_style is not None:
            pulumi.set(__self__, "buttons_style", buttons_style)
        if input_border_radius is not None:
            pulumi.set(__self__, "input_border_radius", input_border_radius)
        if input_border_weight is not None:
            pulumi.set(__self__, "input_border_weight", input_border_weight)
        if inputs_style is not None:
            pulumi.set(__self__, "inputs_style", inputs_style)
        if show_widget_shadow is not None:
            pulumi.set(__self__, "show_widget_shadow", show_widget_shadow)
        if widget_border_weight is not None:
            pulumi.set(__self__, "widget_border_weight", widget_border_weight)
        if widget_corner_radius is not None:
            pulumi.set(__self__, "widget_corner_radius", widget_corner_radius)

    @_builtins.property
    @pulumi.getter(name="buttonBorderRadius")
    def button_border_radius(self) -> Optional[_builtins.float]:
        """
        Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "button_border_radius")

    @_builtins.property
    @pulumi.getter(name="buttonBorderWeight")
    def button_border_weight(self) -> Optional[_builtins.float]:
        """
        Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        """
        return pulumi.get(self, "button_border_weight")

    @_builtins.property
    @pulumi.getter(name="buttonsStyle")
    def buttons_style(self) -> Optional[_builtins.str]:
        """
        Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "buttons_style")

    @_builtins.property
    @pulumi.getter(name="inputBorderRadius")
    def input_border_radius(self) -> Optional[_builtins.float]:
        """
        Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "input_border_radius")

    @_builtins.property
    @pulumi.getter(name="inputBorderWeight")
    def input_border_weight(self) -> Optional[_builtins.float]:
        """
        Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        """
        return pulumi.get(self, "input_border_weight")

    @_builtins.property
    @pulumi.getter(name="inputsStyle")
    def inputs_style(self) -> Optional[_builtins.str]:
        """
        Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "inputs_style")

    @_builtins.property
    @pulumi.getter(name="showWidgetShadow")
    def show_widget_shadow(self) -> Optional[_builtins.bool]:
        """
        Show widget shadow. Defaults to `true`.
        """
        return pulumi.get(self, "show_widget_shadow")

    @_builtins.property
    @pulumi.getter(name="widgetBorderWeight")
    def widget_border_weight(self) -> Optional[_builtins.float]:
        """
        Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        """
        return pulumi.get(self, "widget_border_weight")

    @_builtins.property
    @pulumi.getter(name="widgetCornerRadius")
    def widget_corner_radius(self) -> Optional[_builtins.float]:
        """
        Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        return pulumi.get(self, "widget_corner_radius")


@pulumi.output_type
class BrandingThemeColors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseFocusColor":
            suggest = "base_focus_color"
        elif key == "baseHoverColor":
            suggest = "base_hover_color"
        elif key == "bodyText":
            suggest = "body_text"
        elif key == "captchaWidgetTheme":
            suggest = "captcha_widget_theme"
        elif key == "inputBackground":
            suggest = "input_background"
        elif key == "inputBorder":
            suggest = "input_border"
        elif key == "inputFilledText":
            suggest = "input_filled_text"
        elif key == "inputLabelsPlaceholders":
            suggest = "input_labels_placeholders"
        elif key == "linksFocusedComponents":
            suggest = "links_focused_components"
        elif key == "primaryButton":
            suggest = "primary_button"
        elif key == "primaryButtonLabel":
            suggest = "primary_button_label"
        elif key == "secondaryButtonBorder":
            suggest = "secondary_button_border"
        elif key == "secondaryButtonLabel":
            suggest = "secondary_button_label"
        elif key == "widgetBackground":
            suggest = "widget_background"
        elif key == "widgetBorder":
            suggest = "widget_border"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingThemeColors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingThemeColors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingThemeColors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_focus_color: Optional[_builtins.str] = None,
                 base_hover_color: Optional[_builtins.str] = None,
                 body_text: Optional[_builtins.str] = None,
                 captcha_widget_theme: Optional[_builtins.str] = None,
                 error: Optional[_builtins.str] = None,
                 header: Optional[_builtins.str] = None,
                 icons: Optional[_builtins.str] = None,
                 input_background: Optional[_builtins.str] = None,
                 input_border: Optional[_builtins.str] = None,
                 input_filled_text: Optional[_builtins.str] = None,
                 input_labels_placeholders: Optional[_builtins.str] = None,
                 links_focused_components: Optional[_builtins.str] = None,
                 primary_button: Optional[_builtins.str] = None,
                 primary_button_label: Optional[_builtins.str] = None,
                 secondary_button_border: Optional[_builtins.str] = None,
                 secondary_button_label: Optional[_builtins.str] = None,
                 success: Optional[_builtins.str] = None,
                 widget_background: Optional[_builtins.str] = None,
                 widget_border: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_focus_color: Base focus color. Defaults to `#635dff`.
        :param _builtins.str base_hover_color: Base hover color. Defaults to `#000000`.
        :param _builtins.str body_text: Body text. Defaults to `#1e212a`.
        :param _builtins.str captcha_widget_theme: Captcha Widget Theme.
        :param _builtins.str error: Error. Defaults to `#d03c38`.
        :param _builtins.str header: Header. Defaults to `#1e212a`.
        :param _builtins.str icons: Icons. Defaults to `#65676e`.
        :param _builtins.str input_background: Input background. Defaults to `#ffffff`.
        :param _builtins.str input_border: Input border. Defaults to `#c9cace`.
        :param _builtins.str input_filled_text: Input filled text. Defaults to `#000000`.
        :param _builtins.str input_labels_placeholders: Input labels & placeholders. Defaults to `#65676e`.
        :param _builtins.str links_focused_components: Links & focused components. Defaults to `#635dff`.
        :param _builtins.str primary_button: Primary button. Defaults to `#635dff`.
        :param _builtins.str primary_button_label: Primary button label. Defaults to `#ffffff`.
        :param _builtins.str secondary_button_border: Secondary button border. Defaults to `#c9cace`.
        :param _builtins.str secondary_button_label: Secondary button label. Defaults to `#1e212a`.
        :param _builtins.str success: Success. Defaults to `#13a688`.
        :param _builtins.str widget_background: Widget background. Defaults to `#ffffff`.
        :param _builtins.str widget_border: Widget border. Defaults to `#c9cace`.
        """
        if base_focus_color is not None:
            pulumi.set(__self__, "base_focus_color", base_focus_color)
        if base_hover_color is not None:
            pulumi.set(__self__, "base_hover_color", base_hover_color)
        if body_text is not None:
            pulumi.set(__self__, "body_text", body_text)
        if captcha_widget_theme is not None:
            pulumi.set(__self__, "captcha_widget_theme", captcha_widget_theme)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if icons is not None:
            pulumi.set(__self__, "icons", icons)
        if input_background is not None:
            pulumi.set(__self__, "input_background", input_background)
        if input_border is not None:
            pulumi.set(__self__, "input_border", input_border)
        if input_filled_text is not None:
            pulumi.set(__self__, "input_filled_text", input_filled_text)
        if input_labels_placeholders is not None:
            pulumi.set(__self__, "input_labels_placeholders", input_labels_placeholders)
        if links_focused_components is not None:
            pulumi.set(__self__, "links_focused_components", links_focused_components)
        if primary_button is not None:
            pulumi.set(__self__, "primary_button", primary_button)
        if primary_button_label is not None:
            pulumi.set(__self__, "primary_button_label", primary_button_label)
        if secondary_button_border is not None:
            pulumi.set(__self__, "secondary_button_border", secondary_button_border)
        if secondary_button_label is not None:
            pulumi.set(__self__, "secondary_button_label", secondary_button_label)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if widget_background is not None:
            pulumi.set(__self__, "widget_background", widget_background)
        if widget_border is not None:
            pulumi.set(__self__, "widget_border", widget_border)

    @_builtins.property
    @pulumi.getter(name="baseFocusColor")
    def base_focus_color(self) -> Optional[_builtins.str]:
        """
        Base focus color. Defaults to `#635dff`.
        """
        return pulumi.get(self, "base_focus_color")

    @_builtins.property
    @pulumi.getter(name="baseHoverColor")
    def base_hover_color(self) -> Optional[_builtins.str]:
        """
        Base hover color. Defaults to `#000000`.
        """
        return pulumi.get(self, "base_hover_color")

    @_builtins.property
    @pulumi.getter(name="bodyText")
    def body_text(self) -> Optional[_builtins.str]:
        """
        Body text. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "body_text")

    @_builtins.property
    @pulumi.getter(name="captchaWidgetTheme")
    def captcha_widget_theme(self) -> Optional[_builtins.str]:
        """
        Captcha Widget Theme.
        """
        return pulumi.get(self, "captcha_widget_theme")

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[_builtins.str]:
        """
        Error. Defaults to `#d03c38`.
        """
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[_builtins.str]:
        """
        Header. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def icons(self) -> Optional[_builtins.str]:
        """
        Icons. Defaults to `#65676e`.
        """
        return pulumi.get(self, "icons")

    @_builtins.property
    @pulumi.getter(name="inputBackground")
    def input_background(self) -> Optional[_builtins.str]:
        """
        Input background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "input_background")

    @_builtins.property
    @pulumi.getter(name="inputBorder")
    def input_border(self) -> Optional[_builtins.str]:
        """
        Input border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "input_border")

    @_builtins.property
    @pulumi.getter(name="inputFilledText")
    def input_filled_text(self) -> Optional[_builtins.str]:
        """
        Input filled text. Defaults to `#000000`.
        """
        return pulumi.get(self, "input_filled_text")

    @_builtins.property
    @pulumi.getter(name="inputLabelsPlaceholders")
    def input_labels_placeholders(self) -> Optional[_builtins.str]:
        """
        Input labels & placeholders. Defaults to `#65676e`.
        """
        return pulumi.get(self, "input_labels_placeholders")

    @_builtins.property
    @pulumi.getter(name="linksFocusedComponents")
    def links_focused_components(self) -> Optional[_builtins.str]:
        """
        Links & focused components. Defaults to `#635dff`.
        """
        return pulumi.get(self, "links_focused_components")

    @_builtins.property
    @pulumi.getter(name="primaryButton")
    def primary_button(self) -> Optional[_builtins.str]:
        """
        Primary button. Defaults to `#635dff`.
        """
        return pulumi.get(self, "primary_button")

    @_builtins.property
    @pulumi.getter(name="primaryButtonLabel")
    def primary_button_label(self) -> Optional[_builtins.str]:
        """
        Primary button label. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "primary_button_label")

    @_builtins.property
    @pulumi.getter(name="secondaryButtonBorder")
    def secondary_button_border(self) -> Optional[_builtins.str]:
        """
        Secondary button border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "secondary_button_border")

    @_builtins.property
    @pulumi.getter(name="secondaryButtonLabel")
    def secondary_button_label(self) -> Optional[_builtins.str]:
        """
        Secondary button label. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "secondary_button_label")

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[_builtins.str]:
        """
        Success. Defaults to `#13a688`.
        """
        return pulumi.get(self, "success")

    @_builtins.property
    @pulumi.getter(name="widgetBackground")
    def widget_background(self) -> Optional[_builtins.str]:
        """
        Widget background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "widget_background")

    @_builtins.property
    @pulumi.getter(name="widgetBorder")
    def widget_border(self) -> Optional[_builtins.str]:
        """
        Widget border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "widget_border")


@pulumi.output_type
class BrandingThemeFonts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyText":
            suggest = "body_text"
        elif key == "buttonsText":
            suggest = "buttons_text"
        elif key == "inputLabels":
            suggest = "input_labels"
        elif key == "fontUrl":
            suggest = "font_url"
        elif key == "linksStyle":
            suggest = "links_style"
        elif key == "referenceTextSize":
            suggest = "reference_text_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingThemeFonts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingThemeFonts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingThemeFonts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_text: 'outputs.BrandingThemeFontsBodyText',
                 buttons_text: 'outputs.BrandingThemeFontsButtonsText',
                 input_labels: 'outputs.BrandingThemeFontsInputLabels',
                 links: 'outputs.BrandingThemeFontsLinks',
                 subtitle: 'outputs.BrandingThemeFontsSubtitle',
                 title: 'outputs.BrandingThemeFontsTitle',
                 font_url: Optional[_builtins.str] = None,
                 links_style: Optional[_builtins.str] = None,
                 reference_text_size: Optional[_builtins.float] = None):
        """
        :param 'BrandingThemeFontsBodyTextArgs' body_text: Body text.
        :param 'BrandingThemeFontsButtonsTextArgs' buttons_text: Buttons text.
        :param 'BrandingThemeFontsInputLabelsArgs' input_labels: Input labels.
        :param 'BrandingThemeFontsLinksArgs' links: Links.
        :param 'BrandingThemeFontsSubtitleArgs' subtitle: Subtitle.
        :param 'BrandingThemeFontsTitleArgs' title: Title.
        :param _builtins.str font_url: Font URL. Defaults to an empty string.
        :param _builtins.str links_style: Links style. Defaults to `normal`.
        :param _builtins.float reference_text_size: Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
        pulumi.set(__self__, "body_text", body_text)
        pulumi.set(__self__, "buttons_text", buttons_text)
        pulumi.set(__self__, "input_labels", input_labels)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "subtitle", subtitle)
        pulumi.set(__self__, "title", title)
        if font_url is not None:
            pulumi.set(__self__, "font_url", font_url)
        if links_style is not None:
            pulumi.set(__self__, "links_style", links_style)
        if reference_text_size is not None:
            pulumi.set(__self__, "reference_text_size", reference_text_size)

    @_builtins.property
    @pulumi.getter(name="bodyText")
    def body_text(self) -> 'outputs.BrandingThemeFontsBodyText':
        """
        Body text.
        """
        return pulumi.get(self, "body_text")

    @_builtins.property
    @pulumi.getter(name="buttonsText")
    def buttons_text(self) -> 'outputs.BrandingThemeFontsButtonsText':
        """
        Buttons text.
        """
        return pulumi.get(self, "buttons_text")

    @_builtins.property
    @pulumi.getter(name="inputLabels")
    def input_labels(self) -> 'outputs.BrandingThemeFontsInputLabels':
        """
        Input labels.
        """
        return pulumi.get(self, "input_labels")

    @_builtins.property
    @pulumi.getter
    def links(self) -> 'outputs.BrandingThemeFontsLinks':
        """
        Links.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def subtitle(self) -> 'outputs.BrandingThemeFontsSubtitle':
        """
        Subtitle.
        """
        return pulumi.get(self, "subtitle")

    @_builtins.property
    @pulumi.getter
    def title(self) -> 'outputs.BrandingThemeFontsTitle':
        """
        Title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="fontUrl")
    def font_url(self) -> Optional[_builtins.str]:
        """
        Font URL. Defaults to an empty string.
        """
        return pulumi.get(self, "font_url")

    @_builtins.property
    @pulumi.getter(name="linksStyle")
    def links_style(self) -> Optional[_builtins.str]:
        """
        Links style. Defaults to `normal`.
        """
        return pulumi.get(self, "links_style")

    @_builtins.property
    @pulumi.getter(name="referenceTextSize")
    def reference_text_size(self) -> Optional[_builtins.float]:
        """
        Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
        return pulumi.get(self, "reference_text_size")


@pulumi.output_type
class BrandingThemeFontsBodyText(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Body text bold. Defaults to `false`.
        :param _builtins.float size: Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Body text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemeFontsButtonsText(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Buttons text bold. Defaults to `false`.
        :param _builtins.float size: Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Buttons text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemeFontsInputLabels(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Input labels bold. Defaults to `false`.
        :param _builtins.float size: Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Input labels bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemeFontsLinks(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Links bold. Defaults to `true`.
        :param _builtins.float size: Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Links bold. Defaults to `true`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemeFontsSubtitle(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Subtitle bold. Defaults to `false`.
        :param _builtins.float size: Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Subtitle bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemeFontsTitle(dict):
    def __init__(__self__, *,
                 bold: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.bool bold: Title bold. Defaults to `false`.
        :param _builtins.float size: Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> Optional[_builtins.bool]:
        """
        Title bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BrandingThemePageBackground(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundImageUrl":
            suggest = "background_image_url"
        elif key == "pageLayout":
            suggest = "page_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingThemePageBackground. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingThemePageBackground.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingThemePageBackground.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[_builtins.str] = None,
                 background_image_url: Optional[_builtins.str] = None,
                 page_layout: Optional[_builtins.str] = None):
        """
        :param _builtins.str background_color: Background color. Defaults to `#000000`.
        :param _builtins.str background_image_url: Background image url. Defaults to an empty string.
        :param _builtins.str page_layout: Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if background_image_url is not None:
            pulumi.set(__self__, "background_image_url", background_image_url)
        if page_layout is not None:
            pulumi.set(__self__, "page_layout", page_layout)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[_builtins.str]:
        """
        Background color. Defaults to `#000000`.
        """
        return pulumi.get(self, "background_color")

    @_builtins.property
    @pulumi.getter(name="backgroundImageUrl")
    def background_image_url(self) -> Optional[_builtins.str]:
        """
        Background image url. Defaults to an empty string.
        """
        return pulumi.get(self, "background_image_url")

    @_builtins.property
    @pulumi.getter(name="pageLayout")
    def page_layout(self) -> Optional[_builtins.str]:
        """
        Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "page_layout")


@pulumi.output_type
class BrandingThemeWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerTextAlignment":
            suggest = "header_text_alignment"
        elif key == "logoHeight":
            suggest = "logo_height"
        elif key == "logoPosition":
            suggest = "logo_position"
        elif key == "logoUrl":
            suggest = "logo_url"
        elif key == "socialButtonsLayout":
            suggest = "social_buttons_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrandingThemeWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrandingThemeWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrandingThemeWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_text_alignment: Optional[_builtins.str] = None,
                 logo_height: Optional[_builtins.float] = None,
                 logo_position: Optional[_builtins.str] = None,
                 logo_url: Optional[_builtins.str] = None,
                 social_buttons_layout: Optional[_builtins.str] = None):
        """
        :param _builtins.str header_text_alignment: Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        :param _builtins.float logo_height: Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        :param _builtins.str logo_position: Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        :param _builtins.str logo_url: Logo url. Defaults to an empty string.
        :param _builtins.str social_buttons_layout: Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        if header_text_alignment is not None:
            pulumi.set(__self__, "header_text_alignment", header_text_alignment)
        if logo_height is not None:
            pulumi.set(__self__, "logo_height", logo_height)
        if logo_position is not None:
            pulumi.set(__self__, "logo_position", logo_position)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)
        if social_buttons_layout is not None:
            pulumi.set(__self__, "social_buttons_layout", social_buttons_layout)

    @_builtins.property
    @pulumi.getter(name="headerTextAlignment")
    def header_text_alignment(self) -> Optional[_builtins.str]:
        """
        Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "header_text_alignment")

    @_builtins.property
    @pulumi.getter(name="logoHeight")
    def logo_height(self) -> Optional[_builtins.float]:
        """
        Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        """
        return pulumi.get(self, "logo_height")

    @_builtins.property
    @pulumi.getter(name="logoPosition")
    def logo_position(self) -> Optional[_builtins.str]:
        """
        Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        """
        return pulumi.get(self, "logo_position")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[_builtins.str]:
        """
        Logo url. Defaults to an empty string.
        """
        return pulumi.get(self, "logo_url")

    @_builtins.property
    @pulumi.getter(name="socialButtonsLayout")
    def social_buttons_layout(self) -> Optional[_builtins.str]:
        """
        Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        return pulumi.get(self, "social_buttons_layout")


@pulumi.output_type
class BrandingUniversalLogin(dict):
    def __init__(__self__, *,
                 body: _builtins.str):
        """
        :param _builtins.str body: The html template for the New Universal Login Experience.
        """
        pulumi.set(__self__, "body", body)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The html template for the New Universal Login Experience.
        """
        return pulumi.get(self, "body")


@pulumi.output_type
class ClientAddons(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlob":
            suggest = "azure_blob"
        elif key == "azureSb":
            suggest = "azure_sb"
        elif key == "salesforceApi":
            suggest = "salesforce_api"
        elif key == "salesforceSandboxApi":
            suggest = "salesforce_sandbox_api"
        elif key == "sapApi":
            suggest = "sap_api"
        elif key == "ssoIntegration":
            suggest = "sso_integration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddons. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddons.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddons.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws: Optional['outputs.ClientAddonsAws'] = None,
                 azure_blob: Optional['outputs.ClientAddonsAzureBlob'] = None,
                 azure_sb: Optional['outputs.ClientAddonsAzureSb'] = None,
                 box: Optional['outputs.ClientAddonsBox'] = None,
                 cloudbees: Optional['outputs.ClientAddonsCloudbees'] = None,
                 concur: Optional['outputs.ClientAddonsConcur'] = None,
                 dropbox: Optional['outputs.ClientAddonsDropbox'] = None,
                 echosign: Optional['outputs.ClientAddonsEchosign'] = None,
                 egnyte: Optional['outputs.ClientAddonsEgnyte'] = None,
                 firebase: Optional['outputs.ClientAddonsFirebase'] = None,
                 layer: Optional['outputs.ClientAddonsLayer'] = None,
                 mscrm: Optional['outputs.ClientAddonsMscrm'] = None,
                 newrelic: Optional['outputs.ClientAddonsNewrelic'] = None,
                 office365: Optional['outputs.ClientAddonsOffice365'] = None,
                 rms: Optional['outputs.ClientAddonsRms'] = None,
                 salesforce: Optional['outputs.ClientAddonsSalesforce'] = None,
                 salesforce_api: Optional['outputs.ClientAddonsSalesforceApi'] = None,
                 salesforce_sandbox_api: Optional['outputs.ClientAddonsSalesforceSandboxApi'] = None,
                 samlp: Optional['outputs.ClientAddonsSamlp'] = None,
                 sap_api: Optional['outputs.ClientAddonsSapApi'] = None,
                 sentry: Optional['outputs.ClientAddonsSentry'] = None,
                 sharepoint: Optional['outputs.ClientAddonsSharepoint'] = None,
                 slack: Optional['outputs.ClientAddonsSlack'] = None,
                 springcm: Optional['outputs.ClientAddonsSpringcm'] = None,
                 sso_integration: Optional['outputs.ClientAddonsSsoIntegration'] = None,
                 wams: Optional['outputs.ClientAddonsWams'] = None,
                 wsfed: Optional['outputs.ClientAddonsWsfed'] = None,
                 zendesk: Optional['outputs.ClientAddonsZendesk'] = None,
                 zoom: Optional['outputs.ClientAddonsZoom'] = None):
        """
        :param 'ClientAddonsAwsArgs' aws: AWS Addon configuration.
        :param 'ClientAddonsAzureBlobArgs' azure_blob: Azure Blob Storage Addon configuration.
        :param 'ClientAddonsAzureSbArgs' azure_sb: Azure Storage Bus Addon configuration.
        :param 'ClientAddonsBoxArgs' box: Box SSO indicator (no configuration settings needed for Box SSO).
        :param 'ClientAddonsCloudbeesArgs' cloudbees: CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        :param 'ClientAddonsConcurArgs' concur: Concur SSO indicator (no configuration settings needed for Concur SSO).
        :param 'ClientAddonsDropboxArgs' dropbox: Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        :param 'ClientAddonsEchosignArgs' echosign: Adobe EchoSign SSO configuration.
        :param 'ClientAddonsEgnyteArgs' egnyte: Egnyte SSO configuration.
        :param 'ClientAddonsFirebaseArgs' firebase: Google Firebase addon configuration.
        :param 'ClientAddonsLayerArgs' layer: Layer addon configuration.
        :param 'ClientAddonsMscrmArgs' mscrm: Microsoft Dynamics CRM SSO configuration.
        :param 'ClientAddonsNewrelicArgs' newrelic: New Relic SSO configuration.
        :param 'ClientAddonsOffice365Args' office365: Microsoft Office 365 SSO configuration.
        :param 'ClientAddonsRmsArgs' rms: Active Directory Rights Management Service SSO configuration.
        :param 'ClientAddonsSalesforceArgs' salesforce: Salesforce SSO configuration.
        :param 'ClientAddonsSalesforceApiArgs' salesforce_api: Salesforce API addon configuration.
        :param 'ClientAddonsSalesforceSandboxApiArgs' salesforce_sandbox_api: Salesforce Sandbox addon configuration.
        :param 'ClientAddonsSamlpArgs' samlp: Configuration settings for a SAML add-on.
        :param 'ClientAddonsSapApiArgs' sap_api: SAP API addon configuration.
        :param 'ClientAddonsSentryArgs' sentry: Sentry SSO configuration.
        :param 'ClientAddonsSharepointArgs' sharepoint: SharePoint SSO configuration.
        :param 'ClientAddonsSlackArgs' slack: Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        :param 'ClientAddonsSpringcmArgs' springcm: SpringCM SSO configuration.
        :param 'ClientAddonsSsoIntegrationArgs' sso_integration: Generic SSO configuration.
        :param 'ClientAddonsWamsArgs' wams: Windows Azure Mobile Services addon configuration.
        :param 'ClientAddonsWsfedArgs' wsfed: WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        :param 'ClientAddonsZendeskArgs' zendesk: Zendesk SSO configuration.
        :param 'ClientAddonsZoomArgs' zoom: Zoom SSO configuration.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if azure_blob is not None:
            pulumi.set(__self__, "azure_blob", azure_blob)
        if azure_sb is not None:
            pulumi.set(__self__, "azure_sb", azure_sb)
        if box is not None:
            pulumi.set(__self__, "box", box)
        if cloudbees is not None:
            pulumi.set(__self__, "cloudbees", cloudbees)
        if concur is not None:
            pulumi.set(__self__, "concur", concur)
        if dropbox is not None:
            pulumi.set(__self__, "dropbox", dropbox)
        if echosign is not None:
            pulumi.set(__self__, "echosign", echosign)
        if egnyte is not None:
            pulumi.set(__self__, "egnyte", egnyte)
        if firebase is not None:
            pulumi.set(__self__, "firebase", firebase)
        if layer is not None:
            pulumi.set(__self__, "layer", layer)
        if mscrm is not None:
            pulumi.set(__self__, "mscrm", mscrm)
        if newrelic is not None:
            pulumi.set(__self__, "newrelic", newrelic)
        if office365 is not None:
            pulumi.set(__self__, "office365", office365)
        if rms is not None:
            pulumi.set(__self__, "rms", rms)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if salesforce_api is not None:
            pulumi.set(__self__, "salesforce_api", salesforce_api)
        if salesforce_sandbox_api is not None:
            pulumi.set(__self__, "salesforce_sandbox_api", salesforce_sandbox_api)
        if samlp is not None:
            pulumi.set(__self__, "samlp", samlp)
        if sap_api is not None:
            pulumi.set(__self__, "sap_api", sap_api)
        if sentry is not None:
            pulumi.set(__self__, "sentry", sentry)
        if sharepoint is not None:
            pulumi.set(__self__, "sharepoint", sharepoint)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if springcm is not None:
            pulumi.set(__self__, "springcm", springcm)
        if sso_integration is not None:
            pulumi.set(__self__, "sso_integration", sso_integration)
        if wams is not None:
            pulumi.set(__self__, "wams", wams)
        if wsfed is not None:
            pulumi.set(__self__, "wsfed", wsfed)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)
        if zoom is not None:
            pulumi.set(__self__, "zoom", zoom)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional['outputs.ClientAddonsAws']:
        """
        AWS Addon configuration.
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter(name="azureBlob")
    def azure_blob(self) -> Optional['outputs.ClientAddonsAzureBlob']:
        """
        Azure Blob Storage Addon configuration.
        """
        return pulumi.get(self, "azure_blob")

    @_builtins.property
    @pulumi.getter(name="azureSb")
    def azure_sb(self) -> Optional['outputs.ClientAddonsAzureSb']:
        """
        Azure Storage Bus Addon configuration.
        """
        return pulumi.get(self, "azure_sb")

    @_builtins.property
    @pulumi.getter
    def box(self) -> Optional['outputs.ClientAddonsBox']:
        """
        Box SSO indicator (no configuration settings needed for Box SSO).
        """
        return pulumi.get(self, "box")

    @_builtins.property
    @pulumi.getter
    def cloudbees(self) -> Optional['outputs.ClientAddonsCloudbees']:
        """
        CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        """
        return pulumi.get(self, "cloudbees")

    @_builtins.property
    @pulumi.getter
    def concur(self) -> Optional['outputs.ClientAddonsConcur']:
        """
        Concur SSO indicator (no configuration settings needed for Concur SSO).
        """
        return pulumi.get(self, "concur")

    @_builtins.property
    @pulumi.getter
    def dropbox(self) -> Optional['outputs.ClientAddonsDropbox']:
        """
        Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        """
        return pulumi.get(self, "dropbox")

    @_builtins.property
    @pulumi.getter
    def echosign(self) -> Optional['outputs.ClientAddonsEchosign']:
        """
        Adobe EchoSign SSO configuration.
        """
        return pulumi.get(self, "echosign")

    @_builtins.property
    @pulumi.getter
    def egnyte(self) -> Optional['outputs.ClientAddonsEgnyte']:
        """
        Egnyte SSO configuration.
        """
        return pulumi.get(self, "egnyte")

    @_builtins.property
    @pulumi.getter
    def firebase(self) -> Optional['outputs.ClientAddonsFirebase']:
        """
        Google Firebase addon configuration.
        """
        return pulumi.get(self, "firebase")

    @_builtins.property
    @pulumi.getter
    def layer(self) -> Optional['outputs.ClientAddonsLayer']:
        """
        Layer addon configuration.
        """
        return pulumi.get(self, "layer")

    @_builtins.property
    @pulumi.getter
    def mscrm(self) -> Optional['outputs.ClientAddonsMscrm']:
        """
        Microsoft Dynamics CRM SSO configuration.
        """
        return pulumi.get(self, "mscrm")

    @_builtins.property
    @pulumi.getter
    def newrelic(self) -> Optional['outputs.ClientAddonsNewrelic']:
        """
        New Relic SSO configuration.
        """
        return pulumi.get(self, "newrelic")

    @_builtins.property
    @pulumi.getter
    def office365(self) -> Optional['outputs.ClientAddonsOffice365']:
        """
        Microsoft Office 365 SSO configuration.
        """
        return pulumi.get(self, "office365")

    @_builtins.property
    @pulumi.getter
    def rms(self) -> Optional['outputs.ClientAddonsRms']:
        """
        Active Directory Rights Management Service SSO configuration.
        """
        return pulumi.get(self, "rms")

    @_builtins.property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.ClientAddonsSalesforce']:
        """
        Salesforce SSO configuration.
        """
        return pulumi.get(self, "salesforce")

    @_builtins.property
    @pulumi.getter(name="salesforceApi")
    def salesforce_api(self) -> Optional['outputs.ClientAddonsSalesforceApi']:
        """
        Salesforce API addon configuration.
        """
        return pulumi.get(self, "salesforce_api")

    @_builtins.property
    @pulumi.getter(name="salesforceSandboxApi")
    def salesforce_sandbox_api(self) -> Optional['outputs.ClientAddonsSalesforceSandboxApi']:
        """
        Salesforce Sandbox addon configuration.
        """
        return pulumi.get(self, "salesforce_sandbox_api")

    @_builtins.property
    @pulumi.getter
    def samlp(self) -> Optional['outputs.ClientAddonsSamlp']:
        """
        Configuration settings for a SAML add-on.
        """
        return pulumi.get(self, "samlp")

    @_builtins.property
    @pulumi.getter(name="sapApi")
    def sap_api(self) -> Optional['outputs.ClientAddonsSapApi']:
        """
        SAP API addon configuration.
        """
        return pulumi.get(self, "sap_api")

    @_builtins.property
    @pulumi.getter
    def sentry(self) -> Optional['outputs.ClientAddonsSentry']:
        """
        Sentry SSO configuration.
        """
        return pulumi.get(self, "sentry")

    @_builtins.property
    @pulumi.getter
    def sharepoint(self) -> Optional['outputs.ClientAddonsSharepoint']:
        """
        SharePoint SSO configuration.
        """
        return pulumi.get(self, "sharepoint")

    @_builtins.property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ClientAddonsSlack']:
        """
        Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        """
        return pulumi.get(self, "slack")

    @_builtins.property
    @pulumi.getter
    def springcm(self) -> Optional['outputs.ClientAddonsSpringcm']:
        """
        SpringCM SSO configuration.
        """
        return pulumi.get(self, "springcm")

    @_builtins.property
    @pulumi.getter(name="ssoIntegration")
    def sso_integration(self) -> Optional['outputs.ClientAddonsSsoIntegration']:
        """
        Generic SSO configuration.
        """
        return pulumi.get(self, "sso_integration")

    @_builtins.property
    @pulumi.getter
    def wams(self) -> Optional['outputs.ClientAddonsWams']:
        """
        Windows Azure Mobile Services addon configuration.
        """
        return pulumi.get(self, "wams")

    @_builtins.property
    @pulumi.getter
    def wsfed(self) -> Optional['outputs.ClientAddonsWsfed']:
        """
        WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        """
        return pulumi.get(self, "wsfed")

    @_builtins.property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.ClientAddonsZendesk']:
        """
        Zendesk SSO configuration.
        """
        return pulumi.get(self, "zendesk")

    @_builtins.property
    @pulumi.getter
    def zoom(self) -> Optional['outputs.ClientAddonsZoom']:
        """
        Zoom SSO configuration.
        """
        return pulumi.get(self, "zoom")


@pulumi.output_type
class ClientAddonsAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifetimeInSeconds":
            suggest = "lifetime_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifetime_in_seconds: Optional[_builtins.int] = None,
                 principal: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param _builtins.int lifetime_in_seconds: AWS token lifetime in seconds.
        :param _builtins.str principal: AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        :param _builtins.str role: AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        AWS token lifetime in seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ClientAddonsAzureBlob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "blobDelete":
            suggest = "blob_delete"
        elif key == "blobName":
            suggest = "blob_name"
        elif key == "blobRead":
            suggest = "blob_read"
        elif key == "blobWrite":
            suggest = "blob_write"
        elif key == "containerDelete":
            suggest = "container_delete"
        elif key == "containerList":
            suggest = "container_list"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "containerRead":
            suggest = "container_read"
        elif key == "containerWrite":
            suggest = "container_write"
        elif key == "signedIdentifier":
            suggest = "signed_identifier"
        elif key == "storageAccessKey":
            suggest = "storage_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsAzureBlob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsAzureBlob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsAzureBlob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[_builtins.str] = None,
                 blob_delete: Optional[_builtins.bool] = None,
                 blob_name: Optional[_builtins.str] = None,
                 blob_read: Optional[_builtins.bool] = None,
                 blob_write: Optional[_builtins.bool] = None,
                 container_delete: Optional[_builtins.bool] = None,
                 container_list: Optional[_builtins.bool] = None,
                 container_name: Optional[_builtins.str] = None,
                 container_read: Optional[_builtins.bool] = None,
                 container_write: Optional[_builtins.bool] = None,
                 expiration: Optional[_builtins.int] = None,
                 signed_identifier: Optional[_builtins.str] = None,
                 storage_access_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_name: Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        :param _builtins.bool blob_delete: Indicates if the issued token has permission to delete the blob.
        :param _builtins.str blob_name: Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        :param _builtins.bool blob_read: Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        :param _builtins.bool blob_write: Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param _builtins.bool container_delete: Indicates if issued token has permission to delete any blob in the container.
        :param _builtins.bool container_list: Indicates if the issued token has permission to list blobs in the container.
        :param _builtins.str container_name: Container to request a token for, such as `my-container`.
        :param _builtins.bool container_read: Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        :param _builtins.bool container_write: Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param _builtins.int expiration: Expiration in minutes for the generated token (default of 5 minutes).
        :param _builtins.str signed_identifier: Shared access policy identifier defined in your storage account resource.
        :param _builtins.str storage_access_key: Access key associated with this storage account.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if blob_delete is not None:
            pulumi.set(__self__, "blob_delete", blob_delete)
        if blob_name is not None:
            pulumi.set(__self__, "blob_name", blob_name)
        if blob_read is not None:
            pulumi.set(__self__, "blob_read", blob_read)
        if blob_write is not None:
            pulumi.set(__self__, "blob_write", blob_write)
        if container_delete is not None:
            pulumi.set(__self__, "container_delete", container_delete)
        if container_list is not None:
            pulumi.set(__self__, "container_list", container_list)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_read is not None:
            pulumi.set(__self__, "container_read", container_read)
        if container_write is not None:
            pulumi.set(__self__, "container_write", container_write)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if signed_identifier is not None:
            pulumi.set(__self__, "signed_identifier", signed_identifier)
        if storage_access_key is not None:
            pulumi.set(__self__, "storage_access_key", storage_access_key)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="blobDelete")
    def blob_delete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the issued token has permission to delete the blob.
        """
        return pulumi.get(self, "blob_delete")

    @_builtins.property
    @pulumi.getter(name="blobName")
    def blob_name(self) -> Optional[_builtins.str]:
        """
        Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        """
        return pulumi.get(self, "blob_name")

    @_builtins.property
    @pulumi.getter(name="blobRead")
    def blob_read(self) -> Optional[_builtins.bool]:
        """
        Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        """
        return pulumi.get(self, "blob_read")

    @_builtins.property
    @pulumi.getter(name="blobWrite")
    def blob_write(self) -> Optional[_builtins.bool]:
        """
        Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "blob_write")

    @_builtins.property
    @pulumi.getter(name="containerDelete")
    def container_delete(self) -> Optional[_builtins.bool]:
        """
        Indicates if issued token has permission to delete any blob in the container.
        """
        return pulumi.get(self, "container_delete")

    @_builtins.property
    @pulumi.getter(name="containerList")
    def container_list(self) -> Optional[_builtins.bool]:
        """
        Indicates if the issued token has permission to list blobs in the container.
        """
        return pulumi.get(self, "container_list")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[_builtins.str]:
        """
        Container to request a token for, such as `my-container`.
        """
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter(name="containerRead")
    def container_read(self) -> Optional[_builtins.bool]:
        """
        Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        """
        return pulumi.get(self, "container_read")

    @_builtins.property
    @pulumi.getter(name="containerWrite")
    def container_write(self) -> Optional[_builtins.bool]:
        """
        Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "container_write")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.int]:
        """
        Expiration in minutes for the generated token (default of 5 minutes).
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="signedIdentifier")
    def signed_identifier(self) -> Optional[_builtins.str]:
        """
        Shared access policy identifier defined in your storage account resource.
        """
        return pulumi.get(self, "signed_identifier")

    @_builtins.property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> Optional[_builtins.str]:
        """
        Access key associated with this storage account.
        """
        return pulumi.get(self, "storage_access_key")


@pulumi.output_type
class ClientAddonsAzureSb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityPath":
            suggest = "entity_path"
        elif key == "sasKey":
            suggest = "sas_key"
        elif key == "sasKeyName":
            suggest = "sas_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsAzureSb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsAzureSb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsAzureSb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_path: Optional[_builtins.str] = None,
                 expiration: Optional[_builtins.int] = None,
                 namespace: Optional[_builtins.str] = None,
                 sas_key: Optional[_builtins.str] = None,
                 sas_key_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str entity_path: Entity you want to request a token for, such as `my-queue`.
        :param _builtins.int expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param _builtins.str namespace: Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        :param _builtins.str sas_key: Primary Key associated with your shared access policy.
        :param _builtins.str sas_key_name: Your shared access policy name defined in your Service Bus entity.
        """
        if entity_path is not None:
            pulumi.set(__self__, "entity_path", entity_path)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sas_key is not None:
            pulumi.set(__self__, "sas_key", sas_key)
        if sas_key_name is not None:
            pulumi.set(__self__, "sas_key_name", sas_key_name)

    @_builtins.property
    @pulumi.getter(name="entityPath")
    def entity_path(self) -> Optional[_builtins.str]:
        """
        Entity you want to request a token for, such as `my-queue`.
        """
        return pulumi.get(self, "entity_path")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.int]:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="sasKey")
    def sas_key(self) -> Optional[_builtins.str]:
        """
        Primary Key associated with your shared access policy.
        """
        return pulumi.get(self, "sas_key")

    @_builtins.property
    @pulumi.getter(name="sasKeyName")
    def sas_key_name(self) -> Optional[_builtins.str]:
        """
        Your shared access policy name defined in your Service Bus entity.
        """
        return pulumi.get(self, "sas_key_name")


@pulumi.output_type
class ClientAddonsBox(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClientAddonsCloudbees(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClientAddonsConcur(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClientAddonsDropbox(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClientAddonsEchosign(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ClientAddonsEgnyte(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ClientAddonsFirebase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"
        elif key == "lifetimeInSeconds":
            suggest = "lifetime_in_seconds"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsFirebase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsFirebase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsFirebase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_email: Optional[_builtins.str] = None,
                 lifetime_in_seconds: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 private_key_id: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_email: ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        :param _builtins.int lifetime_in_seconds: Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        :param _builtins.str private_key: Private Key for signing the token (SDK v3+ tokens only).
        :param _builtins.str private_key_id: Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        :param _builtins.str secret: Google Firebase Secret. (SDK v2 only).
        """
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[_builtins.str]:
        """
        ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        """
        return pulumi.get(self, "client_email")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Private Key for signing the token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[_builtins.str]:
        """
        Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Google Firebase Secret. (SDK v2 only).
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ClientAddonsLayer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "providerId":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsLayer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsLayer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsLayer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: _builtins.str,
                 private_key: _builtins.str,
                 provider_id: _builtins.str,
                 expiration: Optional[_builtins.int] = None,
                 principal: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_id: Authentication Key identifier used to sign the Layer token.
        :param _builtins.str private_key: Private key for signing the Layer token.
        :param _builtins.str provider_id: Provider ID of your Layer account.
        :param _builtins.int expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param _builtins.str principal: Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "provider_id", provider_id)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        Authentication Key identifier used to sign the Layer token.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        Private key for signing the Layer token.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        """
        Provider ID of your Layer account.
        """
        return pulumi.get(self, "provider_id")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.int]:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class ClientAddonsMscrm(dict):
    def __init__(__self__, *,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Microsoft Dynamics CRM application URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Microsoft Dynamics CRM application URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClientAddonsNewrelic(dict):
    def __init__(__self__, *,
                 account: Optional[_builtins.str] = None):
        """
        :param _builtins.str account: Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[_builtins.str]:
        """
        Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class ClientAddonsOffice365(dict):
    def __init__(__self__, *,
                 connection: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection: Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        :param _builtins.str domain: Your Office 365 domain name, for example `acme-org.com`.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional[_builtins.str]:
        """
        Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Your Office 365 domain name, for example `acme-org.com`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class ClientAddonsRms(dict):
    def __init__(__self__, *,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClientAddonsSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str entity_id: Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[_builtins.str]:
        """
        Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        return pulumi.get(self, "entity_id")


@pulumi.output_type
class ClientAddonsSalesforceApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "communityName":
            suggest = "community_name"
        elif key == "communityUrlSection":
            suggest = "community_url_section"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSalesforceApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSalesforceApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSalesforceApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 community_name: Optional[_builtins.str] = None,
                 community_url_section: Optional[_builtins.str] = None,
                 principal: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param _builtins.str community_name: Community name.
        :param _builtins.str community_url_section: Community URL section.
        :param _builtins.str principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if community_url_section is not None:
            pulumi.set(__self__, "community_url_section", community_url_section)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[_builtins.str]:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> Optional[_builtins.str]:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class ClientAddonsSalesforceSandboxApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "communityName":
            suggest = "community_name"
        elif key == "communityUrlSection":
            suggest = "community_url_section"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSalesforceSandboxApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSalesforceSandboxApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSalesforceSandboxApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 community_name: Optional[_builtins.str] = None,
                 community_url_section: Optional[_builtins.str] = None,
                 principal: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param _builtins.str community_name: Community name.
        :param _builtins.str community_url_section: Community URL section.
        :param _builtins.str principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if community_url_section is not None:
            pulumi.set(__self__, "community_url_section", community_url_section)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[_builtins.str]:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> Optional[_builtins.str]:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class ClientAddonsSamlp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authnContextClassRef":
            suggest = "authn_context_class_ref"
        elif key == "createUpnClaim":
            suggest = "create_upn_claim"
        elif key == "digestAlgorithm":
            suggest = "digest_algorithm"
        elif key == "flexibleMappings":
            suggest = "flexible_mappings"
        elif key == "includeAttributeNameFormat":
            suggest = "include_attribute_name_format"
        elif key == "lifetimeInSeconds":
            suggest = "lifetime_in_seconds"
        elif key == "mapIdentities":
            suggest = "map_identities"
        elif key == "mapUnknownClaimsAsIs":
            suggest = "map_unknown_claims_as_is"
        elif key == "nameIdentifierFormat":
            suggest = "name_identifier_format"
        elif key == "nameIdentifierProbes":
            suggest = "name_identifier_probes"
        elif key == "passthroughClaimsWithNoMapping":
            suggest = "passthrough_claims_with_no_mapping"
        elif key == "signResponse":
            suggest = "sign_response"
        elif key == "signatureAlgorithm":
            suggest = "signature_algorithm"
        elif key == "signingCert":
            suggest = "signing_cert"
        elif key == "typedAttributes":
            suggest = "typed_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSamlp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSamlp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSamlp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[_builtins.str] = None,
                 authn_context_class_ref: Optional[_builtins.str] = None,
                 binding: Optional[_builtins.str] = None,
                 create_upn_claim: Optional[_builtins.bool] = None,
                 destination: Optional[_builtins.str] = None,
                 digest_algorithm: Optional[_builtins.str] = None,
                 flexible_mappings: Optional[_builtins.str] = None,
                 include_attribute_name_format: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 lifetime_in_seconds: Optional[_builtins.int] = None,
                 logout: Optional['outputs.ClientAddonsSamlpLogout'] = None,
                 map_identities: Optional[_builtins.bool] = None,
                 map_unknown_claims_as_is: Optional[_builtins.bool] = None,
                 mappings: Optional[Mapping[str, _builtins.str]] = None,
                 name_identifier_format: Optional[_builtins.str] = None,
                 name_identifier_probes: Optional[Sequence[_builtins.str]] = None,
                 passthrough_claims_with_no_mapping: Optional[_builtins.bool] = None,
                 recipient: Optional[_builtins.str] = None,
                 sign_response: Optional[_builtins.bool] = None,
                 signature_algorithm: Optional[_builtins.str] = None,
                 signing_cert: Optional[_builtins.str] = None,
                 typed_attributes: Optional[_builtins.bool] = None):
        """
        :param _builtins.str audience: Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        :param _builtins.str authn_context_class_ref: Class reference of the authentication context.
        :param _builtins.str binding: Protocol binding used for SAML logout responses.
        :param _builtins.bool create_upn_claim: Indicates whether a UPN claim should be created. Defaults to `true`.
        :param _builtins.str destination: Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        :param _builtins.str digest_algorithm: Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        :param _builtins.str flexible_mappings: This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
        :param _builtins.bool include_attribute_name_format: Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        :param _builtins.str issuer: Issuer of the SAML Assertion.
        :param _builtins.int lifetime_in_seconds: Number of seconds during which the token is valid. Defaults to `3600` seconds.
        :param 'ClientAddonsSamlpLogoutArgs' logout: Configuration settings for logout.
        :param _builtins.bool map_identities: Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        :param _builtins.bool map_unknown_claims_as_is: Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        :param Mapping[str, _builtins.str] mappings: Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        :param _builtins.str name_identifier_format: Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param Sequence[_builtins.str] name_identifier_probes: Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        :param _builtins.bool passthrough_claims_with_no_mapping: Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        :param _builtins.str recipient: Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        :param _builtins.bool sign_response: Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        :param _builtins.str signature_algorithm: Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        :param _builtins.str signing_cert: Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        :param _builtins.bool typed_attributes: Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if authn_context_class_ref is not None:
            pulumi.set(__self__, "authn_context_class_ref", authn_context_class_ref)
        if binding is not None:
            pulumi.set(__self__, "binding", binding)
        if create_upn_claim is not None:
            pulumi.set(__self__, "create_upn_claim", create_upn_claim)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if digest_algorithm is not None:
            pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        if flexible_mappings is not None:
            pulumi.set(__self__, "flexible_mappings", flexible_mappings)
        if include_attribute_name_format is not None:
            pulumi.set(__self__, "include_attribute_name_format", include_attribute_name_format)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if logout is not None:
            pulumi.set(__self__, "logout", logout)
        if map_identities is not None:
            pulumi.set(__self__, "map_identities", map_identities)
        if map_unknown_claims_as_is is not None:
            pulumi.set(__self__, "map_unknown_claims_as_is", map_unknown_claims_as_is)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if name_identifier_format is not None:
            pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        if name_identifier_probes is not None:
            pulumi.set(__self__, "name_identifier_probes", name_identifier_probes)
        if passthrough_claims_with_no_mapping is not None:
            pulumi.set(__self__, "passthrough_claims_with_no_mapping", passthrough_claims_with_no_mapping)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if sign_response is not None:
            pulumi.set(__self__, "sign_response", sign_response)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if signing_cert is not None:
            pulumi.set(__self__, "signing_cert", signing_cert)
        if typed_attributes is not None:
            pulumi.set(__self__, "typed_attributes", typed_attributes)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[_builtins.str]:
        """
        Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter(name="authnContextClassRef")
    def authn_context_class_ref(self) -> Optional[_builtins.str]:
        """
        Class reference of the authentication context.
        """
        return pulumi.get(self, "authn_context_class_ref")

    @_builtins.property
    @pulumi.getter
    def binding(self) -> Optional[_builtins.str]:
        """
        Protocol binding used for SAML logout responses.
        """
        return pulumi.get(self, "binding")

    @_builtins.property
    @pulumi.getter(name="createUpnClaim")
    def create_upn_claim(self) -> Optional[_builtins.bool]:
        """
        Indicates whether a UPN claim should be created. Defaults to `true`.
        """
        return pulumi.get(self, "create_upn_claim")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> Optional[_builtins.str]:
        """
        Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        """
        return pulumi.get(self, "digest_algorithm")

    @_builtins.property
    @pulumi.getter(name="flexibleMappings")
    def flexible_mappings(self) -> Optional[_builtins.str]:
        """
        This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
        """
        return pulumi.get(self, "flexible_mappings")

    @_builtins.property
    @pulumi.getter(name="includeAttributeNameFormat")
    def include_attribute_name_format(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        """
        return pulumi.get(self, "include_attribute_name_format")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        Issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds during which the token is valid. Defaults to `3600` seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def logout(self) -> Optional['outputs.ClientAddonsSamlpLogout']:
        """
        Configuration settings for logout.
        """
        return pulumi.get(self, "logout")

    @_builtins.property
    @pulumi.getter(name="mapIdentities")
    def map_identities(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        """
        return pulumi.get(self, "map_identities")

    @_builtins.property
    @pulumi.getter(name="mapUnknownClaimsAsIs")
    def map_unknown_claims_as_is(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        """
        return pulumi.get(self, "map_unknown_claims_as_is")

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        """
        return pulumi.get(self, "mappings")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> Optional[_builtins.str]:
        """
        Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierProbes")
    def name_identifier_probes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        """
        return pulumi.get(self, "name_identifier_probes")

    @_builtins.property
    @pulumi.getter(name="passthroughClaimsWithNoMapping")
    def passthrough_claims_with_no_mapping(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        """
        return pulumi.get(self, "passthrough_claims_with_no_mapping")

    @_builtins.property
    @pulumi.getter
    def recipient(self) -> Optional[_builtins.str]:
        """
        Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        """
        return pulumi.get(self, "recipient")

    @_builtins.property
    @pulumi.getter(name="signResponse")
    def sign_response(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        """
        return pulumi.get(self, "sign_response")

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[_builtins.str]:
        """
        Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        """
        return pulumi.get(self, "signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> Optional[_builtins.str]:
        """
        Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        """
        return pulumi.get(self, "signing_cert")

    @_builtins.property
    @pulumi.getter(name="typedAttributes")
    def typed_attributes(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        return pulumi.get(self, "typed_attributes")


@pulumi.output_type
class ClientAddonsSamlpLogout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloEnabled":
            suggest = "slo_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSamlpLogout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSamlpLogout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSamlpLogout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 callback: Optional[_builtins.str] = None,
                 slo_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str callback: The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        :param _builtins.bool slo_enabled: Controls whether Auth0 should notify service providers of session termination.
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if slo_enabled is not None:
            pulumi.set(__self__, "slo_enabled", slo_enabled)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> Optional[_builtins.str]:
        """
        The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        """
        return pulumi.get(self, "callback")

    @_builtins.property
    @pulumi.getter(name="sloEnabled")
    def slo_enabled(self) -> Optional[_builtins.bool]:
        """
        Controls whether Auth0 should notify service providers of session termination.
        """
        return pulumi.get(self, "slo_enabled")


@pulumi.output_type
class ClientAddonsSapApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "nameIdentifierFormat":
            suggest = "name_identifier_format"
        elif key == "servicePassword":
            suggest = "service_password"
        elif key == "tokenEndpointUrl":
            suggest = "token_endpoint_url"
        elif key == "usernameAttribute":
            suggest = "username_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSapApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSapApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSapApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 name_identifier_format: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 service_password: Optional[_builtins.str] = None,
                 token_endpoint_url: Optional[_builtins.str] = None,
                 username_attribute: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute`client*id`must be set and equal the`client*id` form parameter of the access token request.
        :param _builtins.str name_identifier_format: NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param _builtins.str scope: Requested scope for SAP APIs.
        :param _builtins.str service_password: Service account password to use to authenticate API calls to the token endpoint.
        :param _builtins.str token_endpoint_url: The OAuth2 token endpoint URL of your SAP OData server.
        :param _builtins.str username_attribute: Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name_identifier_format is not None:
            pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if service_password is not None:
            pulumi.set(__self__, "service_password", service_password)
        if token_endpoint_url is not None:
            pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        if username_attribute is not None:
            pulumi.set(__self__, "username_attribute", username_attribute)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute`client*id`must be set and equal the`client*id` form parameter of the access token request.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> Optional[_builtins.str]:
        """
        NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        Requested scope for SAP APIs.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="servicePassword")
    def service_password(self) -> Optional[_builtins.str]:
        """
        Service account password to use to authenticate API calls to the token endpoint.
        """
        return pulumi.get(self, "service_password")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> Optional[_builtins.str]:
        """
        The OAuth2 token endpoint URL of your SAP OData server.
        """
        return pulumi.get(self, "token_endpoint_url")

    @_builtins.property
    @pulumi.getter(name="usernameAttribute")
    def username_attribute(self) -> Optional[_builtins.str]:
        """
        Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        return pulumi.get(self, "username_attribute")


@pulumi.output_type
class ClientAddonsSentry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "orgSlug":
            suggest = "org_slug"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSentry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSentry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSentry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: Optional[_builtins.str] = None,
                 org_slug: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_url: URL prefix only if running Sentry Community Edition, otherwise leave empty.
        :param _builtins.str org_slug: Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if org_slug is not None:
            pulumi.set(__self__, "org_slug", org_slug)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        URL prefix only if running Sentry Community Edition, otherwise leave empty.
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="orgSlug")
    def org_slug(self) -> Optional[_builtins.str]:
        """
        Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        return pulumi.get(self, "org_slug")


@pulumi.output_type
class ClientAddonsSharepoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalUrls":
            suggest = "external_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSharepoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSharepoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSharepoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_urls: Optional[Sequence[_builtins.str]] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] external_urls: External SharePoint application URLs if exposed to the Internet.
        :param _builtins.str url: Internal SharePoint application URL.
        """
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        External SharePoint application URLs if exposed to the Internet.
        """
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Internal SharePoint application URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClientAddonsSlack(dict):
    def __init__(__self__, *,
                 team: Optional[_builtins.str] = None):
        """
        :param _builtins.str team: Slack team name.
        """
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[_builtins.str]:
        """
        Slack team name.
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class ClientAddonsSpringcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acsUrl":
            suggest = "acs_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsSpringcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsSpringcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsSpringcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acs_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str acs_url: SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        if acs_url is not None:
            pulumi.set(__self__, "acs_url", acs_url)

    @_builtins.property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> Optional[_builtins.str]:
        """
        SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        return pulumi.get(self, "acs_url")


@pulumi.output_type
class ClientAddonsSsoIntegration(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: SSO integration name.
        :param _builtins.str version: SSO integration version installed.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        SSO integration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        SSO integration version installed.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClientAddonsWams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterKey":
            suggest = "master_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsWams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsWams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsWams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str master_key: Your master key for Windows Azure Mobile Services.
        """
        if master_key is not None:
            pulumi.set(__self__, "master_key", master_key)

    @_builtins.property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> Optional[_builtins.str]:
        """
        Your master key for Windows Azure Mobile Services.
        """
        return pulumi.get(self, "master_key")


@pulumi.output_type
class ClientAddonsWsfed(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClientAddonsZendesk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAddonsZendesk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAddonsZendesk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAddonsZendesk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_name: Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        return pulumi.get(self, "account_name")


@pulumi.output_type
class ClientAddonsZoom(dict):
    def __init__(__self__, *,
                 account: Optional[_builtins.str] = None):
        """
        :param _builtins.str account: Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[_builtins.str]:
        """
        Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class ClientCredentialsPrivateKeyJwt(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.ClientCredentialsPrivateKeyJwtCredential']):
        """
        :param Sequence['ClientCredentialsPrivateKeyJwtCredentialArgs'] credentials: Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.ClientCredentialsPrivateKeyJwtCredential']:
        """
        Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class ClientCredentialsPrivateKeyJwtCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialType":
            suggest = "credential_type"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "parseExpiryFromCert":
            suggest = "parse_expiry_from_cert"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsPrivateKeyJwtCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsPrivateKeyJwtCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsPrivateKeyJwtCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_type: _builtins.str,
                 pem: _builtins.str,
                 algorithm: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 key_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 parse_expiry_from_cert: Optional[_builtins.bool] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str credential_type: Credential type. Supported types: `public_key`.
        :param _builtins.str pem: PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        :param _builtins.str algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str expires_at: The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str key_id: The key identifier of the credential, generated on creation.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.bool parse_expiry_from_cert: Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "pem", pem)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parse_expiry_from_cert is not None:
            pulumi.set(__self__, "parse_expiry_from_cert", parse_expiry_from_cert)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def pem(self) -> _builtins.str:
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parseExpiryFromCert")
    def parse_expiry_from_cert(self) -> Optional[_builtins.bool]:
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        return pulumi.get(self, "parse_expiry_from_cert")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ClientCredentialsSelfSignedTlsClientAuth(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.ClientCredentialsSelfSignedTlsClientAuthCredential']):
        """
        :param Sequence['ClientCredentialsSelfSignedTlsClientAuthCredentialArgs'] credentials: Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.ClientCredentialsSelfSignedTlsClientAuthCredential']:
        """
        Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class ClientCredentialsSelfSignedTlsClientAuthCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "thumbprintSha256":
            suggest = "thumbprint_sha256"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsSelfSignedTlsClientAuthCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsSelfSignedTlsClientAuthCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsSelfSignedTlsClientAuthCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pem: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 credential_type: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 thumbprint_sha256: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str pem: PEM-formatted X509 certificate. Must be JSON escaped.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str credential_type: Credential type. Supported types: `x509_cert`.
        :param _builtins.str expires_at: The ISO 8601 formatted date representing the expiration of the credential.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str thumbprint_sha256: The X509 certificate's SHA256 thumbprint.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "pem", pem)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if thumbprint_sha256 is not None:
            pulumi.set(__self__, "thumbprint_sha256", thumbprint_sha256)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def pem(self) -> _builtins.str:
        """
        PEM-formatted X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[_builtins.str]:
        """
        Credential type. Supported types: `x509_cert`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date representing the expiration of the credential.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="thumbprintSha256")
    def thumbprint_sha256(self) -> Optional[_builtins.str]:
        """
        The X509 certificate's SHA256 thumbprint.
        """
        return pulumi.get(self, "thumbprint_sha256")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ClientCredentialsSignedRequestObject(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.ClientCredentialsSignedRequestObjectCredential'],
                 required: Optional[_builtins.bool] = None):
        """
        :param Sequence['ClientCredentialsSignedRequestObjectCredentialArgs'] credentials: Client credentials for use with JWT-secured authorization requests.
        :param _builtins.bool required: Require JWT-secured authorization requests.
        """
        pulumi.set(__self__, "credentials", credentials)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.ClientCredentialsSignedRequestObjectCredential']:
        """
        Client credentials for use with JWT-secured authorization requests.
        """
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Require JWT-secured authorization requests.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class ClientCredentialsSignedRequestObjectCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialType":
            suggest = "credential_type"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "parseExpiryFromCert":
            suggest = "parse_expiry_from_cert"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsSignedRequestObjectCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsSignedRequestObjectCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsSignedRequestObjectCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_type: _builtins.str,
                 pem: _builtins.str,
                 algorithm: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 key_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 parse_expiry_from_cert: Optional[_builtins.bool] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str credential_type: Credential type. Supported types: `public_key`.
        :param _builtins.str pem: PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        :param _builtins.str algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str expires_at: The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str key_id: The key identifier of the credential, generated on creation.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.bool parse_expiry_from_cert: Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "pem", pem)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parse_expiry_from_cert is not None:
            pulumi.set(__self__, "parse_expiry_from_cert", parse_expiry_from_cert)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def pem(self) -> _builtins.str:
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parseExpiryFromCert")
    def parse_expiry_from_cert(self) -> Optional[_builtins.bool]:
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        return pulumi.get(self, "parse_expiry_from_cert")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ClientCredentialsTlsClientAuth(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.ClientCredentialsTlsClientAuthCredential']):
        """
        :param Sequence['ClientCredentialsTlsClientAuthCredentialArgs'] credentials: Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.ClientCredentialsTlsClientAuthCredential']:
        """
        Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class ClientCredentialsTlsClientAuthCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialType":
            suggest = "credential_type"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "subjectDn":
            suggest = "subject_dn"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsTlsClientAuthCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsTlsClientAuthCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsTlsClientAuthCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_type: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 pem: Optional[_builtins.str] = None,
                 subject_dn: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str credential_type: Credential type. Supported types: `cert_subject_dn`.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str pem: PEM-formatted X509 certificate. Must be JSON escaped. Mutually exlusive with `subject_dn` property.
        :param _builtins.str subject_dn: Subject Distinguished Name. Mutually exlusive with `pem` property.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pem is not None:
            pulumi.set(__self__, "pem", pem)
        if subject_dn is not None:
            pulumi.set(__self__, "subject_dn", subject_dn)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `cert_subject_dn`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pem(self) -> Optional[_builtins.str]:
        """
        PEM-formatted X509 certificate. Must be JSON escaped. Mutually exlusive with `subject_dn` property.
        """
        return pulumi.get(self, "pem")

    @_builtins.property
    @pulumi.getter(name="subjectDn")
    def subject_dn(self) -> Optional[_builtins.str]:
        """
        Subject Distinguished Name. Mutually exlusive with `pem` property.
        """
        return pulumi.get(self, "subject_dn")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ClientDefaultOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationId":
            suggest = "organization_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientDefaultOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientDefaultOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientDefaultOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 flows: Optional[Sequence[_builtins.str]] = None,
                 organization_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable: If set, the `default_organization` will be removed.
        :param Sequence[_builtins.str] flows: Definition of the flow that needs to be configured. Eg. client_credentials
        :param _builtins.str organization_id: The unique identifier of the organization
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if flows is not None:
            pulumi.set(__self__, "flows", flows)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        If set, the `default_organization` will be removed.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Optional[Sequence[_builtins.str]]:
        """
        Definition of the flow that needs to be configured. Eg. client_credentials
        """
        return pulumi.get(self, "flows")

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the organization
        """
        return pulumi.get(self, "organization_id")


@pulumi.output_type
class ClientJwtConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifetimeInSeconds":
            suggest = "lifetime_in_seconds"
        elif key == "secretEncoded":
            suggest = "secret_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientJwtConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientJwtConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientJwtConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alg: Optional[_builtins.str] = None,
                 lifetime_in_seconds: Optional[_builtins.int] = None,
                 scopes: Optional[Mapping[str, _builtins.str]] = None,
                 secret_encoded: Optional[_builtins.bool] = None):
        """
        :param _builtins.str alg: Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        :param _builtins.int lifetime_in_seconds: Number of seconds during which the JWT will be valid.
        :param Mapping[str, _builtins.str] scopes: Permissions (scopes) included in JWTs.
        :param _builtins.bool secret_encoded: Indicates whether the client secret is Base64-encoded.
        """
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_encoded is not None:
            pulumi.set(__self__, "secret_encoded", secret_encoded)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> Optional[_builtins.str]:
        """
        Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        """
        return pulumi.get(self, "alg")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds during which the JWT will be valid.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Permissions (scopes) included in JWTs.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="secretEncoded")
    def secret_encoded(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the client secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_encoded")


@pulumi.output_type
class ClientMobile(dict):
    def __init__(__self__, *,
                 android: Optional['outputs.ClientMobileAndroid'] = None,
                 ios: Optional['outputs.ClientMobileIos'] = None):
        """
        :param 'ClientMobileAndroidArgs' android: Configuration settings for Android native apps.
        :param 'ClientMobileIosArgs' ios: Configuration settings for i0S native apps.
        """
        if android is not None:
            pulumi.set(__self__, "android", android)
        if ios is not None:
            pulumi.set(__self__, "ios", ios)

    @_builtins.property
    @pulumi.getter
    def android(self) -> Optional['outputs.ClientMobileAndroid']:
        """
        Configuration settings for Android native apps.
        """
        return pulumi.get(self, "android")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Optional['outputs.ClientMobileIos']:
        """
        Configuration settings for i0S native apps.
        """
        return pulumi.get(self, "ios")


@pulumi.output_type
class ClientMobileAndroid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appPackageName":
            suggest = "app_package_name"
        elif key == "sha256CertFingerprints":
            suggest = "sha256_cert_fingerprints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientMobileAndroid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientMobileAndroid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientMobileAndroid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_package_name: Optional[_builtins.str] = None,
                 sha256_cert_fingerprints: Optional[Sequence[_builtins.str]] = None):
        if app_package_name is not None:
            pulumi.set(__self__, "app_package_name", app_package_name)
        if sha256_cert_fingerprints is not None:
            pulumi.set(__self__, "sha256_cert_fingerprints", sha256_cert_fingerprints)

    @_builtins.property
    @pulumi.getter(name="appPackageName")
    def app_package_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "app_package_name")

    @_builtins.property
    @pulumi.getter(name="sha256CertFingerprints")
    def sha256_cert_fingerprints(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sha256_cert_fingerprints")


@pulumi.output_type
class ClientMobileIos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appBundleIdentifier":
            suggest = "app_bundle_identifier"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientMobileIos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientMobileIos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientMobileIos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_bundle_identifier: Optional[_builtins.str] = None,
                 team_id: Optional[_builtins.str] = None):
        if app_bundle_identifier is not None:
            pulumi.set(__self__, "app_bundle_identifier", app_bundle_identifier)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="appBundleIdentifier")
    def app_bundle_identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "app_bundle_identifier")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class ClientNativeSocialLogin(dict):
    def __init__(__self__, *,
                 apple: Optional['outputs.ClientNativeSocialLoginApple'] = None,
                 facebook: Optional['outputs.ClientNativeSocialLoginFacebook'] = None,
                 google: Optional['outputs.ClientNativeSocialLoginGoogle'] = None):
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)

    @_builtins.property
    @pulumi.getter
    def apple(self) -> Optional['outputs.ClientNativeSocialLoginApple']:
        return pulumi.get(self, "apple")

    @_builtins.property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.ClientNativeSocialLoginFacebook']:
        return pulumi.get(self, "facebook")

    @_builtins.property
    @pulumi.getter
    def google(self) -> Optional['outputs.ClientNativeSocialLoginGoogle']:
        return pulumi.get(self, "google")


@pulumi.output_type
class ClientNativeSocialLoginApple(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClientNativeSocialLoginFacebook(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClientNativeSocialLoginGoogle(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClientOidcLogout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backchannelLogoutUrls":
            suggest = "backchannel_logout_urls"
        elif key == "backchannelLogoutInitiators":
            suggest = "backchannel_logout_initiators"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientOidcLogout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientOidcLogout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientOidcLogout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backchannel_logout_urls: Sequence[_builtins.str],
                 backchannel_logout_initiators: Optional['outputs.ClientOidcLogoutBackchannelLogoutInitiators'] = None):
        """
        :param Sequence[_builtins.str] backchannel_logout_urls: Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        :param 'ClientOidcLogoutBackchannelLogoutInitiatorsArgs' backchannel_logout_initiators: Configure OIDC logout initiators for the Client
        """
        pulumi.set(__self__, "backchannel_logout_urls", backchannel_logout_urls)
        if backchannel_logout_initiators is not None:
            pulumi.set(__self__, "backchannel_logout_initiators", backchannel_logout_initiators)

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutUrls")
    def backchannel_logout_urls(self) -> Sequence[_builtins.str]:
        """
        Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        """
        return pulumi.get(self, "backchannel_logout_urls")

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutInitiators")
    def backchannel_logout_initiators(self) -> Optional['outputs.ClientOidcLogoutBackchannelLogoutInitiators']:
        """
        Configure OIDC logout initiators for the Client
        """
        return pulumi.get(self, "backchannel_logout_initiators")


@pulumi.output_type
class ClientOidcLogoutBackchannelLogoutInitiators(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedInitiators":
            suggest = "selected_initiators"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientOidcLogoutBackchannelLogoutInitiators. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientOidcLogoutBackchannelLogoutInitiators.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientOidcLogoutBackchannelLogoutInitiators.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: _builtins.str,
                 selected_initiators: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str mode: Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel*logout*selected_initiators set, `all` enables all current and future initiators.
        :param Sequence[_builtins.str] selected_initiators: Contains the list of initiators to be enabled for the given client.
        """
        pulumi.set(__self__, "mode", mode)
        if selected_initiators is not None:
            pulumi.set(__self__, "selected_initiators", selected_initiators)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel*logout*selected_initiators set, `all` enables all current and future initiators.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="selectedInitiators")
    def selected_initiators(self) -> Optional[Sequence[_builtins.str]]:
        """
        Contains the list of initiators to be enabled for the given client.
        """
        return pulumi.get(self, "selected_initiators")


@pulumi.output_type
class ClientRefreshToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationType":
            suggest = "expiration_type"
        elif key == "rotationType":
            suggest = "rotation_type"
        elif key == "idleTokenLifetime":
            suggest = "idle_token_lifetime"
        elif key == "infiniteIdleTokenLifetime":
            suggest = "infinite_idle_token_lifetime"
        elif key == "infiniteTokenLifetime":
            suggest = "infinite_token_lifetime"
        elif key == "tokenLifetime":
            suggest = "token_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientRefreshToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientRefreshToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientRefreshToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_type: _builtins.str,
                 rotation_type: _builtins.str,
                 idle_token_lifetime: Optional[_builtins.int] = None,
                 infinite_idle_token_lifetime: Optional[_builtins.bool] = None,
                 infinite_token_lifetime: Optional[_builtins.bool] = None,
                 leeway: Optional[_builtins.int] = None,
                 policies: Optional[Sequence['outputs.ClientRefreshTokenPolicy']] = None,
                 token_lifetime: Optional[_builtins.int] = None):
        """
        :param _builtins.str expiration_type: Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        :param _builtins.str rotation_type: Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        :param _builtins.int idle_token_lifetime: The time in seconds after which inactive refresh tokens will expire.
        :param _builtins.bool infinite_idle_token_lifetime: Whether inactive refresh tokens should remain valid indefinitely.
        :param _builtins.bool infinite_token_lifetime: Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        :param _builtins.int leeway: The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        :param Sequence['ClientRefreshTokenPolicyArgs'] policies: A collection of policies governing multi-resource refresh token exchange (MRRT), defining how refresh tokens can be used across different resource servers
        :param _builtins.int token_lifetime: The absolute lifetime of a refresh token in seconds.
        """
        pulumi.set(__self__, "expiration_type", expiration_type)
        pulumi.set(__self__, "rotation_type", rotation_type)
        if idle_token_lifetime is not None:
            pulumi.set(__self__, "idle_token_lifetime", idle_token_lifetime)
        if infinite_idle_token_lifetime is not None:
            pulumi.set(__self__, "infinite_idle_token_lifetime", infinite_idle_token_lifetime)
        if infinite_token_lifetime is not None:
            pulumi.set(__self__, "infinite_token_lifetime", infinite_token_lifetime)
        if leeway is not None:
            pulumi.set(__self__, "leeway", leeway)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if token_lifetime is not None:
            pulumi.set(__self__, "token_lifetime", token_lifetime)

    @_builtins.property
    @pulumi.getter(name="expirationType")
    def expiration_type(self) -> _builtins.str:
        """
        Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        """
        return pulumi.get(self, "expiration_type")

    @_builtins.property
    @pulumi.getter(name="rotationType")
    def rotation_type(self) -> _builtins.str:
        """
        Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        """
        return pulumi.get(self, "rotation_type")

    @_builtins.property
    @pulumi.getter(name="idleTokenLifetime")
    def idle_token_lifetime(self) -> Optional[_builtins.int]:
        """
        The time in seconds after which inactive refresh tokens will expire.
        """
        return pulumi.get(self, "idle_token_lifetime")

    @_builtins.property
    @pulumi.getter(name="infiniteIdleTokenLifetime")
    def infinite_idle_token_lifetime(self) -> Optional[_builtins.bool]:
        """
        Whether inactive refresh tokens should remain valid indefinitely.
        """
        return pulumi.get(self, "infinite_idle_token_lifetime")

    @_builtins.property
    @pulumi.getter(name="infiniteTokenLifetime")
    def infinite_token_lifetime(self) -> Optional[_builtins.bool]:
        """
        Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        """
        return pulumi.get(self, "infinite_token_lifetime")

    @_builtins.property
    @pulumi.getter
    def leeway(self) -> Optional[_builtins.int]:
        """
        The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        """
        return pulumi.get(self, "leeway")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClientRefreshTokenPolicy']]:
        """
        A collection of policies governing multi-resource refresh token exchange (MRRT), defining how refresh tokens can be used across different resource servers
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="tokenLifetime")
    def token_lifetime(self) -> Optional[_builtins.int]:
        """
        The absolute lifetime of a refresh token in seconds.
        """
        return pulumi.get(self, "token_lifetime")


@pulumi.output_type
class ClientRefreshTokenPolicy(dict):
    def __init__(__self__, *,
                 audience: _builtins.str,
                 scopes: Sequence[_builtins.str]):
        """
        :param _builtins.str audience: The identifier of the resource server to which the Multi Resource Refresh Token Policy applies
        :param Sequence[_builtins.str] scopes: The resource server permissions granted under the Multi Resource Refresh Token Policy, defining the context in which an access token can be used
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        The identifier of the resource server to which the Multi Resource Refresh Token Policy applies
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        The resource server permissions granted under the Multi Resource Refresh Token Policy, defining the context in which an access token can be used
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ClientSessionTransfer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRefreshToken":
            suggest = "allow_refresh_token"
        elif key == "allowedAuthenticationMethods":
            suggest = "allowed_authentication_methods"
        elif key == "canCreateSessionTransferToken":
            suggest = "can_create_session_transfer_token"
        elif key == "enforceDeviceBinding":
            suggest = "enforce_device_binding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientSessionTransfer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientSessionTransfer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientSessionTransfer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_refresh_token: Optional[_builtins.bool] = None,
                 allowed_authentication_methods: Optional[Sequence[_builtins.str]] = None,
                 can_create_session_transfer_token: Optional[_builtins.bool] = None,
                 enforce_device_binding: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_refresh_token: Indicates whether the application is allowed to use a refresh token when using a session*transfer*token session.
        :param _builtins.bool can_create_session_transfer_token: Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session*transfer*token
        :param _builtins.str enforce_device_binding: Configures the level of device binding enforced when a session*transfer*token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        if allow_refresh_token is not None:
            pulumi.set(__self__, "allow_refresh_token", allow_refresh_token)
        if allowed_authentication_methods is not None:
            pulumi.set(__self__, "allowed_authentication_methods", allowed_authentication_methods)
        if can_create_session_transfer_token is not None:
            pulumi.set(__self__, "can_create_session_transfer_token", can_create_session_transfer_token)
        if enforce_device_binding is not None:
            pulumi.set(__self__, "enforce_device_binding", enforce_device_binding)

    @_builtins.property
    @pulumi.getter(name="allowRefreshToken")
    def allow_refresh_token(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the application is allowed to use a refresh token when using a session*transfer*token session.
        """
        return pulumi.get(self, "allow_refresh_token")

    @_builtins.property
    @pulumi.getter(name="allowedAuthenticationMethods")
    def allowed_authentication_methods(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_authentication_methods")

    @_builtins.property
    @pulumi.getter(name="canCreateSessionTransferToken")
    def can_create_session_transfer_token(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session*transfer*token
        """
        return pulumi.get(self, "can_create_session_transfer_token")

    @_builtins.property
    @pulumi.getter(name="enforceDeviceBinding")
    def enforce_device_binding(self) -> Optional[_builtins.str]:
        """
        Configures the level of device binding enforced when a session*transfer*token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        return pulumi.get(self, "enforce_device_binding")


@pulumi.output_type
class ClientTokenExchange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAnyProfileOfTypes":
            suggest = "allow_any_profile_of_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientTokenExchange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientTokenExchange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientTokenExchange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_any_profile_of_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allow_any_profile_of_types: List of allowed profile types for token exchange
        """
        pulumi.set(__self__, "allow_any_profile_of_types", allow_any_profile_of_types)

    @_builtins.property
    @pulumi.getter(name="allowAnyProfileOfTypes")
    def allow_any_profile_of_types(self) -> Sequence[_builtins.str]:
        """
        List of allowed profile types for token exchange
        """
        return pulumi.get(self, "allow_any_profile_of_types")


@pulumi.output_type
class ClientTokenQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientTokenQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientTokenQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientTokenQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials: 'outputs.ClientTokenQuotaClientCredentials'):
        """
        :param 'ClientTokenQuotaClientCredentialsArgs' client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> 'outputs.ClientTokenQuotaClientCredentials':
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class ClientTokenQuotaClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perDay":
            suggest = "per_day"
        elif key == "perHour":
            suggest = "per_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientTokenQuotaClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientTokenQuotaClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientTokenQuotaClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce: Optional[_builtins.bool] = None,
                 per_day: Optional[_builtins.int] = None,
                 per_hour: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if per_day is not None:
            pulumi.set(__self__, "per_day", per_day)
        if per_hour is not None:
            pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.bool]:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class ConnectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adfsServer":
            suggest = "adfs_server"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "apiEnableUsers":
            suggest = "api_enable_users"
        elif key == "appId":
            suggest = "app_id"
        elif key == "attributeMap":
            suggest = "attribute_map"
        elif key == "authParams":
            suggest = "auth_params"
        elif key == "authenticationMethods":
            suggest = "authentication_methods"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "bruteForceProtection":
            suggest = "brute_force_protection"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "communityBaseUrl":
            suggest = "community_base_url"
        elif key == "connectionSettings":
            suggest = "connection_settings"
        elif key == "customHeaders":
            suggest = "custom_headers"
        elif key == "customScripts":
            suggest = "custom_scripts"
        elif key == "decryptionKey":
            suggest = "decryption_key"
        elif key == "digestAlgorithm":
            suggest = "digest_algorithm"
        elif key == "disableCache":
            suggest = "disable_cache"
        elif key == "disableSelfServiceChangePassword":
            suggest = "disable_self_service_change_password"
        elif key == "disableSignOut":
            suggest = "disable_sign_out"
        elif key == "disableSignup":
            suggest = "disable_signup"
        elif key == "discoveryUrl":
            suggest = "discovery_url"
        elif key == "domainAliases":
            suggest = "domain_aliases"
        elif key == "enableScriptContext":
            suggest = "enable_script_context"
        elif key == "enabledDatabaseCustomization":
            suggest = "enabled_database_customization"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "fedMetadataXml":
            suggest = "fed_metadata_xml"
        elif key == "fieldsMap":
            suggest = "fields_map"
        elif key == "forwardRequestInfo":
            suggest = "forward_request_info"
        elif key == "from":
            suggest = "from_"
        elif key == "gatewayAuthentication":
            suggest = "gateway_authentication"
        elif key == "gatewayUrl":
            suggest = "gateway_url"
        elif key == "globalTokenRevocationJwtIss":
            suggest = "global_token_revocation_jwt_iss"
        elif key == "globalTokenRevocationJwtSub":
            suggest = "global_token_revocation_jwt_sub"
        elif key == "iconUrl":
            suggest = "icon_url"
        elif key == "identityApi":
            suggest = "identity_api"
        elif key == "idpInitiated":
            suggest = "idp_initiated"
        elif key == "importMode":
            suggest = "import_mode"
        elif key == "jwksUri":
            suggest = "jwks_uri"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "mapUserIdToId":
            suggest = "map_user_id_to_id"
        elif key == "maxGroupsToRetrieve":
            suggest = "max_groups_to_retrieve"
        elif key == "messagingServiceSid":
            suggest = "messaging_service_sid"
        elif key == "metadataUrl":
            suggest = "metadata_url"
        elif key == "metadataXml":
            suggest = "metadata_xml"
        elif key == "nonPersistentAttrs":
            suggest = "non_persistent_attrs"
        elif key == "passkeyOptions":
            suggest = "passkey_options"
        elif key == "passwordComplexityOptions":
            suggest = "password_complexity_options"
        elif key == "passwordDictionary":
            suggest = "password_dictionary"
        elif key == "passwordHistories":
            suggest = "password_histories"
        elif key == "passwordNoPersonalInfo":
            suggest = "password_no_personal_info"
        elif key == "passwordPolicy":
            suggest = "password_policy"
        elif key == "pingFederateBaseUrl":
            suggest = "ping_federate_base_url"
        elif key == "pkceEnabled":
            suggest = "pkce_enabled"
        elif key == "protocolBinding":
            suggest = "protocol_binding"
        elif key == "realmFallback":
            suggest = "realm_fallback"
        elif key == "requestTemplate":
            suggest = "request_template"
        elif key == "requiresUsername":
            suggest = "requires_username"
        elif key == "setUserRootAttributes":
            suggest = "set_user_root_attributes"
        elif key == "shouldTrustEmailVerifiedConnection":
            suggest = "should_trust_email_verified_connection"
        elif key == "signInEndpoint":
            suggest = "sign_in_endpoint"
        elif key == "signOutEndpoint":
            suggest = "sign_out_endpoint"
        elif key == "signSamlRequest":
            suggest = "sign_saml_request"
        elif key == "signatureAlgorithm":
            suggest = "signature_algorithm"
        elif key == "signingCert":
            suggest = "signing_cert"
        elif key == "signingKey":
            suggest = "signing_key"
        elif key == "strategyVersion":
            suggest = "strategy_version"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "tenantDomain":
            suggest = "tenant_domain"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "tokenEndpointAuthMethod":
            suggest = "token_endpoint_auth_method"
        elif key == "tokenEndpointAuthSigningAlg":
            suggest = "token_endpoint_auth_signing_alg"
        elif key == "twilioSid":
            suggest = "twilio_sid"
        elif key == "twilioToken":
            suggest = "twilio_token"
        elif key == "upstreamParams":
            suggest = "upstream_params"
        elif key == "useCertAuth":
            suggest = "use_cert_auth"
        elif key == "useKerberos":
            suggest = "use_kerberos"
        elif key == "useWsfed":
            suggest = "use_wsfed"
        elif key == "userIdAttribute":
            suggest = "user_id_attribute"
        elif key == "userinfoEndpoint":
            suggest = "userinfo_endpoint"
        elif key == "waadCommonEndpoint":
            suggest = "waad_common_endpoint"
        elif key == "waadProtocol":
            suggest = "waad_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adfs_server: Optional[_builtins.str] = None,
                 allowed_audiences: Optional[Sequence[_builtins.str]] = None,
                 api_enable_users: Optional[_builtins.bool] = None,
                 app_id: Optional[_builtins.str] = None,
                 attribute_map: Optional['outputs.ConnectionOptionsAttributeMap'] = None,
                 attributes: Optional[Sequence['outputs.ConnectionOptionsAttribute']] = None,
                 auth_params: Optional[Mapping[str, _builtins.str]] = None,
                 authentication_methods: Optional[Sequence['outputs.ConnectionOptionsAuthenticationMethod']] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 brute_force_protection: Optional[_builtins.bool] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 community_base_url: Optional[_builtins.str] = None,
                 configuration: Optional[Mapping[str, _builtins.str]] = None,
                 connection_settings: Optional['outputs.ConnectionOptionsConnectionSettings'] = None,
                 custom_headers: Optional[Sequence['outputs.ConnectionOptionsCustomHeader']] = None,
                 custom_scripts: Optional[Mapping[str, _builtins.str]] = None,
                 debug: Optional[_builtins.bool] = None,
                 decryption_key: Optional['outputs.ConnectionOptionsDecryptionKey'] = None,
                 digest_algorithm: Optional[_builtins.str] = None,
                 disable_cache: Optional[_builtins.bool] = None,
                 disable_self_service_change_password: Optional[_builtins.bool] = None,
                 disable_sign_out: Optional[_builtins.bool] = None,
                 disable_signup: Optional[_builtins.bool] = None,
                 discovery_url: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 domain_aliases: Optional[Sequence[_builtins.str]] = None,
                 enable_script_context: Optional[_builtins.bool] = None,
                 enabled_database_customization: Optional[_builtins.bool] = None,
                 entity_id: Optional[_builtins.str] = None,
                 fed_metadata_xml: Optional[_builtins.str] = None,
                 fields_map: Optional[_builtins.str] = None,
                 forward_request_info: Optional[_builtins.bool] = None,
                 from_: Optional[_builtins.str] = None,
                 gateway_authentication: Optional['outputs.ConnectionOptionsGatewayAuthentication'] = None,
                 gateway_url: Optional[_builtins.str] = None,
                 global_token_revocation_jwt_iss: Optional[_builtins.str] = None,
                 global_token_revocation_jwt_sub: Optional[_builtins.str] = None,
                 icon_url: Optional[_builtins.str] = None,
                 identity_api: Optional[_builtins.str] = None,
                 idp_initiated: Optional['outputs.ConnectionOptionsIdpInitiated'] = None,
                 import_mode: Optional[_builtins.bool] = None,
                 ips: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 key_id: Optional[_builtins.str] = None,
                 map_user_id_to_id: Optional[_builtins.bool] = None,
                 max_groups_to_retrieve: Optional[_builtins.str] = None,
                 messaging_service_sid: Optional[_builtins.str] = None,
                 metadata_url: Optional[_builtins.str] = None,
                 metadata_xml: Optional[_builtins.str] = None,
                 mfa: Optional['outputs.ConnectionOptionsMfa'] = None,
                 name: Optional[_builtins.str] = None,
                 non_persistent_attrs: Optional[Sequence[_builtins.str]] = None,
                 passkey_options: Optional['outputs.ConnectionOptionsPasskeyOptions'] = None,
                 password_complexity_options: Optional['outputs.ConnectionOptionsPasswordComplexityOptions'] = None,
                 password_dictionary: Optional['outputs.ConnectionOptionsPasswordDictionary'] = None,
                 password_histories: Optional[Sequence['outputs.ConnectionOptionsPasswordHistory']] = None,
                 password_no_personal_info: Optional['outputs.ConnectionOptionsPasswordNoPersonalInfo'] = None,
                 password_policy: Optional[_builtins.str] = None,
                 ping_federate_base_url: Optional[_builtins.str] = None,
                 pkce_enabled: Optional[_builtins.bool] = None,
                 precedences: Optional[Sequence[_builtins.str]] = None,
                 protocol_binding: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 realm_fallback: Optional[_builtins.bool] = None,
                 request_template: Optional[_builtins.str] = None,
                 requires_username: Optional[_builtins.bool] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 scripts: Optional[Mapping[str, _builtins.str]] = None,
                 set_user_root_attributes: Optional[_builtins.str] = None,
                 should_trust_email_verified_connection: Optional[_builtins.str] = None,
                 sign_in_endpoint: Optional[_builtins.str] = None,
                 sign_out_endpoint: Optional[_builtins.str] = None,
                 sign_saml_request: Optional[_builtins.bool] = None,
                 signature_algorithm: Optional[_builtins.str] = None,
                 signing_cert: Optional[_builtins.str] = None,
                 signing_key: Optional['outputs.ConnectionOptionsSigningKey'] = None,
                 strategy_version: Optional[_builtins.int] = None,
                 subject: Optional[_builtins.str] = None,
                 syntax: Optional[_builtins.str] = None,
                 team_id: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None,
                 tenant_domain: Optional[_builtins.str] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 token_endpoint_auth_method: Optional[_builtins.str] = None,
                 token_endpoint_auth_signing_alg: Optional[_builtins.str] = None,
                 totp: Optional['outputs.ConnectionOptionsTotp'] = None,
                 twilio_sid: Optional[_builtins.str] = None,
                 twilio_token: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 upstream_params: Optional[_builtins.str] = None,
                 use_cert_auth: Optional[_builtins.bool] = None,
                 use_kerberos: Optional[_builtins.bool] = None,
                 use_wsfed: Optional[_builtins.bool] = None,
                 user_id_attribute: Optional[_builtins.str] = None,
                 userinfo_endpoint: Optional[_builtins.str] = None,
                 validation: Optional['outputs.ConnectionOptionsValidation'] = None,
                 waad_common_endpoint: Optional[_builtins.bool] = None,
                 waad_protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str adfs_server: ADFS URL where to fetch the metadata source.
        :param Sequence[_builtins.str] allowed_audiences: List of allowed audiences.
        :param _builtins.bool api_enable_users: Enable API Access to users.
        :param _builtins.str app_id: App ID.
        :param 'ConnectionOptionsAttributeMapArgs' attribute_map: OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        :param Sequence['ConnectionOptionsAttributeArgs'] attributes: Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        :param Mapping[str, _builtins.str] auth_params: Query string parameters to be included as part of the generated passwordless email link.
        :param Sequence['ConnectionOptionsAuthenticationMethodArgs'] authentication_methods: Specifies the authentication methods and their configuration (enabled or disabled)
        :param _builtins.str authorization_endpoint: Authorization endpoint.
        :param _builtins.bool brute_force_protection: Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        :param _builtins.str client_id: The strategy's client ID.
        :param _builtins.str client_secret: The strategy's client secret.
        :param _builtins.str community_base_url: Salesforce community base URL.
        :param Mapping[str, _builtins.str] configuration: A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        :param 'ConnectionOptionsConnectionSettingsArgs' connection_settings: Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        :param Sequence['ConnectionOptionsCustomHeaderArgs'] custom_headers: Configure extra headers to the Token endpoint of an OAuth 2.0 provider
        :param Mapping[str, _builtins.str] custom_scripts: A map of scripts used to integrate with a custom database.
        :param _builtins.bool debug: When enabled, additional debug information will be generated.
        :param 'ConnectionOptionsDecryptionKeyArgs' decryption_key: The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param _builtins.str digest_algorithm: Sign Request Algorithm Digest.
        :param _builtins.bool disable_cache: Indicates whether to disable the cache or not.
        :param _builtins.bool disable_self_service_change_password: Indicates whether to remove the forgot password link within the New Universal Login.
        :param _builtins.bool disable_sign_out: When enabled, will disable sign out.
        :param _builtins.bool disable_signup: Indicates whether to allow user sign-ups to your application.
        :param _builtins.str discovery_url: OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        :param _builtins.str domain: Domain name.
        :param Sequence[_builtins.str] domain_aliases: List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        :param _builtins.bool enable_script_context: Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        :param _builtins.bool enabled_database_customization: Set to `true` to use a legacy user store.
        :param _builtins.str entity_id: Custom Entity ID for the connection.
        :param _builtins.str fed_metadata_xml: Federation Metadata for the ADFS connection.
        :param _builtins.str fields_map: If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        :param _builtins.bool forward_request_info: Specifies whether or not request info should be forwarded to sms gateway.
        :param _builtins.str from_: Address to use as the sender.
        :param 'ConnectionOptionsGatewayAuthenticationArgs' gateway_authentication: Defines the parameters used to generate the auth token for the custom gateway.
        :param _builtins.str gateway_url: Defines a custom sms gateway to use instead of Twilio.
        :param _builtins.str global_token_revocation_jwt_iss: Specifies the issuer of the JWT used for global token revocation for the SAML connection.
        :param _builtins.str global_token_revocation_jwt_sub: Specifies the subject of the JWT used for global token revocation for the SAML connection.
        :param _builtins.str icon_url: Icon URL.
        :param _builtins.str identity_api: Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        :param 'ConnectionOptionsIdpInitiatedArgs' idp_initiated: Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        :param _builtins.bool import_mode: Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        :param Sequence[_builtins.str] ips: A list of IPs.
        :param _builtins.str issuer: Issuer URL, e.g. `https://auth.example.com`.
        :param _builtins.str jwks_uri: JWKS URI.
        :param _builtins.str key_id: Apple Key ID.
        :param _builtins.bool map_user_id_to_id: By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        :param _builtins.str max_groups_to_retrieve: Maximum number of groups to retrieve.
        :param _builtins.str messaging_service_sid: SID for Copilot. Used when SMS Source is Copilot.
        :param _builtins.str metadata_url: The URL of the SAML metadata document.
        :param _builtins.str metadata_xml: The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        :param 'ConnectionOptionsMfaArgs' mfa: Configuration options for multifactor authentication.
        :param _builtins.str name: The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        :param Sequence[_builtins.str] non_persistent_attrs: If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        :param 'ConnectionOptionsPasskeyOptionsArgs' passkey_options: Defines options for the passkey authentication method
        :param 'ConnectionOptionsPasswordComplexityOptionsArgs' password_complexity_options: Configuration settings for password complexity.
        :param 'ConnectionOptionsPasswordDictionaryArgs' password_dictionary: Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        :param Sequence['ConnectionOptionsPasswordHistoryArgs'] password_histories: Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        :param 'ConnectionOptionsPasswordNoPersonalInfoArgs' password_no_personal_info: Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        :param _builtins.str password_policy: Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        :param _builtins.str ping_federate_base_url: Ping Federate Server URL.
        :param _builtins.bool pkce_enabled: Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        :param Sequence[_builtins.str] precedences: Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        :param _builtins.str protocol_binding: The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        :param _builtins.str provider: Defines the custom `sms_gateway` provider.
        :param _builtins.bool realm_fallback: Allows configuration if connections*realm*fallback flag is enabled for the tenant
        :param _builtins.str request_template: Template that formats the SAML request.
        :param _builtins.bool requires_username: Indicates whether the user is required to provide a username in addition to an email address.
        :param Sequence[_builtins.str] scopes: Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        :param Mapping[str, _builtins.str] scripts: A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        :param _builtins.str set_user_root_attributes: Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
        :param _builtins.str should_trust_email_verified_connection: Choose how Auth0 sets the email_verified field in the user profile.
        :param _builtins.str sign_in_endpoint: SAML single login URL for the connection.
        :param _builtins.str sign_out_endpoint: SAML single logout URL for the connection.
        :param _builtins.bool sign_saml_request: When enabled, the SAML authentication request will be signed.
        :param _builtins.str signature_algorithm: Sign Request Algorithm.
        :param _builtins.str signing_cert: X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        :param 'ConnectionOptionsSigningKeyArgs' signing_key: The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param _builtins.int strategy_version: Version 1 is deprecated, use version 2.
        :param _builtins.str subject: Subject line of the email.
        :param _builtins.str syntax: Syntax of the template body.
        :param _builtins.str team_id: Apple Team ID.
        :param _builtins.str template: Body of the template.
        :param _builtins.str tenant_domain: Tenant domain name.
        :param _builtins.str token_endpoint: Token endpoint.
        :param _builtins.str token_endpoint_auth_method: Specifies the authentication method for the token endpoint. (Okta/OIDC Connections)
        :param _builtins.str token_endpoint_auth_signing_alg: Specifies the signing algorithm for the token endpoint. (Okta/OIDC Connections)
        :param 'ConnectionOptionsTotpArgs' totp: Configuration options for one-time passwords.
        :param _builtins.str twilio_sid: SID for your Twilio account.
        :param _builtins.str twilio_token: AuthToken for your Twilio account.
        :param _builtins.str type: Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        :param _builtins.str upstream_params: You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        :param _builtins.bool use_cert_auth: Indicates whether to use cert auth or not.
        :param _builtins.bool use_kerberos: Indicates whether to use Kerberos or not.
        :param _builtins.bool use_wsfed: Whether to use WS-Fed.
        :param _builtins.str user_id_attribute: Attribute in the token that will be mapped to the user_id property in Auth0.
        :param _builtins.str userinfo_endpoint: User info endpoint.
        :param 'ConnectionOptionsValidationArgs' validation: Validation of the minimum and maximum values allowed for a user to have as username.
        :param _builtins.bool waad_common_endpoint: Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        :param _builtins.str waad_protocol: Protocol to use.
        """
        if adfs_server is not None:
            pulumi.set(__self__, "adfs_server", adfs_server)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if api_enable_users is not None:
            pulumi.set(__self__, "api_enable_users", api_enable_users)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if attribute_map is not None:
            pulumi.set(__self__, "attribute_map", attribute_map)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_params is not None:
            pulumi.set(__self__, "auth_params", auth_params)
        if authentication_methods is not None:
            pulumi.set(__self__, "authentication_methods", authentication_methods)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if brute_force_protection is not None:
            pulumi.set(__self__, "brute_force_protection", brute_force_protection)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if community_base_url is not None:
            pulumi.set(__self__, "community_base_url", community_base_url)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if connection_settings is not None:
            pulumi.set(__self__, "connection_settings", connection_settings)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_scripts is not None:
            pulumi.set(__self__, "custom_scripts", custom_scripts)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if decryption_key is not None:
            pulumi.set(__self__, "decryption_key", decryption_key)
        if digest_algorithm is not None:
            pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_self_service_change_password is not None:
            pulumi.set(__self__, "disable_self_service_change_password", disable_self_service_change_password)
        if disable_sign_out is not None:
            pulumi.set(__self__, "disable_sign_out", disable_sign_out)
        if disable_signup is not None:
            pulumi.set(__self__, "disable_signup", disable_signup)
        if discovery_url is not None:
            pulumi.set(__self__, "discovery_url", discovery_url)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_aliases is not None:
            pulumi.set(__self__, "domain_aliases", domain_aliases)
        if enable_script_context is not None:
            pulumi.set(__self__, "enable_script_context", enable_script_context)
        if enabled_database_customization is not None:
            pulumi.set(__self__, "enabled_database_customization", enabled_database_customization)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if fed_metadata_xml is not None:
            pulumi.set(__self__, "fed_metadata_xml", fed_metadata_xml)
        if fields_map is not None:
            pulumi.set(__self__, "fields_map", fields_map)
        if forward_request_info is not None:
            pulumi.set(__self__, "forward_request_info", forward_request_info)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if gateway_authentication is not None:
            pulumi.set(__self__, "gateway_authentication", gateway_authentication)
        if gateway_url is not None:
            pulumi.set(__self__, "gateway_url", gateway_url)
        if global_token_revocation_jwt_iss is not None:
            pulumi.set(__self__, "global_token_revocation_jwt_iss", global_token_revocation_jwt_iss)
        if global_token_revocation_jwt_sub is not None:
            pulumi.set(__self__, "global_token_revocation_jwt_sub", global_token_revocation_jwt_sub)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if identity_api is not None:
            pulumi.set(__self__, "identity_api", identity_api)
        if idp_initiated is not None:
            pulumi.set(__self__, "idp_initiated", idp_initiated)
        if import_mode is not None:
            pulumi.set(__self__, "import_mode", import_mode)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if map_user_id_to_id is not None:
            pulumi.set(__self__, "map_user_id_to_id", map_user_id_to_id)
        if max_groups_to_retrieve is not None:
            pulumi.set(__self__, "max_groups_to_retrieve", max_groups_to_retrieve)
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if metadata_url is not None:
            pulumi.set(__self__, "metadata_url", metadata_url)
        if metadata_xml is not None:
            pulumi.set(__self__, "metadata_xml", metadata_xml)
        if mfa is not None:
            pulumi.set(__self__, "mfa", mfa)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_persistent_attrs is not None:
            pulumi.set(__self__, "non_persistent_attrs", non_persistent_attrs)
        if passkey_options is not None:
            pulumi.set(__self__, "passkey_options", passkey_options)
        if password_complexity_options is not None:
            pulumi.set(__self__, "password_complexity_options", password_complexity_options)
        if password_dictionary is not None:
            pulumi.set(__self__, "password_dictionary", password_dictionary)
        if password_histories is not None:
            pulumi.set(__self__, "password_histories", password_histories)
        if password_no_personal_info is not None:
            pulumi.set(__self__, "password_no_personal_info", password_no_personal_info)
        if password_policy is not None:
            pulumi.set(__self__, "password_policy", password_policy)
        if ping_federate_base_url is not None:
            pulumi.set(__self__, "ping_federate_base_url", ping_federate_base_url)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if precedences is not None:
            pulumi.set(__self__, "precedences", precedences)
        if protocol_binding is not None:
            pulumi.set(__self__, "protocol_binding", protocol_binding)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if realm_fallback is not None:
            pulumi.set(__self__, "realm_fallback", realm_fallback)
        if request_template is not None:
            pulumi.set(__self__, "request_template", request_template)
        if requires_username is not None:
            pulumi.set(__self__, "requires_username", requires_username)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if scripts is not None:
            pulumi.set(__self__, "scripts", scripts)
        if set_user_root_attributes is not None:
            pulumi.set(__self__, "set_user_root_attributes", set_user_root_attributes)
        if should_trust_email_verified_connection is not None:
            pulumi.set(__self__, "should_trust_email_verified_connection", should_trust_email_verified_connection)
        if sign_in_endpoint is not None:
            pulumi.set(__self__, "sign_in_endpoint", sign_in_endpoint)
        if sign_out_endpoint is not None:
            pulumi.set(__self__, "sign_out_endpoint", sign_out_endpoint)
        if sign_saml_request is not None:
            pulumi.set(__self__, "sign_saml_request", sign_saml_request)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if signing_cert is not None:
            pulumi.set(__self__, "signing_cert", signing_cert)
        if signing_key is not None:
            pulumi.set(__self__, "signing_key", signing_key)
        if strategy_version is not None:
            pulumi.set(__self__, "strategy_version", strategy_version)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if syntax is not None:
            pulumi.set(__self__, "syntax", syntax)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tenant_domain is not None:
            pulumi.set(__self__, "tenant_domain", tenant_domain)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if token_endpoint_auth_method is not None:
            pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)
        if token_endpoint_auth_signing_alg is not None:
            pulumi.set(__self__, "token_endpoint_auth_signing_alg", token_endpoint_auth_signing_alg)
        if totp is not None:
            pulumi.set(__self__, "totp", totp)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)
        if twilio_token is not None:
            pulumi.set(__self__, "twilio_token", twilio_token)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upstream_params is not None:
            pulumi.set(__self__, "upstream_params", upstream_params)
        if use_cert_auth is not None:
            pulumi.set(__self__, "use_cert_auth", use_cert_auth)
        if use_kerberos is not None:
            pulumi.set(__self__, "use_kerberos", use_kerberos)
        if use_wsfed is not None:
            pulumi.set(__self__, "use_wsfed", use_wsfed)
        if user_id_attribute is not None:
            pulumi.set(__self__, "user_id_attribute", user_id_attribute)
        if userinfo_endpoint is not None:
            pulumi.set(__self__, "userinfo_endpoint", userinfo_endpoint)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)
        if waad_common_endpoint is not None:
            pulumi.set(__self__, "waad_common_endpoint", waad_common_endpoint)
        if waad_protocol is not None:
            pulumi.set(__self__, "waad_protocol", waad_protocol)

    @_builtins.property
    @pulumi.getter(name="adfsServer")
    def adfs_server(self) -> Optional[_builtins.str]:
        """
        ADFS URL where to fetch the metadata source.
        """
        return pulumi.get(self, "adfs_server")

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of allowed audiences.
        """
        return pulumi.get(self, "allowed_audiences")

    @_builtins.property
    @pulumi.getter(name="apiEnableUsers")
    def api_enable_users(self) -> Optional[_builtins.bool]:
        """
        Enable API Access to users.
        """
        return pulumi.get(self, "api_enable_users")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        App ID.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="attributeMap")
    def attribute_map(self) -> Optional['outputs.ConnectionOptionsAttributeMap']:
        """
        OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        """
        return pulumi.get(self, "attribute_map")

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence['outputs.ConnectionOptionsAttribute']]:
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="authParams")
    def auth_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Query string parameters to be included as part of the generated passwordless email link.
        """
        return pulumi.get(self, "auth_params")

    @_builtins.property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> Optional[Sequence['outputs.ConnectionOptionsAuthenticationMethod']]:
        """
        Specifies the authentication methods and their configuration (enabled or disabled)
        """
        return pulumi.get(self, "authentication_methods")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        Authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="bruteForceProtection")
    def brute_force_protection(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        """
        return pulumi.get(self, "brute_force_protection")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The strategy's client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The strategy's client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="communityBaseUrl")
    def community_base_url(self) -> Optional[_builtins.str]:
        """
        Salesforce community base URL.
        """
        return pulumi.get(self, "community_base_url")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="connectionSettings")
    def connection_settings(self) -> Optional['outputs.ConnectionOptionsConnectionSettings']:
        """
        Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        """
        return pulumi.get(self, "connection_settings")

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.ConnectionOptionsCustomHeader']]:
        """
        Configure extra headers to the Token endpoint of an OAuth 2.0 provider
        """
        return pulumi.get(self, "custom_headers")

    @_builtins.property
    @pulumi.getter(name="customScripts")
    def custom_scripts(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of scripts used to integrate with a custom database.
        """
        return pulumi.get(self, "custom_scripts")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.bool]:
        """
        When enabled, additional debug information will be generated.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="decryptionKey")
    def decryption_key(self) -> Optional['outputs.ConnectionOptionsDecryptionKey']:
        """
        The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "decryption_key")

    @_builtins.property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> Optional[_builtins.str]:
        """
        Sign Request Algorithm Digest.
        """
        return pulumi.get(self, "digest_algorithm")

    @_builtins.property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to disable the cache or not.
        """
        return pulumi.get(self, "disable_cache")

    @_builtins.property
    @pulumi.getter(name="disableSelfServiceChangePassword")
    def disable_self_service_change_password(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to remove the forgot password link within the New Universal Login.
        """
        return pulumi.get(self, "disable_self_service_change_password")

    @_builtins.property
    @pulumi.getter(name="disableSignOut")
    def disable_sign_out(self) -> Optional[_builtins.bool]:
        """
        When enabled, will disable sign out.
        """
        return pulumi.get(self, "disable_sign_out")

    @_builtins.property
    @pulumi.getter(name="disableSignup")
    def disable_signup(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to allow user sign-ups to your application.
        """
        return pulumi.get(self, "disable_signup")

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> Optional[_builtins.str]:
        """
        OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        """
        return pulumi.get(self, "discovery_url")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="domainAliases")
    def domain_aliases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        """
        return pulumi.get(self, "domain_aliases")

    @_builtins.property
    @pulumi.getter(name="enableScriptContext")
    def enable_script_context(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        """
        return pulumi.get(self, "enable_script_context")

    @_builtins.property
    @pulumi.getter(name="enabledDatabaseCustomization")
    def enabled_database_customization(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to use a legacy user store.
        """
        return pulumi.get(self, "enabled_database_customization")

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[_builtins.str]:
        """
        Custom Entity ID for the connection.
        """
        return pulumi.get(self, "entity_id")

    @_builtins.property
    @pulumi.getter(name="fedMetadataXml")
    def fed_metadata_xml(self) -> Optional[_builtins.str]:
        """
        Federation Metadata for the ADFS connection.
        """
        return pulumi.get(self, "fed_metadata_xml")

    @_builtins.property
    @pulumi.getter(name="fieldsMap")
    def fields_map(self) -> Optional[_builtins.str]:
        """
        If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        """
        return pulumi.get(self, "fields_map")

    @_builtins.property
    @pulumi.getter(name="forwardRequestInfo")
    def forward_request_info(self) -> Optional[_builtins.bool]:
        """
        Specifies whether or not request info should be forwarded to sms gateway.
        """
        return pulumi.get(self, "forward_request_info")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        Address to use as the sender.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter(name="gatewayAuthentication")
    def gateway_authentication(self) -> Optional['outputs.ConnectionOptionsGatewayAuthentication']:
        """
        Defines the parameters used to generate the auth token for the custom gateway.
        """
        return pulumi.get(self, "gateway_authentication")

    @_builtins.property
    @pulumi.getter(name="gatewayUrl")
    def gateway_url(self) -> Optional[_builtins.str]:
        """
        Defines a custom sms gateway to use instead of Twilio.
        """
        return pulumi.get(self, "gateway_url")

    @_builtins.property
    @pulumi.getter(name="globalTokenRevocationJwtIss")
    def global_token_revocation_jwt_iss(self) -> Optional[_builtins.str]:
        """
        Specifies the issuer of the JWT used for global token revocation for the SAML connection.
        """
        return pulumi.get(self, "global_token_revocation_jwt_iss")

    @_builtins.property
    @pulumi.getter(name="globalTokenRevocationJwtSub")
    def global_token_revocation_jwt_sub(self) -> Optional[_builtins.str]:
        """
        Specifies the subject of the JWT used for global token revocation for the SAML connection.
        """
        return pulumi.get(self, "global_token_revocation_jwt_sub")

    @_builtins.property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[_builtins.str]:
        """
        Icon URL.
        """
        return pulumi.get(self, "icon_url")

    @_builtins.property
    @pulumi.getter(name="identityApi")
    def identity_api(self) -> Optional[_builtins.str]:
        """
        Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        """
        return pulumi.get(self, "identity_api")

    @_builtins.property
    @pulumi.getter(name="idpInitiated")
    def idp_initiated(self) -> Optional['outputs.ConnectionOptionsIdpInitiated']:
        """
        Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        """
        return pulumi.get(self, "idp_initiated")

    @_builtins.property
    @pulumi.getter(name="importMode")
    def import_mode(self) -> Optional[_builtins.bool]:
        """
        Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        """
        return pulumi.get(self, "import_mode")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of IPs.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        Issuer URL, e.g. `https://auth.example.com`.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        JWKS URI.
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        Apple Key ID.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="mapUserIdToId")
    def map_user_id_to_id(self) -> Optional[_builtins.bool]:
        """
        By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        """
        return pulumi.get(self, "map_user_id_to_id")

    @_builtins.property
    @pulumi.getter(name="maxGroupsToRetrieve")
    def max_groups_to_retrieve(self) -> Optional[_builtins.str]:
        """
        Maximum number of groups to retrieve.
        """
        return pulumi.get(self, "max_groups_to_retrieve")

    @_builtins.property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[_builtins.str]:
        """
        SID for Copilot. Used when SMS Source is Copilot.
        """
        return pulumi.get(self, "messaging_service_sid")

    @_builtins.property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[_builtins.str]:
        """
        The URL of the SAML metadata document.
        """
        return pulumi.get(self, "metadata_url")

    @_builtins.property
    @pulumi.getter(name="metadataXml")
    def metadata_xml(self) -> Optional[_builtins.str]:
        """
        The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        """
        return pulumi.get(self, "metadata_xml")

    @_builtins.property
    @pulumi.getter
    def mfa(self) -> Optional['outputs.ConnectionOptionsMfa']:
        """
        Configuration options for multifactor authentication.
        """
        return pulumi.get(self, "mfa")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonPersistentAttrs")
    def non_persistent_attrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        """
        return pulumi.get(self, "non_persistent_attrs")

    @_builtins.property
    @pulumi.getter(name="passkeyOptions")
    def passkey_options(self) -> Optional['outputs.ConnectionOptionsPasskeyOptions']:
        """
        Defines options for the passkey authentication method
        """
        return pulumi.get(self, "passkey_options")

    @_builtins.property
    @pulumi.getter(name="passwordComplexityOptions")
    def password_complexity_options(self) -> Optional['outputs.ConnectionOptionsPasswordComplexityOptions']:
        """
        Configuration settings for password complexity.
        """
        return pulumi.get(self, "password_complexity_options")

    @_builtins.property
    @pulumi.getter(name="passwordDictionary")
    def password_dictionary(self) -> Optional['outputs.ConnectionOptionsPasswordDictionary']:
        """
        Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        """
        return pulumi.get(self, "password_dictionary")

    @_builtins.property
    @pulumi.getter(name="passwordHistories")
    def password_histories(self) -> Optional[Sequence['outputs.ConnectionOptionsPasswordHistory']]:
        """
        Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        """
        return pulumi.get(self, "password_histories")

    @_builtins.property
    @pulumi.getter(name="passwordNoPersonalInfo")
    def password_no_personal_info(self) -> Optional['outputs.ConnectionOptionsPasswordNoPersonalInfo']:
        """
        Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        """
        return pulumi.get(self, "password_no_personal_info")

    @_builtins.property
    @pulumi.getter(name="passwordPolicy")
    def password_policy(self) -> Optional[_builtins.str]:
        """
        Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        """
        return pulumi.get(self, "password_policy")

    @_builtins.property
    @pulumi.getter(name="pingFederateBaseUrl")
    def ping_federate_base_url(self) -> Optional[_builtins.str]:
        """
        Ping Federate Server URL.
        """
        return pulumi.get(self, "ping_federate_base_url")

    @_builtins.property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        """
        return pulumi.get(self, "pkce_enabled")

    @_builtins.property
    @pulumi.getter
    def precedences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        return pulumi.get(self, "precedences")

    @_builtins.property
    @pulumi.getter(name="protocolBinding")
    def protocol_binding(self) -> Optional[_builtins.str]:
        """
        The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        """
        return pulumi.get(self, "protocol_binding")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Defines the custom `sms_gateway` provider.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="realmFallback")
    def realm_fallback(self) -> Optional[_builtins.bool]:
        """
        Allows configuration if connections*realm*fallback flag is enabled for the tenant
        """
        return pulumi.get(self, "realm_fallback")

    @_builtins.property
    @pulumi.getter(name="requestTemplate")
    def request_template(self) -> Optional[_builtins.str]:
        """
        Template that formats the SAML request.
        """
        return pulumi.get(self, "request_template")

    @_builtins.property
    @pulumi.getter(name="requiresUsername")
    def requires_username(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the user is required to provide a username in addition to an email address.
        """
        return pulumi.get(self, "requires_username")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def scripts(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        """
        return pulumi.get(self, "scripts")

    @_builtins.property
    @pulumi.getter(name="setUserRootAttributes")
    def set_user_root_attributes(self) -> Optional[_builtins.str]:
        """
        Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
        """
        return pulumi.get(self, "set_user_root_attributes")

    @_builtins.property
    @pulumi.getter(name="shouldTrustEmailVerifiedConnection")
    def should_trust_email_verified_connection(self) -> Optional[_builtins.str]:
        """
        Choose how Auth0 sets the email_verified field in the user profile.
        """
        return pulumi.get(self, "should_trust_email_verified_connection")

    @_builtins.property
    @pulumi.getter(name="signInEndpoint")
    def sign_in_endpoint(self) -> Optional[_builtins.str]:
        """
        SAML single login URL for the connection.
        """
        return pulumi.get(self, "sign_in_endpoint")

    @_builtins.property
    @pulumi.getter(name="signOutEndpoint")
    def sign_out_endpoint(self) -> Optional[_builtins.str]:
        """
        SAML single logout URL for the connection.
        """
        return pulumi.get(self, "sign_out_endpoint")

    @_builtins.property
    @pulumi.getter(name="signSamlRequest")
    def sign_saml_request(self) -> Optional[_builtins.bool]:
        """
        When enabled, the SAML authentication request will be signed.
        """
        return pulumi.get(self, "sign_saml_request")

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[_builtins.str]:
        """
        Sign Request Algorithm.
        """
        return pulumi.get(self, "signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> Optional[_builtins.str]:
        """
        X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        """
        return pulumi.get(self, "signing_cert")

    @_builtins.property
    @pulumi.getter(name="signingKey")
    def signing_key(self) -> Optional['outputs.ConnectionOptionsSigningKey']:
        """
        The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "signing_key")

    @_builtins.property
    @pulumi.getter(name="strategyVersion")
    def strategy_version(self) -> Optional[_builtins.int]:
        """
        Version 1 is deprecated, use version 2.
        """
        return pulumi.get(self, "strategy_version")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        Subject line of the email.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def syntax(self) -> Optional[_builtins.str]:
        """
        Syntax of the template body.
        """
        return pulumi.get(self, "syntax")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[_builtins.str]:
        """
        Apple Team ID.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        Body of the template.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="tenantDomain")
    def tenant_domain(self) -> Optional[_builtins.str]:
        """
        Tenant domain name.
        """
        return pulumi.get(self, "tenant_domain")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        Token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> Optional[_builtins.str]:
        """
        Specifies the authentication method for the token endpoint. (Okta/OIDC Connections)
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointAuthSigningAlg")
    def token_endpoint_auth_signing_alg(self) -> Optional[_builtins.str]:
        """
        Specifies the signing algorithm for the token endpoint. (Okta/OIDC Connections)
        """
        return pulumi.get(self, "token_endpoint_auth_signing_alg")

    @_builtins.property
    @pulumi.getter
    def totp(self) -> Optional['outputs.ConnectionOptionsTotp']:
        """
        Configuration options for one-time passwords.
        """
        return pulumi.get(self, "totp")

    @_builtins.property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[_builtins.str]:
        """
        SID for your Twilio account.
        """
        return pulumi.get(self, "twilio_sid")

    @_builtins.property
    @pulumi.getter(name="twilioToken")
    def twilio_token(self) -> Optional[_builtins.str]:
        """
        AuthToken for your Twilio account.
        """
        return pulumi.get(self, "twilio_token")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upstreamParams")
    def upstream_params(self) -> Optional[_builtins.str]:
        """
        You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        """
        return pulumi.get(self, "upstream_params")

    @_builtins.property
    @pulumi.getter(name="useCertAuth")
    def use_cert_auth(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use cert auth or not.
        """
        return pulumi.get(self, "use_cert_auth")

    @_builtins.property
    @pulumi.getter(name="useKerberos")
    def use_kerberos(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use Kerberos or not.
        """
        return pulumi.get(self, "use_kerberos")

    @_builtins.property
    @pulumi.getter(name="useWsfed")
    def use_wsfed(self) -> Optional[_builtins.bool]:
        """
        Whether to use WS-Fed.
        """
        return pulumi.get(self, "use_wsfed")

    @_builtins.property
    @pulumi.getter(name="userIdAttribute")
    def user_id_attribute(self) -> Optional[_builtins.str]:
        """
        Attribute in the token that will be mapped to the user_id property in Auth0.
        """
        return pulumi.get(self, "user_id_attribute")

    @_builtins.property
    @pulumi.getter(name="userinfoEndpoint")
    def userinfo_endpoint(self) -> Optional[_builtins.str]:
        """
        User info endpoint.
        """
        return pulumi.get(self, "userinfo_endpoint")

    @_builtins.property
    @pulumi.getter
    def validation(self) -> Optional['outputs.ConnectionOptionsValidation']:
        """
        Validation of the minimum and maximum values allowed for a user to have as username.
        """
        return pulumi.get(self, "validation")

    @_builtins.property
    @pulumi.getter(name="waadCommonEndpoint")
    def waad_common_endpoint(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        """
        return pulumi.get(self, "waad_common_endpoint")

    @_builtins.property
    @pulumi.getter(name="waadProtocol")
    def waad_protocol(self) -> Optional[_builtins.str]:
        """
        Protocol to use.
        """
        return pulumi.get(self, "waad_protocol")


@pulumi.output_type
class ConnectionOptionsAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumbers":
            suggest = "phone_numbers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence['outputs.ConnectionOptionsAttributeEmail']] = None,
                 phone_numbers: Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumber']] = None,
                 usernames: Optional[Sequence['outputs.ConnectionOptionsAttributeUsername']] = None):
        """
        :param Sequence['ConnectionOptionsAttributeEmailArgs'] emails: Connection Options for Email Attribute
        :param Sequence['ConnectionOptionsAttributePhoneNumberArgs'] phone_numbers: Connection Options for Phone Number Attribute
        :param Sequence['ConnectionOptionsAttributeUsernameArgs'] usernames: Connection Options for User Name Attribute
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if phone_numbers is not None:
            pulumi.set(__self__, "phone_numbers", phone_numbers)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeEmail']]:
        """
        Connection Options for Email Attribute
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumber']]:
        """
        Connection Options for Phone Number Attribute
        """
        return pulumi.get(self, "phone_numbers")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeUsername']]:
        """
        Connection Options for User Name Attribute
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ConnectionOptionsAttributeEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileRequired":
            suggest = "profile_required"
        elif key == "verificationMethod":
            suggest = "verification_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributeEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributeEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributeEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifiers: Optional[Sequence['outputs.ConnectionOptionsAttributeEmailIdentifier']] = None,
                 profile_required: Optional[_builtins.bool] = None,
                 signups: Optional[Sequence['outputs.ConnectionOptionsAttributeEmailSignup']] = None,
                 verification_method: Optional[_builtins.str] = None):
        """
        :param Sequence['ConnectionOptionsAttributeEmailIdentifierArgs'] identifiers: Connection Options Email Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['ConnectionOptionsAttributeEmailSignupArgs'] signups: Defines signup settings for Email attribute
        :param _builtins.str verification_method: Defines whether whether user will receive a link or an OTP during user signup for email verification and password reset for email verification
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)
        if verification_method is not None:
            pulumi.set(__self__, "verification_method", verification_method)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeEmailIdentifier']]:
        """
        Connection Options Email Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[_builtins.bool]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeEmailSignup']]:
        """
        Defines signup settings for Email attribute
        """
        return pulumi.get(self, "signups")

    @_builtins.property
    @pulumi.getter(name="verificationMethod")
    def verification_method(self) -> Optional[_builtins.str]:
        """
        Defines whether whether user will receive a link or an OTP during user signup for email verification and password reset for email verification
        """
        return pulumi.get(self, "verification_method")


@pulumi.output_type
class ConnectionOptionsAttributeEmailIdentifier(dict):
    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Defines whether email attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Defines whether email attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class ConnectionOptionsAttributeEmailSignup(dict):
    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None,
                 verifications: Optional[Sequence['outputs.ConnectionOptionsAttributeEmailSignupVerification']] = None):
        """
        :param _builtins.str status: Defines signup status for Email Attribute
        :param Sequence['ConnectionOptionsAttributeEmailSignupVerificationArgs'] verifications: Defines settings for Verification under Email attribute
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if verifications is not None:
            pulumi.set(__self__, "verifications", verifications)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Defines signup status for Email Attribute
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def verifications(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeEmailSignupVerification']]:
        """
        Defines settings for Verification under Email attribute
        """
        return pulumi.get(self, "verifications")


@pulumi.output_type
class ConnectionOptionsAttributeEmailSignupVerification(dict):
    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Defines verification settings for signup attribute
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Defines verification settings for signup attribute
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class ConnectionOptionsAttributeMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingMode":
            suggest = "mapping_mode"
        elif key == "userinfoScope":
            suggest = "userinfo_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributeMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributeMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributeMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_mode: _builtins.str,
                 attributes: Optional[_builtins.str] = None,
                 userinfo_scope: Optional[_builtins.str] = None):
        """
        :param _builtins.str mapping_mode: Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        :param _builtins.str attributes: This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        :param _builtins.str userinfo_scope: This property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.
        """
        pulumi.set(__self__, "mapping_mode", mapping_mode)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if userinfo_scope is not None:
            pulumi.set(__self__, "userinfo_scope", userinfo_scope)

    @_builtins.property
    @pulumi.getter(name="mappingMode")
    def mapping_mode(self) -> _builtins.str:
        """
        Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        """
        return pulumi.get(self, "mapping_mode")

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[_builtins.str]:
        """
        This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="userinfoScope")
    def userinfo_scope(self) -> Optional[_builtins.str]:
        """
        This property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.
        """
        return pulumi.get(self, "userinfo_scope")


@pulumi.output_type
class ConnectionOptionsAttributePhoneNumber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileRequired":
            suggest = "profile_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributePhoneNumber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributePhoneNumber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributePhoneNumber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifiers: Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberIdentifier']] = None,
                 profile_required: Optional[_builtins.bool] = None,
                 signups: Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberSignup']] = None):
        """
        :param Sequence['ConnectionOptionsAttributePhoneNumberIdentifierArgs'] identifiers: Connection Options Phone Number Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['ConnectionOptionsAttributePhoneNumberSignupArgs'] signups: Defines signup settings for Phone Number attribute
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberIdentifier']]:
        """
        Connection Options Phone Number Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[_builtins.bool]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberSignup']]:
        """
        Defines signup settings for Phone Number attribute
        """
        return pulumi.get(self, "signups")


@pulumi.output_type
class ConnectionOptionsAttributePhoneNumberIdentifier(dict):
    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Defines whether Phone Number attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Defines whether Phone Number attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class ConnectionOptionsAttributePhoneNumberSignup(dict):
    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None,
                 verifications: Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberSignupVerification']] = None):
        """
        :param _builtins.str status: Defines status of signup for Phone Number attribute
        :param Sequence['ConnectionOptionsAttributePhoneNumberSignupVerificationArgs'] verifications: Defines verification settings for Phone Number attribute
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if verifications is not None:
            pulumi.set(__self__, "verifications", verifications)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Defines status of signup for Phone Number attribute
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def verifications(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributePhoneNumberSignupVerification']]:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "verifications")


@pulumi.output_type
class ConnectionOptionsAttributePhoneNumberSignupVerification(dict):
    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Defines verification settings for Phone Number attribute
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class ConnectionOptionsAttributeUsername(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileRequired":
            suggest = "profile_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributeUsername. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributeUsername.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributeUsername.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifiers: Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameIdentifier']] = None,
                 profile_required: Optional[_builtins.bool] = None,
                 signups: Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameSignup']] = None,
                 validations: Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameValidation']] = None):
        """
        :param Sequence['ConnectionOptionsAttributeUsernameIdentifierArgs'] identifiers: Connection options for User Name Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['ConnectionOptionsAttributeUsernameSignupArgs'] signups: Defines signup settings for User Name attribute
        :param Sequence['ConnectionOptionsAttributeUsernameValidationArgs'] validations: Defines validation settings for User Name attribute
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)
        if validations is not None:
            pulumi.set(__self__, "validations", validations)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameIdentifier']]:
        """
        Connection options for User Name Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[_builtins.bool]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameSignup']]:
        """
        Defines signup settings for User Name attribute
        """
        return pulumi.get(self, "signups")

    @_builtins.property
    @pulumi.getter
    def validations(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameValidation']]:
        """
        Defines validation settings for User Name attribute
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class ConnectionOptionsAttributeUsernameIdentifier(dict):
    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Defines whether UserName attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Defines whether UserName attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class ConnectionOptionsAttributeUsernameSignup(dict):
    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: Defines whether User Name attribute is active as an identifier
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Defines whether User Name attribute is active as an identifier
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ConnectionOptionsAttributeUsernameValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTypes":
            suggest = "allowed_types"
        elif key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributeUsernameValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributeUsernameValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributeUsernameValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_types: Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameValidationAllowedType']] = None,
                 max_length: Optional[_builtins.int] = None,
                 min_length: Optional[_builtins.int] = None):
        """
        :param Sequence['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs'] allowed_types: Defines allowed types for for UserName attribute
        :param _builtins.int max_length: Defines Max Length for User Name attribute
        :param _builtins.int min_length: Defines Min Length for User Name attribute
        """
        if allowed_types is not None:
            pulumi.set(__self__, "allowed_types", allowed_types)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="allowedTypes")
    def allowed_types(self) -> Optional[Sequence['outputs.ConnectionOptionsAttributeUsernameValidationAllowedType']]:
        """
        Defines allowed types for for UserName attribute
        """
        return pulumi.get(self, "allowed_types")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[_builtins.int]:
        """
        Defines Max Length for User Name attribute
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        Defines Min Length for User Name attribute
        """
        return pulumi.get(self, "min_length")


@pulumi.output_type
class ConnectionOptionsAttributeUsernameValidationAllowedType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsAttributeUsernameValidationAllowedType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsAttributeUsernameValidationAllowedType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsAttributeUsernameValidationAllowedType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[_builtins.bool] = None,
                 phone_number: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool email: One of the allowed types for UserName signup attribute
        :param _builtins.bool phone_number: One of the allowed types for UserName signup attribute
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.bool]:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.bool]:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ConnectionOptionsAuthenticationMethod(dict):
    def __init__(__self__, *,
                 passkey: Optional['outputs.ConnectionOptionsAuthenticationMethodPasskey'] = None,
                 password: Optional['outputs.ConnectionOptionsAuthenticationMethodPassword'] = None):
        """
        :param 'ConnectionOptionsAuthenticationMethodPasskeyArgs' passkey: Configures passkey authentication
        :param 'ConnectionOptionsAuthenticationMethodPasswordArgs' password: Configures password authentication
        """
        if passkey is not None:
            pulumi.set(__self__, "passkey", passkey)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def passkey(self) -> Optional['outputs.ConnectionOptionsAuthenticationMethodPasskey']:
        """
        Configures passkey authentication
        """
        return pulumi.get(self, "passkey")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.ConnectionOptionsAuthenticationMethodPassword']:
        """
        Configures password authentication
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ConnectionOptionsAuthenticationMethodPasskey(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables passkey authentication
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables passkey authentication
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ConnectionOptionsAuthenticationMethodPassword(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables password authentication
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables password authentication
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ConnectionOptionsConnectionSettings(dict):
    def __init__(__self__, *,
                 pkce: _builtins.str):
        """
        :param _builtins.str pkce: PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        pulumi.set(__self__, "pkce", pkce)

    @_builtins.property
    @pulumi.getter
    def pkce(self) -> _builtins.str:
        """
        PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        return pulumi.get(self, "pkce")


@pulumi.output_type
class ConnectionOptionsCustomHeader(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ConnectionOptionsDecryptionKey(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class ConnectionOptionsGatewayAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretBase64Encoded":
            suggest = "secret_base64_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsGatewayAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsGatewayAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsGatewayAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[_builtins.str] = None,
                 method: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 secret_base64_encoded: Optional[_builtins.bool] = None,
                 subject: Optional[_builtins.str] = None):
        """
        :param _builtins.str audience: Audience claim for the HS256 token sent to `gateway_url`.
        :param _builtins.str method: Authentication method (default is `bearer` token).
        :param _builtins.str secret: Secret used to sign the HS256 token sent to `gateway_url`.
        :param _builtins.bool secret_base64_encoded: Specifies whether or not the secret is Base64-encoded.
        :param _builtins.str subject: Subject claim for the HS256 token sent to `gateway_url`.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_base64_encoded is not None:
            pulumi.set(__self__, "secret_base64_encoded", secret_base64_encoded)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[_builtins.str]:
        """
        Audience claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Authentication method (default is `bearer` token).
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret used to sign the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretBase64Encoded")
    def secret_base64_encoded(self) -> Optional[_builtins.bool]:
        """
        Specifies whether or not the secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_base64_encoded")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        Subject claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class ConnectionOptionsIdpInitiated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientAuthorizeQuery":
            suggest = "client_authorize_query"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientProtocol":
            suggest = "client_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsIdpInitiated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsIdpInitiated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsIdpInitiated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_authorize_query: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_protocol: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        if client_authorize_query is not None:
            pulumi.set(__self__, "client_authorize_query", client_authorize_query)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_protocol is not None:
            pulumi.set(__self__, "client_protocol", client_protocol)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="clientAuthorizeQuery")
    def client_authorize_query(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_authorize_query")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_protocol")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ConnectionOptionsMfa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnEnrollSettings":
            suggest = "return_enroll_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsMfa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsMfa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsMfa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[_builtins.bool] = None,
                 return_enroll_settings: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool active: Indicates whether multifactor authentication is enabled for this connection.
        :param _builtins.bool return_enroll_settings: Indicates whether multifactor authentication enrollment settings will be returned.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if return_enroll_settings is not None:
            pulumi.set(__self__, "return_enroll_settings", return_enroll_settings)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Indicates whether multifactor authentication is enabled for this connection.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="returnEnrollSettings")
    def return_enroll_settings(self) -> Optional[_builtins.bool]:
        """
        Indicates whether multifactor authentication enrollment settings will be returned.
        """
        return pulumi.get(self, "return_enroll_settings")


@pulumi.output_type
class ConnectionOptionsPasskeyOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "challengeUi":
            suggest = "challenge_ui"
        elif key == "localEnrollmentEnabled":
            suggest = "local_enrollment_enabled"
        elif key == "progressiveEnrollmentEnabled":
            suggest = "progressive_enrollment_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsPasskeyOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsPasskeyOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsPasskeyOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 challenge_ui: Optional[_builtins.str] = None,
                 local_enrollment_enabled: Optional[_builtins.bool] = None,
                 progressive_enrollment_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str challenge_ui: Controls the UI used to challenge the user for their passkey
        :param _builtins.bool local_enrollment_enabled: Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection
        :param _builtins.bool progressive_enrollment_enabled: Enables or disables progressive enrollment of passkeys for the connection
        """
        if challenge_ui is not None:
            pulumi.set(__self__, "challenge_ui", challenge_ui)
        if local_enrollment_enabled is not None:
            pulumi.set(__self__, "local_enrollment_enabled", local_enrollment_enabled)
        if progressive_enrollment_enabled is not None:
            pulumi.set(__self__, "progressive_enrollment_enabled", progressive_enrollment_enabled)

    @_builtins.property
    @pulumi.getter(name="challengeUi")
    def challenge_ui(self) -> Optional[_builtins.str]:
        """
        Controls the UI used to challenge the user for their passkey
        """
        return pulumi.get(self, "challenge_ui")

    @_builtins.property
    @pulumi.getter(name="localEnrollmentEnabled")
    def local_enrollment_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection
        """
        return pulumi.get(self, "local_enrollment_enabled")

    @_builtins.property
    @pulumi.getter(name="progressiveEnrollmentEnabled")
    def progressive_enrollment_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables progressive enrollment of passkeys for the connection
        """
        return pulumi.get(self, "progressive_enrollment_enabled")


@pulumi.output_type
class ConnectionOptionsPasswordComplexityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minLength":
            suggest = "min_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsPasswordComplexityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsPasswordComplexityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsPasswordComplexityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_length: Optional[_builtins.int] = None):
        """
        :param _builtins.int min_length: Minimum number of characters allowed in passwords.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        Minimum number of characters allowed in passwords.
        """
        return pulumi.get(self, "min_length")


@pulumi.output_type
class ConnectionOptionsPasswordDictionary(dict):
    def __init__(__self__, *,
                 dictionaries: Optional[Sequence[_builtins.str]] = None,
                 enable: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] dictionaries: Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        :param _builtins.bool enable: Indicates whether the password dictionary check is enabled for this connection.
        """
        if dictionaries is not None:
            pulumi.set(__self__, "dictionaries", dictionaries)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def dictionaries(self) -> Optional[Sequence[_builtins.str]]:
        """
        Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        """
        return pulumi.get(self, "dictionaries")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the password dictionary check is enabled for this connection.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class ConnectionOptionsPasswordHistory(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 size: Optional[_builtins.int] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")


@pulumi.output_type
class ConnectionOptionsPasswordNoPersonalInfo(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable")


@pulumi.output_type
class ConnectionOptionsSigningKey(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class ConnectionOptionsTotp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeStep":
            suggest = "time_step"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionOptionsTotp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionOptionsTotp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionOptionsTotp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 length: Optional[_builtins.int] = None,
                 time_step: Optional[_builtins.int] = None):
        """
        :param _builtins.int length: Length of the one-time password.
        :param _builtins.int time_step: Seconds between allowed generation of new passwords.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if time_step is not None:
            pulumi.set(__self__, "time_step", time_step)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        Length of the one-time password.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter(name="timeStep")
    def time_step(self) -> Optional[_builtins.int]:
        """
        Seconds between allowed generation of new passwords.
        """
        return pulumi.get(self, "time_step")


@pulumi.output_type
class ConnectionOptionsValidation(dict):
    def __init__(__self__, *,
                 username: Optional['outputs.ConnectionOptionsValidationUsername'] = None):
        """
        :param 'ConnectionOptionsValidationUsernameArgs' username: Specifies the `min` and `max` values of username length.
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional['outputs.ConnectionOptionsValidationUsername']:
        """
        Specifies the `min` and `max` values of username length.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectionOptionsValidationUsername(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class ConnectionScimConfigurationMapping(dict):
    def __init__(__self__, *,
                 auth0: _builtins.str,
                 scim: _builtins.str):
        """
        :param _builtins.str auth0: The field location in the Auth0 schema.
        :param _builtins.str scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @_builtins.property
    @pulumi.getter
    def auth0(self) -> _builtins.str:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @_builtins.property
    @pulumi.getter
    def scim(self) -> _builtins.str:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")


@pulumi.output_type
class CustomDomainCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "errorMsg":
            suggest = "error_msg"
        elif key == "renewsBefore":
            suggest = "renews_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: Optional[_builtins.str] = None,
                 error_msg: Optional[_builtins.str] = None,
                 renews_before: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_authority: Name of the certificate authority that issued the certificate.
        :param _builtins.str error_msg: Contains the error message if the provisioning process fails.
        :param _builtins.str renews_before: Specifies the date by which the certificate should be renewed.
        :param _builtins.str status: Indicates the current state of the certificate provisioning process.
        """
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)
        if renews_before is not None:
            pulumi.set(__self__, "renews_before", renews_before)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        Name of the certificate authority that issued the certificate.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[_builtins.str]:
        """
        Contains the error message if the provisioning process fails.
        """
        return pulumi.get(self, "error_msg")

    @_builtins.property
    @pulumi.getter(name="renewsBefore")
    def renews_before(self) -> Optional[_builtins.str]:
        """
        Specifies the date by which the certificate should be renewed.
        """
        return pulumi.get(self, "renews_before")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Indicates the current state of the certificate provisioning process.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CustomDomainVerification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMsg":
            suggest = "error_msg"
        elif key == "lastVerifiedAt":
            suggest = "last_verified_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainVerification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainVerification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainVerification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_msg: Optional[_builtins.str] = None,
                 last_verified_at: Optional[_builtins.str] = None,
                 methods: Optional[Sequence[Any]] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_msg: Contains error message, if any, from the last DNS verification check.
        :param _builtins.str last_verified_at: Indicates the last time the domain was successfully verified.
        :param Sequence[Any] methods: Defines the list of domain verification methods used.
        :param _builtins.str status: Represents the current status of the domain verification process.
        """
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)
        if last_verified_at is not None:
            pulumi.set(__self__, "last_verified_at", last_verified_at)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[_builtins.str]:
        """
        Contains error message, if any, from the last DNS verification check.
        """
        return pulumi.get(self, "error_msg")

    @_builtins.property
    @pulumi.getter(name="lastVerifiedAt")
    def last_verified_at(self) -> Optional[_builtins.str]:
        """
        Indicates the last time the domain was successfully verified.
        """
        return pulumi.get(self, "last_verified_at")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[Any]]:
        """
        Defines the list of domain verification methods used.
        """
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Represents the current status of the domain verification process.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class EmailProviderCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "azureCsConnectionString":
            suggest = "azure_cs_connection_string"
        elif key == "ms365ClientId":
            suggest = "ms365_client_id"
        elif key == "ms365ClientSecret":
            suggest = "ms365_client_secret"
        elif key == "ms365TenantId":
            suggest = "ms365_tenant_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "smtpHost":
            suggest = "smtp_host"
        elif key == "smtpPass":
            suggest = "smtp_pass"
        elif key == "smtpPort":
            suggest = "smtp_port"
        elif key == "smtpUser":
            suggest = "smtp_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailProviderCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailProviderCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailProviderCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[_builtins.str] = None,
                 api_key: Optional[_builtins.str] = None,
                 azure_cs_connection_string: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 ms365_client_id: Optional[_builtins.str] = None,
                 ms365_client_secret: Optional[_builtins.str] = None,
                 ms365_tenant_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 smtp_host: Optional[_builtins.str] = None,
                 smtp_pass: Optional[_builtins.str] = None,
                 smtp_port: Optional[_builtins.int] = None,
                 smtp_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key_id: AWS Access Key ID. Used only for AWS.
        :param _builtins.str api_key: API Key for your email service. Will always be encrypted in our database.
        :param _builtins.str azure_cs_connection_string: Azure Communication Services Connection String.
        :param _builtins.str domain: Domain name.
        :param _builtins.str ms365_client_id: Microsoft 365 Client ID.
        :param _builtins.str ms365_client_secret: Microsoft 365 Client Secret.
        :param _builtins.str ms365_tenant_id: Microsoft 365 Tenant ID.
        :param _builtins.str region: Default region. Used only for AWS, Mailgun, and SparkPost.
        :param _builtins.str secret_access_key: AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
        :param _builtins.str smtp_host: Hostname or IP address of your SMTP server. Used only for SMTP.
        :param _builtins.str smtp_pass: SMTP password. Used only for SMTP.
        :param _builtins.int smtp_port: Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
        :param _builtins.str smtp_user: SMTP username. Used only for SMTP.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if azure_cs_connection_string is not None:
            pulumi.set(__self__, "azure_cs_connection_string", azure_cs_connection_string)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if ms365_client_id is not None:
            pulumi.set(__self__, "ms365_client_id", ms365_client_id)
        if ms365_client_secret is not None:
            pulumi.set(__self__, "ms365_client_secret", ms365_client_secret)
        if ms365_tenant_id is not None:
            pulumi.set(__self__, "ms365_tenant_id", ms365_tenant_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if smtp_host is not None:
            pulumi.set(__self__, "smtp_host", smtp_host)
        if smtp_pass is not None:
            pulumi.set(__self__, "smtp_pass", smtp_pass)
        if smtp_port is not None:
            pulumi.set(__self__, "smtp_port", smtp_port)
        if smtp_user is not None:
            pulumi.set(__self__, "smtp_user", smtp_user)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        AWS Access Key ID. Used only for AWS.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key for your email service. Will always be encrypted in our database.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="azureCsConnectionString")
    def azure_cs_connection_string(self) -> Optional[_builtins.str]:
        """
        Azure Communication Services Connection String.
        """
        return pulumi.get(self, "azure_cs_connection_string")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="ms365ClientId")
    def ms365_client_id(self) -> Optional[_builtins.str]:
        """
        Microsoft 365 Client ID.
        """
        return pulumi.get(self, "ms365_client_id")

    @_builtins.property
    @pulumi.getter(name="ms365ClientSecret")
    def ms365_client_secret(self) -> Optional[_builtins.str]:
        """
        Microsoft 365 Client Secret.
        """
        return pulumi.get(self, "ms365_client_secret")

    @_builtins.property
    @pulumi.getter(name="ms365TenantId")
    def ms365_tenant_id(self) -> Optional[_builtins.str]:
        """
        Microsoft 365 Tenant ID.
        """
        return pulumi.get(self, "ms365_tenant_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Default region. Used only for AWS, Mailgun, and SparkPost.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="smtpHost")
    def smtp_host(self) -> Optional[_builtins.str]:
        """
        Hostname or IP address of your SMTP server. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_host")

    @_builtins.property
    @pulumi.getter(name="smtpPass")
    def smtp_pass(self) -> Optional[_builtins.str]:
        """
        SMTP password. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_pass")

    @_builtins.property
    @pulumi.getter(name="smtpPort")
    def smtp_port(self) -> Optional[_builtins.int]:
        """
        Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_port")

    @_builtins.property
    @pulumi.getter(name="smtpUser")
    def smtp_user(self) -> Optional[_builtins.str]:
        """
        SMTP username. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_user")


@pulumi.output_type
class EmailProviderSettings(dict):
    def __init__(__self__, *,
                 headers: Optional['outputs.EmailProviderSettingsHeaders'] = None,
                 message: Optional['outputs.EmailProviderSettingsMessage'] = None):
        """
        :param 'EmailProviderSettingsHeadersArgs' headers: Headers settings for the `smtp` email provider.
        :param 'EmailProviderSettingsMessageArgs' message: Message settings for the `mandrill` or `ses` email provider.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional['outputs.EmailProviderSettingsHeaders']:
        """
        Headers settings for the `smtp` email provider.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional['outputs.EmailProviderSettingsMessage']:
        """
        Message settings for the `mandrill` or `ses` email provider.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class EmailProviderSettingsHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xMcViewContentLink":
            suggest = "x_mc_view_content_link"
        elif key == "xSesConfigurationSet":
            suggest = "x_ses_configuration_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailProviderSettingsHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailProviderSettingsHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailProviderSettingsHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_mc_view_content_link: Optional[_builtins.str] = None,
                 x_ses_configuration_set: Optional[_builtins.str] = None):
        """
        :param _builtins.str x_mc_view_content_link: Disable or enable the default View Content Link for sensitive emails.
        :param _builtins.str x_ses_configuration_set: SES Configuration set to include when sending emails.
        """
        if x_mc_view_content_link is not None:
            pulumi.set(__self__, "x_mc_view_content_link", x_mc_view_content_link)
        if x_ses_configuration_set is not None:
            pulumi.set(__self__, "x_ses_configuration_set", x_ses_configuration_set)

    @_builtins.property
    @pulumi.getter(name="xMcViewContentLink")
    def x_mc_view_content_link(self) -> Optional[_builtins.str]:
        """
        Disable or enable the default View Content Link for sensitive emails.
        """
        return pulumi.get(self, "x_mc_view_content_link")

    @_builtins.property
    @pulumi.getter(name="xSesConfigurationSet")
    def x_ses_configuration_set(self) -> Optional[_builtins.str]:
        """
        SES Configuration set to include when sending emails.
        """
        return pulumi.get(self, "x_ses_configuration_set")


@pulumi.output_type
class EmailProviderSettingsMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationSetName":
            suggest = "configuration_set_name"
        elif key == "viewContentLink":
            suggest = "view_content_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailProviderSettingsMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailProviderSettingsMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailProviderSettingsMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_set_name: Optional[_builtins.str] = None,
                 view_content_link: Optional[_builtins.bool] = None):
        """
        :param _builtins.str configuration_set_name: Setting for the `ses` email provider. The name of the configuration set to apply to the sent emails.
        :param _builtins.bool view_content_link: Setting for the `mandrill` email provider. Set to `true` to see the content of individual emails sent to users.
        """
        if configuration_set_name is not None:
            pulumi.set(__self__, "configuration_set_name", configuration_set_name)
        if view_content_link is not None:
            pulumi.set(__self__, "view_content_link", view_content_link)

    @_builtins.property
    @pulumi.getter(name="configurationSetName")
    def configuration_set_name(self) -> Optional[_builtins.str]:
        """
        Setting for the `ses` email provider. The name of the configuration set to apply to the sent emails.
        """
        return pulumi.get(self, "configuration_set_name")

    @_builtins.property
    @pulumi.getter(name="viewContentLink")
    def view_content_link(self) -> Optional[_builtins.bool]:
        """
        Setting for the `mandrill` email provider. Set to `true` to see the content of individual emails sent to users.
        """
        return pulumi.get(self, "view_content_link")


@pulumi.output_type
class EncryptionKeyManagerCustomerProvidedRootKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "parentKeyId":
            suggest = "parent_key_id"
        elif key == "publicWrappingKey":
            suggest = "public_wrapping_key"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "wrappedKey":
            suggest = "wrapped_key"
        elif key == "wrappingAlgorithm":
            suggest = "wrapping_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyManagerCustomerProvidedRootKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyManagerCustomerProvidedRootKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyManagerCustomerProvidedRootKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 key_id: Optional[_builtins.str] = None,
                 parent_key_id: Optional[_builtins.str] = None,
                 public_wrapping_key: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 wrapped_key: Optional[_builtins.str] = None,
                 wrapping_algorithm: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The ISO 8601 formatted date the customer provided root key was created.
        :param _builtins.str key_id: The key ID of the customer provided root key.
        :param _builtins.str parent_key_id: The key ID of the parent wrapping key.
        :param _builtins.str public_wrapping_key: The public wrapping key in PEM format.
        :param _builtins.str state: The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        :param _builtins.str type: The type of the customer provided root key. Should be `customer-provided-root-key`.
        :param _builtins.str updated_at: The ISO 8601 formatted date the customer provided root key was updated.
        :param _builtins.str wrapped_key: The base64-encoded customer provided root key, wrapped using the `public_wrapping_key`. This can be removed after the wrapped key has been applied.
        :param _builtins.str wrapping_algorithm: The algorithm that should be used to wrap the customer provided root key. Should be `CKM_RSA_AES_KEY_WRAP`.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if parent_key_id is not None:
            pulumi.set(__self__, "parent_key_id", parent_key_id)
        if public_wrapping_key is not None:
            pulumi.set(__self__, "public_wrapping_key", public_wrapping_key)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if wrapped_key is not None:
            pulumi.set(__self__, "wrapped_key", wrapped_key)
        if wrapping_algorithm is not None:
            pulumi.set(__self__, "wrapping_algorithm", wrapping_algorithm)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the customer provided root key was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        The key ID of the customer provided root key.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="parentKeyId")
    def parent_key_id(self) -> Optional[_builtins.str]:
        """
        The key ID of the parent wrapping key.
        """
        return pulumi.get(self, "parent_key_id")

    @_builtins.property
    @pulumi.getter(name="publicWrappingKey")
    def public_wrapping_key(self) -> Optional[_builtins.str]:
        """
        The public wrapping key in PEM format.
        """
        return pulumi.get(self, "public_wrapping_key")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the customer provided root key. Should be `customer-provided-root-key`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the customer provided root key was updated.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> Optional[_builtins.str]:
        """
        The base64-encoded customer provided root key, wrapped using the `public_wrapping_key`. This can be removed after the wrapped key has been applied.
        """
        return pulumi.get(self, "wrapped_key")

    @_builtins.property
    @pulumi.getter(name="wrappingAlgorithm")
    def wrapping_algorithm(self) -> Optional[_builtins.str]:
        """
        The algorithm that should be used to wrap the customer provided root key. Should be `CKM_RSA_AES_KEY_WRAP`.
        """
        return pulumi.get(self, "wrapping_algorithm")


@pulumi.output_type
class EncryptionKeyManagerEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "parentKeyId":
            suggest = "parent_key_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyManagerEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyManagerEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyManagerEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 key_id: Optional[_builtins.str] = None,
                 parent_key_id: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The ISO 8601 formatted date the encryption key was created.
        :param _builtins.str key_id: The key ID of the encryption key.
        :param _builtins.str parent_key_id: The key ID of the parent wrapping key.
        :param _builtins.str state: The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        :param _builtins.str type: The type of the encryption key. One of `customer-provided-root-key`, `environment-root-key`, or `tenant-master-key`.
        :param _builtins.str updated_at: The ISO 8601 formatted date the encryption key was updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if parent_key_id is not None:
            pulumi.set(__self__, "parent_key_id", parent_key_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the encryption key was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        The key ID of the encryption key.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="parentKeyId")
    def parent_key_id(self) -> Optional[_builtins.str]:
        """
        The key ID of the parent wrapping key.
        """
        return pulumi.get(self, "parent_key_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the encryption key. One of `customer-provided-root-key`, `environment-root-key`, or `tenant-master-key`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 formatted date the encryption key was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class FormLanguage(dict):
    def __init__(__self__, *,
                 primary: _builtins.str,
                 default: Optional[_builtins.str] = None):
        """
        :param _builtins.str primary: Primary language for the form.
        :param _builtins.str default: Default language for the form.
        """
        pulumi.set(__self__, "primary", primary)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.str:
        """
        Primary language for the form.
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        Default language for the form.
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class FormMessage(dict):
    def __init__(__self__, *,
                 custom: Optional[_builtins.str] = None,
                 errors: Optional[_builtins.str] = None):
        """
        :param _builtins.str custom: Custom message for the form. (JSON encoded)
        :param _builtins.str errors: Error message for the form. (JSON encoded)
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[_builtins.str]:
        """
        Custom message for the form. (JSON encoded)
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[_builtins.str]:
        """
        Error message for the form. (JSON encoded)
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class GuardianDuo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationKey":
            suggest = "integration_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianDuo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianDuo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianDuo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 hostname: Optional[_builtins.str] = None,
                 integration_key: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Indicates whether Duo MFA is enabled.
        :param _builtins.str hostname: Duo API Hostname, see the Duo documentation for more details on Duo setup.
        :param _builtins.str integration_key: Duo client ID, see the Duo documentation for more details on Duo setup.
        :param _builtins.str secret_key: Duo client secret, see the Duo documentation for more details on Duo setup.
        """
        pulumi.set(__self__, "enabled", enabled)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if integration_key is not None:
            pulumi.set(__self__, "integration_key", integration_key)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether Duo MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        Duo API Hostname, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> Optional[_builtins.str]:
        """
        Duo client ID, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "integration_key")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Duo client secret, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GuardianPhone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageTypes":
            suggest = "message_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPhone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPhone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPhone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 message_types: Optional[Sequence[_builtins.str]] = None,
                 options: Optional['outputs.GuardianPhoneOptions'] = None,
                 provider: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Indicates whether Phone MFA is enabled.
        :param Sequence[_builtins.str] message_types: Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
        :param 'GuardianPhoneOptionsArgs' options: Options for the various providers.
        :param _builtins.str provider: Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
        """
        pulumi.set(__self__, "enabled", enabled)
        if message_types is not None:
            pulumi.set(__self__, "message_types", message_types)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether Phone MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="messageTypes")
    def message_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
        """
        return pulumi.get(self, "message_types")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GuardianPhoneOptions']:
        """
        Options for the various providers.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class GuardianPhoneOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "enrollmentMessage":
            suggest = "enrollment_message"
        elif key == "from":
            suggest = "from_"
        elif key == "messagingServiceSid":
            suggest = "messaging_service_sid"
        elif key == "verificationMessage":
            suggest = "verification_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPhoneOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPhoneOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPhoneOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: Optional[_builtins.str] = None,
                 enrollment_message: Optional[_builtins.str] = None,
                 from_: Optional[_builtins.str] = None,
                 messaging_service_sid: Optional[_builtins.str] = None,
                 sid: Optional[_builtins.str] = None,
                 verification_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_token: AuthToken for your Twilio account.
        :param _builtins.str enrollment_message: This message will be sent whenever a user enrolls a new device for the first time using MFA. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        :param _builtins.str from_: Phone number to use as the sender.
        :param _builtins.str messaging_service_sid: Messaging service SID.
        :param _builtins.str sid: SID for your Twilio account.
        :param _builtins.str verification_message: This message will be sent whenever a user logs in after the enrollment. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if enrollment_message is not None:
            pulumi.set(__self__, "enrollment_message", enrollment_message)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)
        if verification_message is not None:
            pulumi.set(__self__, "verification_message", verification_message)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[_builtins.str]:
        """
        AuthToken for your Twilio account.
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="enrollmentMessage")
    def enrollment_message(self) -> Optional[_builtins.str]:
        """
        This message will be sent whenever a user enrolls a new device for the first time using MFA. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        return pulumi.get(self, "enrollment_message")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        """
        Phone number to use as the sender.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[_builtins.str]:
        """
        Messaging service SID.
        """
        return pulumi.get(self, "messaging_service_sid")

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[_builtins.str]:
        """
        SID for your Twilio account.
        """
        return pulumi.get(self, "sid")

    @_builtins.property
    @pulumi.getter(name="verificationMessage")
    def verification_message(self) -> Optional[_builtins.str]:
        """
        This message will be sent whenever a user logs in after the enrollment. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        return pulumi.get(self, "verification_message")


@pulumi.output_type
class GuardianPush(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonSns":
            suggest = "amazon_sns"
        elif key == "customApp":
            suggest = "custom_app"
        elif key == "directApns":
            suggest = "direct_apns"
        elif key == "directFcm":
            suggest = "direct_fcm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPush. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPush.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPush.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 amazon_sns: Optional['outputs.GuardianPushAmazonSns'] = None,
                 custom_app: Optional['outputs.GuardianPushCustomApp'] = None,
                 direct_apns: Optional['outputs.GuardianPushDirectApns'] = None,
                 direct_fcm: Optional['outputs.GuardianPushDirectFcm'] = None,
                 provider: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Indicates whether Push MFA is enabled.
        :param 'GuardianPushAmazonSnsArgs' amazon_sns: Configuration for Amazon SNS.
        :param 'GuardianPushCustomAppArgs' custom_app: Configuration for the Guardian Custom App.
        :param 'GuardianPushDirectApnsArgs' direct_apns: Configuration for the Apple Push Notification service (APNs) settings.
        :param 'GuardianPushDirectFcmArgs' direct_fcm: Configuration for Firebase Cloud Messaging (FCM) settings.
        :param _builtins.str provider: Provider to use, one of `direct`, `guardian`, `sns`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if amazon_sns is not None:
            pulumi.set(__self__, "amazon_sns", amazon_sns)
        if custom_app is not None:
            pulumi.set(__self__, "custom_app", custom_app)
        if direct_apns is not None:
            pulumi.set(__self__, "direct_apns", direct_apns)
        if direct_fcm is not None:
            pulumi.set(__self__, "direct_fcm", direct_fcm)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether Push MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="amazonSns")
    def amazon_sns(self) -> Optional['outputs.GuardianPushAmazonSns']:
        """
        Configuration for Amazon SNS.
        """
        return pulumi.get(self, "amazon_sns")

    @_builtins.property
    @pulumi.getter(name="customApp")
    def custom_app(self) -> Optional['outputs.GuardianPushCustomApp']:
        """
        Configuration for the Guardian Custom App.
        """
        return pulumi.get(self, "custom_app")

    @_builtins.property
    @pulumi.getter(name="directApns")
    def direct_apns(self) -> Optional['outputs.GuardianPushDirectApns']:
        """
        Configuration for the Apple Push Notification service (APNs) settings.
        """
        return pulumi.get(self, "direct_apns")

    @_builtins.property
    @pulumi.getter(name="directFcm")
    def direct_fcm(self) -> Optional['outputs.GuardianPushDirectFcm']:
        """
        Configuration for Firebase Cloud Messaging (FCM) settings.
        """
        return pulumi.get(self, "direct_fcm")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider to use, one of `direct`, `guardian`, `sns`.
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class GuardianPushAmazonSns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "snsApnsPlatformApplicationArn":
            suggest = "sns_apns_platform_application_arn"
        elif key == "snsGcmPlatformApplicationArn":
            suggest = "sns_gcm_platform_application_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPushAmazonSns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPushAmazonSns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPushAmazonSns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: _builtins.str,
                 aws_region: _builtins.str,
                 aws_secret_access_key: _builtins.str,
                 sns_apns_platform_application_arn: _builtins.str,
                 sns_gcm_platform_application_arn: _builtins.str):
        """
        :param _builtins.str aws_access_key_id: Your AWS Access Key ID.
        :param _builtins.str aws_region: Your AWS application's region.
        :param _builtins.str aws_secret_access_key: Your AWS Secret Access Key.
        :param _builtins.str sns_apns_platform_application_arn: The Amazon Resource Name for your Apple Push Notification Service.
        :param _builtins.str sns_gcm_platform_application_arn: The Amazon Resource Name for your Firebase Cloud Messaging Service.
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        pulumi.set(__self__, "sns_apns_platform_application_arn", sns_apns_platform_application_arn)
        pulumi.set(__self__, "sns_gcm_platform_application_arn", sns_gcm_platform_application_arn)

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> _builtins.str:
        """
        Your AWS Access Key ID.
        """
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> _builtins.str:
        """
        Your AWS application's region.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> _builtins.str:
        """
        Your AWS Secret Access Key.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="snsApnsPlatformApplicationArn")
    def sns_apns_platform_application_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name for your Apple Push Notification Service.
        """
        return pulumi.get(self, "sns_apns_platform_application_arn")

    @_builtins.property
    @pulumi.getter(name="snsGcmPlatformApplicationArn")
    def sns_gcm_platform_application_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name for your Firebase Cloud Messaging Service.
        """
        return pulumi.get(self, "sns_gcm_platform_application_arn")


@pulumi.output_type
class GuardianPushCustomApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appName":
            suggest = "app_name"
        elif key == "appleAppLink":
            suggest = "apple_app_link"
        elif key == "googleAppLink":
            suggest = "google_app_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPushCustomApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPushCustomApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPushCustomApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_name: Optional[_builtins.str] = None,
                 apple_app_link: Optional[_builtins.str] = None,
                 google_app_link: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_name: Custom Application Name.
        :param _builtins.str apple_app_link: Apple App Store URL. Must be HTTPS or an empty string.
        :param _builtins.str google_app_link: Google Store URL. Must be HTTPS or an empty string.
        """
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if apple_app_link is not None:
            pulumi.set(__self__, "apple_app_link", apple_app_link)
        if google_app_link is not None:
            pulumi.set(__self__, "google_app_link", google_app_link)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[_builtins.str]:
        """
        Custom Application Name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="appleAppLink")
    def apple_app_link(self) -> Optional[_builtins.str]:
        """
        Apple App Store URL. Must be HTTPS or an empty string.
        """
        return pulumi.get(self, "apple_app_link")

    @_builtins.property
    @pulumi.getter(name="googleAppLink")
    def google_app_link(self) -> Optional[_builtins.str]:
        """
        Google Store URL. Must be HTTPS or an empty string.
        """
        return pulumi.get(self, "google_app_link")


@pulumi.output_type
class GuardianPushDirectApns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundleId":
            suggest = "bundle_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPushDirectApns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPushDirectApns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPushDirectApns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundle_id: _builtins.str,
                 p12: _builtins.str,
                 sandbox: _builtins.bool,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bundle_id: The Apple Push Notification service Bundle ID.
        :param _builtins.str p12: The base64 encoded certificate in P12 format.
        :param _builtins.bool sandbox: Set to true to use the sandbox iOS app environment, otherwise set to false to use the production iOS app environment.
        :param _builtins.bool enabled: Indicates whether the Apple Push Notification service is enabled.
        """
        pulumi.set(__self__, "bundle_id", bundle_id)
        pulumi.set(__self__, "p12", p12)
        pulumi.set(__self__, "sandbox", sandbox)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> _builtins.str:
        """
        The Apple Push Notification service Bundle ID.
        """
        return pulumi.get(self, "bundle_id")

    @_builtins.property
    @pulumi.getter
    def p12(self) -> _builtins.str:
        """
        The base64 encoded certificate in P12 format.
        """
        return pulumi.get(self, "p12")

    @_builtins.property
    @pulumi.getter
    def sandbox(self) -> _builtins.bool:
        """
        Set to true to use the sandbox iOS app environment, otherwise set to false to use the production iOS app environment.
        """
        return pulumi.get(self, "sandbox")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the Apple Push Notification service is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GuardianPushDirectFcm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverKey":
            suggest = "server_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianPushDirectFcm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianPushDirectFcm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianPushDirectFcm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_key: _builtins.str):
        """
        :param _builtins.str server_key: The Firebase Cloud Messaging Server Key. For security purposes, we don’t retrieve your existing FCM server key to check for drift.
        """
        pulumi.set(__self__, "server_key", server_key)

    @_builtins.property
    @pulumi.getter(name="serverKey")
    def server_key(self) -> _builtins.str:
        """
        The Firebase Cloud Messaging Server Key. For security purposes, we don’t retrieve your existing FCM server key to check for drift.
        """
        return pulumi.get(self, "server_key")


@pulumi.output_type
class GuardianWebauthnPlatform(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideRelyingParty":
            suggest = "override_relying_party"
        elif key == "relyingPartyIdentifier":
            suggest = "relying_party_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianWebauthnPlatform. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianWebauthnPlatform.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianWebauthnPlatform.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 override_relying_party: Optional[_builtins.bool] = None,
                 relying_party_identifier: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
        :param _builtins.bool override_relying_party: The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        :param _builtins.str relying_party_identifier: The Relying Party should be a suffix of the custom domain.
        """
        pulumi.set(__self__, "enabled", enabled)
        if override_relying_party is not None:
            pulumi.set(__self__, "override_relying_party", override_relying_party)
        if relying_party_identifier is not None:
            pulumi.set(__self__, "relying_party_identifier", relying_party_identifier)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="overrideRelyingParty")
    def override_relying_party(self) -> Optional[_builtins.bool]:
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        return pulumi.get(self, "override_relying_party")

    @_builtins.property
    @pulumi.getter(name="relyingPartyIdentifier")
    def relying_party_identifier(self) -> Optional[_builtins.str]:
        """
        The Relying Party should be a suffix of the custom domain.
        """
        return pulumi.get(self, "relying_party_identifier")


@pulumi.output_type
class GuardianWebauthnRoaming(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideRelyingParty":
            suggest = "override_relying_party"
        elif key == "relyingPartyIdentifier":
            suggest = "relying_party_identifier"
        elif key == "userVerification":
            suggest = "user_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardianWebauthnRoaming. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardianWebauthnRoaming.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardianWebauthnRoaming.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 override_relying_party: Optional[_builtins.bool] = None,
                 relying_party_identifier: Optional[_builtins.str] = None,
                 user_verification: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
        :param _builtins.bool override_relying_party: The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        :param _builtins.str relying_party_identifier: The Relying Party should be a suffix of the custom domain.
        :param _builtins.str user_verification: User verification, one of `discouraged`, `preferred` or `required`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if override_relying_party is not None:
            pulumi.set(__self__, "override_relying_party", override_relying_party)
        if relying_party_identifier is not None:
            pulumi.set(__self__, "relying_party_identifier", relying_party_identifier)
        if user_verification is not None:
            pulumi.set(__self__, "user_verification", user_verification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="overrideRelyingParty")
    def override_relying_party(self) -> Optional[_builtins.bool]:
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        return pulumi.get(self, "override_relying_party")

    @_builtins.property
    @pulumi.getter(name="relyingPartyIdentifier")
    def relying_party_identifier(self) -> Optional[_builtins.str]:
        """
        The Relying Party should be a suffix of the custom domain.
        """
        return pulumi.get(self, "relying_party_identifier")

    @_builtins.property
    @pulumi.getter(name="userVerification")
    def user_verification(self) -> Optional[_builtins.str]:
        """
        User verification, one of `discouraged`, `preferred` or `required`.
        """
        return pulumi.get(self, "user_verification")


@pulumi.output_type
class LogStreamSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsPartnerEventSource":
            suggest = "aws_partner_event_source"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "azurePartnerTopic":
            suggest = "azure_partner_topic"
        elif key == "azureRegion":
            suggest = "azure_region"
        elif key == "azureResourceGroup":
            suggest = "azure_resource_group"
        elif key == "azureSubscriptionId":
            suggest = "azure_subscription_id"
        elif key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogRegion":
            suggest = "datadog_region"
        elif key == "httpAuthorization":
            suggest = "http_authorization"
        elif key == "httpContentFormat":
            suggest = "http_content_format"
        elif key == "httpContentType":
            suggest = "http_content_type"
        elif key == "httpCustomHeaders":
            suggest = "http_custom_headers"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "mixpanelProjectId":
            suggest = "mixpanel_project_id"
        elif key == "mixpanelRegion":
            suggest = "mixpanel_region"
        elif key == "mixpanelServiceAccountPassword":
            suggest = "mixpanel_service_account_password"
        elif key == "mixpanelServiceAccountUsername":
            suggest = "mixpanel_service_account_username"
        elif key == "segmentWriteKey":
            suggest = "segment_write_key"
        elif key == "splunkDomain":
            suggest = "splunk_domain"
        elif key == "splunkPort":
            suggest = "splunk_port"
        elif key == "splunkSecure":
            suggest = "splunk_secure"
        elif key == "splunkToken":
            suggest = "splunk_token"
        elif key == "sumoSourceAddress":
            suggest = "sumo_source_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogStreamSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogStreamSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogStreamSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_account_id: Optional[_builtins.str] = None,
                 aws_partner_event_source: Optional[_builtins.str] = None,
                 aws_region: Optional[_builtins.str] = None,
                 azure_partner_topic: Optional[_builtins.str] = None,
                 azure_region: Optional[_builtins.str] = None,
                 azure_resource_group: Optional[_builtins.str] = None,
                 azure_subscription_id: Optional[_builtins.str] = None,
                 datadog_api_key: Optional[_builtins.str] = None,
                 datadog_region: Optional[_builtins.str] = None,
                 http_authorization: Optional[_builtins.str] = None,
                 http_content_format: Optional[_builtins.str] = None,
                 http_content_type: Optional[_builtins.str] = None,
                 http_custom_headers: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 http_endpoint: Optional[_builtins.str] = None,
                 mixpanel_project_id: Optional[_builtins.str] = None,
                 mixpanel_region: Optional[_builtins.str] = None,
                 mixpanel_service_account_password: Optional[_builtins.str] = None,
                 mixpanel_service_account_username: Optional[_builtins.str] = None,
                 segment_write_key: Optional[_builtins.str] = None,
                 splunk_domain: Optional[_builtins.str] = None,
                 splunk_port: Optional[_builtins.str] = None,
                 splunk_secure: Optional[_builtins.bool] = None,
                 splunk_token: Optional[_builtins.str] = None,
                 sumo_source_address: Optional[_builtins.str] = None):
        """
        :param _builtins.str aws_account_id: The AWS Account ID.
        :param _builtins.str aws_partner_event_source: Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
        :param _builtins.str aws_region: The region in which the EventBridge event source will be created. Possible values: `ap-east-1`, `ap-northeast-1`, `ap-northeast-2`, `ap-northeast-3`, `ap-south-1`, `ap-southeast-1`, `ap-southeast-2`, `ca-central-1`, `cn-north-1`, `cn-northwest-1`, `eu-central-1`, `eu-north-1`, `eu-west-1`, `eu-west-2`, `eu-west-3`, `me-south-1`, `sa-east-1`, `us-gov-east-1`, `us-gov-west-1`, `us-east-1`, `us-east-2`, `us-west-1`, `us-west-2`.
        :param _builtins.str azure_partner_topic: Name of the Partner Topic to be used with Azure. Generally should not be specified.
        :param _builtins.str azure_region: The Azure region code. Possible values: `australiacentral`, `australiaeast`, `australiasoutheast`, `brazilsouth`, `canadacentral`, `canadaeast`, `centralindia`, `centralus`, `eastasia`, `eastus`, `eastus2`, `francecentral`, `germanywestcentral`, `japaneast`, `japanwest`, `koreacentral`, `koreasouth`, `northcentralus`, `northeurope`, `norwayeast`, `southafricanorth`, `southcentralus`, `southeastasia`, `southindia`, `switzerlandnorth`, `uaenorth`, `uksouth`, `ukwest`, `westcentralus`, `westeurope`, `westindia`, `westus`, `westus2`.
        :param _builtins.str azure_resource_group: The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
        :param _builtins.str azure_subscription_id: The unique alphanumeric string that identifies your Azure subscription.
        :param _builtins.str datadog_api_key: The Datadog API key.
        :param _builtins.str datadog_region: The Datadog region. Possible values: `us`, `eu`, `us3`, `us5`.
        :param _builtins.str http_authorization: Sent in the HTTP "Authorization" header with each request.
        :param _builtins.str http_content_format: The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
        :param _builtins.str http_content_type: The "Content-Type" header to send over HTTP. Common value is "application/json".
        :param Sequence[Mapping[str, _builtins.str]] http_custom_headers: Additional HTTP headers to be included as part of the HTTP request.
        :param _builtins.str http_endpoint: The HTTP endpoint to send streaming logs.
        :param _builtins.str mixpanel_project_id: The Mixpanel project ID, found on the Project Settings page.
        :param _builtins.str mixpanel_region: The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
        :param _builtins.str mixpanel_service_account_password: The Mixpanel Service Account password.
        :param _builtins.str mixpanel_service_account_username: The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
        :param _builtins.str segment_write_key: The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
        :param _builtins.str splunk_domain: The Splunk domain name.
        :param _builtins.str splunk_port: The Splunk port.
        :param _builtins.bool splunk_secure: This toggle should be turned off when using self-signed certificates.
        :param _builtins.str splunk_token: The Splunk access token.
        :param _builtins.str sumo_source_address: Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
        """
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_partner_event_source is not None:
            pulumi.set(__self__, "aws_partner_event_source", aws_partner_event_source)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if azure_partner_topic is not None:
            pulumi.set(__self__, "azure_partner_topic", azure_partner_topic)
        if azure_region is not None:
            pulumi.set(__self__, "azure_region", azure_region)
        if azure_resource_group is not None:
            pulumi.set(__self__, "azure_resource_group", azure_resource_group)
        if azure_subscription_id is not None:
            pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if http_authorization is not None:
            pulumi.set(__self__, "http_authorization", http_authorization)
        if http_content_format is not None:
            pulumi.set(__self__, "http_content_format", http_content_format)
        if http_content_type is not None:
            pulumi.set(__self__, "http_content_type", http_content_type)
        if http_custom_headers is not None:
            pulumi.set(__self__, "http_custom_headers", http_custom_headers)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if mixpanel_project_id is not None:
            pulumi.set(__self__, "mixpanel_project_id", mixpanel_project_id)
        if mixpanel_region is not None:
            pulumi.set(__self__, "mixpanel_region", mixpanel_region)
        if mixpanel_service_account_password is not None:
            pulumi.set(__self__, "mixpanel_service_account_password", mixpanel_service_account_password)
        if mixpanel_service_account_username is not None:
            pulumi.set(__self__, "mixpanel_service_account_username", mixpanel_service_account_username)
        if segment_write_key is not None:
            pulumi.set(__self__, "segment_write_key", segment_write_key)
        if splunk_domain is not None:
            pulumi.set(__self__, "splunk_domain", splunk_domain)
        if splunk_port is not None:
            pulumi.set(__self__, "splunk_port", splunk_port)
        if splunk_secure is not None:
            pulumi.set(__self__, "splunk_secure", splunk_secure)
        if splunk_token is not None:
            pulumi.set(__self__, "splunk_token", splunk_token)
        if sumo_source_address is not None:
            pulumi.set(__self__, "sumo_source_address", sumo_source_address)

    @_builtins.property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[_builtins.str]:
        """
        The AWS Account ID.
        """
        return pulumi.get(self, "aws_account_id")

    @_builtins.property
    @pulumi.getter(name="awsPartnerEventSource")
    def aws_partner_event_source(self) -> Optional[_builtins.str]:
        """
        Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
        """
        return pulumi.get(self, "aws_partner_event_source")

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[_builtins.str]:
        """
        The region in which the EventBridge event source will be created. Possible values: `ap-east-1`, `ap-northeast-1`, `ap-northeast-2`, `ap-northeast-3`, `ap-south-1`, `ap-southeast-1`, `ap-southeast-2`, `ca-central-1`, `cn-north-1`, `cn-northwest-1`, `eu-central-1`, `eu-north-1`, `eu-west-1`, `eu-west-2`, `eu-west-3`, `me-south-1`, `sa-east-1`, `us-gov-east-1`, `us-gov-west-1`, `us-east-1`, `us-east-2`, `us-west-1`, `us-west-2`.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter(name="azurePartnerTopic")
    def azure_partner_topic(self) -> Optional[_builtins.str]:
        """
        Name of the Partner Topic to be used with Azure. Generally should not be specified.
        """
        return pulumi.get(self, "azure_partner_topic")

    @_builtins.property
    @pulumi.getter(name="azureRegion")
    def azure_region(self) -> Optional[_builtins.str]:
        """
        The Azure region code. Possible values: `australiacentral`, `australiaeast`, `australiasoutheast`, `brazilsouth`, `canadacentral`, `canadaeast`, `centralindia`, `centralus`, `eastasia`, `eastus`, `eastus2`, `francecentral`, `germanywestcentral`, `japaneast`, `japanwest`, `koreacentral`, `koreasouth`, `northcentralus`, `northeurope`, `norwayeast`, `southafricanorth`, `southcentralus`, `southeastasia`, `southindia`, `switzerlandnorth`, `uaenorth`, `uksouth`, `ukwest`, `westcentralus`, `westeurope`, `westindia`, `westus`, `westus2`.
        """
        return pulumi.get(self, "azure_region")

    @_builtins.property
    @pulumi.getter(name="azureResourceGroup")
    def azure_resource_group(self) -> Optional[_builtins.str]:
        """
        The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
        """
        return pulumi.get(self, "azure_resource_group")

    @_builtins.property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> Optional[_builtins.str]:
        """
        The unique alphanumeric string that identifies your Azure subscription.
        """
        return pulumi.get(self, "azure_subscription_id")

    @_builtins.property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[_builtins.str]:
        """
        The Datadog API key.
        """
        return pulumi.get(self, "datadog_api_key")

    @_builtins.property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[_builtins.str]:
        """
        The Datadog region. Possible values: `us`, `eu`, `us3`, `us5`.
        """
        return pulumi.get(self, "datadog_region")

    @_builtins.property
    @pulumi.getter(name="httpAuthorization")
    def http_authorization(self) -> Optional[_builtins.str]:
        """
        Sent in the HTTP "Authorization" header with each request.
        """
        return pulumi.get(self, "http_authorization")

    @_builtins.property
    @pulumi.getter(name="httpContentFormat")
    def http_content_format(self) -> Optional[_builtins.str]:
        """
        The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
        """
        return pulumi.get(self, "http_content_format")

    @_builtins.property
    @pulumi.getter(name="httpContentType")
    def http_content_type(self) -> Optional[_builtins.str]:
        """
        The "Content-Type" header to send over HTTP. Common value is "application/json".
        """
        return pulumi.get(self, "http_content_type")

    @_builtins.property
    @pulumi.getter(name="httpCustomHeaders")
    def http_custom_headers(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        Additional HTTP headers to be included as part of the HTTP request.
        """
        return pulumi.get(self, "http_custom_headers")

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        The HTTP endpoint to send streaming logs.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="mixpanelProjectId")
    def mixpanel_project_id(self) -> Optional[_builtins.str]:
        """
        The Mixpanel project ID, found on the Project Settings page.
        """
        return pulumi.get(self, "mixpanel_project_id")

    @_builtins.property
    @pulumi.getter(name="mixpanelRegion")
    def mixpanel_region(self) -> Optional[_builtins.str]:
        """
        The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
        """
        return pulumi.get(self, "mixpanel_region")

    @_builtins.property
    @pulumi.getter(name="mixpanelServiceAccountPassword")
    def mixpanel_service_account_password(self) -> Optional[_builtins.str]:
        """
        The Mixpanel Service Account password.
        """
        return pulumi.get(self, "mixpanel_service_account_password")

    @_builtins.property
    @pulumi.getter(name="mixpanelServiceAccountUsername")
    def mixpanel_service_account_username(self) -> Optional[_builtins.str]:
        """
        The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
        """
        return pulumi.get(self, "mixpanel_service_account_username")

    @_builtins.property
    @pulumi.getter(name="segmentWriteKey")
    def segment_write_key(self) -> Optional[_builtins.str]:
        """
        The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
        """
        return pulumi.get(self, "segment_write_key")

    @_builtins.property
    @pulumi.getter(name="splunkDomain")
    def splunk_domain(self) -> Optional[_builtins.str]:
        """
        The Splunk domain name.
        """
        return pulumi.get(self, "splunk_domain")

    @_builtins.property
    @pulumi.getter(name="splunkPort")
    def splunk_port(self) -> Optional[_builtins.str]:
        """
        The Splunk port.
        """
        return pulumi.get(self, "splunk_port")

    @_builtins.property
    @pulumi.getter(name="splunkSecure")
    def splunk_secure(self) -> Optional[_builtins.bool]:
        """
        This toggle should be turned off when using self-signed certificates.
        """
        return pulumi.get(self, "splunk_secure")

    @_builtins.property
    @pulumi.getter(name="splunkToken")
    def splunk_token(self) -> Optional[_builtins.str]:
        """
        The Splunk access token.
        """
        return pulumi.get(self, "splunk_token")

    @_builtins.property
    @pulumi.getter(name="sumoSourceAddress")
    def sumo_source_address(self) -> Optional[_builtins.str]:
        """
        Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
        """
        return pulumi.get(self, "sumo_source_address")


@pulumi.output_type
class NetworkAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notMatch":
            suggest = "not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.NetworkAclRuleAction',
                 scope: _builtins.str,
                 match: Optional['outputs.NetworkAclRuleMatch'] = None,
                 not_match: Optional['outputs.NetworkAclRuleNotMatch'] = None):
        """
        :param 'NetworkAclRuleActionArgs' action: The action configuration for the Network ACL Rule. Only one action type (block, allow, log, or redirect) should be specified.
        :param _builtins.str scope: The scope of the Network ACL Rule
        :param 'NetworkAclRuleMatchArgs' match: The configuration for the Network ACL Rule
        :param 'NetworkAclRuleNotMatchArgs' not_match: The configuration for the Network ACL Rule
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "scope", scope)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if not_match is not None:
            pulumi.set(__self__, "not_match", not_match)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'outputs.NetworkAclRuleAction':
        """
        The action configuration for the Network ACL Rule. Only one action type (block, allow, log, or redirect) should be specified.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope of the Network ACL Rule
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.NetworkAclRuleMatch']:
        """
        The configuration for the Network ACL Rule
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="notMatch")
    def not_match(self) -> Optional['outputs.NetworkAclRuleNotMatch']:
        """
        The configuration for the Network ACL Rule
        """
        return pulumi.get(self, "not_match")


@pulumi.output_type
class NetworkAclRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: Optional[_builtins.bool] = None,
                 block: Optional[_builtins.bool] = None,
                 log: Optional[_builtins.bool] = None,
                 redirect: Optional[_builtins.bool] = None,
                 redirect_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow: If true, allows the request. When using allow action, no other properties should be set.
        :param _builtins.bool block: If true, blocks the request. When using block action, no other properties should be set.
        :param _builtins.bool log: If true, logs the request. When using log action, no other properties should be set.
        :param _builtins.bool redirect: If true, redirects the request. When using redirect action, redirect_uri must also be specified.
        :param _builtins.str redirect_uri: The URI to redirect to when redirect is true. Required when redirect is true. Must be between 1 and 2000 characters.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[_builtins.bool]:
        """
        If true, allows the request. When using allow action, no other properties should be set.
        """
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[_builtins.bool]:
        """
        If true, blocks the request. When using block action, no other properties should be set.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional[_builtins.bool]:
        """
        If true, logs the request. When using log action, no other properties should be set.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[_builtins.bool]:
        """
        If true, redirects the request. When using redirect action, redirect_uri must also be specified.
        """
        return pulumi.get(self, "redirect")

    @_builtins.property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[_builtins.str]:
        """
        The URI to redirect to when redirect is true. Required when redirect is true. Must be between 1 and 2000 characters.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class NetworkAclRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoCountryCodes":
            suggest = "geo_country_codes"
        elif key == "geoSubdivisionCodes":
            suggest = "geo_subdivision_codes"
        elif key == "ipv4Cidrs":
            suggest = "ipv4_cidrs"
        elif key == "ipv6Cidrs":
            suggest = "ipv6_cidrs"
        elif key == "ja3Fingerprints":
            suggest = "ja3_fingerprints"
        elif key == "ja4Fingerprints":
            suggest = "ja4_fingerprints"
        elif key == "userAgents":
            suggest = "user_agents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asns: Optional[Sequence[_builtins.int]] = None,
                 geo_country_codes: Optional[Sequence[_builtins.str]] = None,
                 geo_subdivision_codes: Optional[Sequence[_builtins.str]] = None,
                 ipv4_cidrs: Optional[Sequence[_builtins.str]] = None,
                 ipv6_cidrs: Optional[Sequence[_builtins.str]] = None,
                 ja3_fingerprints: Optional[Sequence[_builtins.str]] = None,
                 ja4_fingerprints: Optional[Sequence[_builtins.str]] = None,
                 user_agents: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.int] asns: ASNs. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_country_codes: Geo Country Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_subdivision_codes: Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ipv4_cidrs: IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ipv6_cidrs: IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ja3_fingerprints: JA3 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ja4_fingerprints: JA4 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] user_agents: User Agents. Must contain between 1 and 10 unique items.
        """
        if asns is not None:
            pulumi.set(__self__, "asns", asns)
        if geo_country_codes is not None:
            pulumi.set(__self__, "geo_country_codes", geo_country_codes)
        if geo_subdivision_codes is not None:
            pulumi.set(__self__, "geo_subdivision_codes", geo_subdivision_codes)
        if ipv4_cidrs is not None:
            pulumi.set(__self__, "ipv4_cidrs", ipv4_cidrs)
        if ipv6_cidrs is not None:
            pulumi.set(__self__, "ipv6_cidrs", ipv6_cidrs)
        if ja3_fingerprints is not None:
            pulumi.set(__self__, "ja3_fingerprints", ja3_fingerprints)
        if ja4_fingerprints is not None:
            pulumi.set(__self__, "ja4_fingerprints", ja4_fingerprints)
        if user_agents is not None:
            pulumi.set(__self__, "user_agents", user_agents)

    @_builtins.property
    @pulumi.getter
    def asns(self) -> Optional[Sequence[_builtins.int]]:
        """
        ASNs. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "asns")

    @_builtins.property
    @pulumi.getter(name="geoCountryCodes")
    def geo_country_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Geo Country Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_country_codes")

    @_builtins.property
    @pulumi.getter(name="geoSubdivisionCodes")
    def geo_subdivision_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_subdivision_codes")

    @_builtins.property
    @pulumi.getter(name="ipv4Cidrs")
    def ipv4_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv4_cidrs")

    @_builtins.property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidrs")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprints")
    def ja3_fingerprints(self) -> Optional[Sequence[_builtins.str]]:
        """
        JA3 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja3_fingerprints")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprints")
    def ja4_fingerprints(self) -> Optional[Sequence[_builtins.str]]:
        """
        JA4 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja4_fingerprints")

    @_builtins.property
    @pulumi.getter(name="userAgents")
    def user_agents(self) -> Optional[Sequence[_builtins.str]]:
        """
        User Agents. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "user_agents")


@pulumi.output_type
class NetworkAclRuleNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoCountryCodes":
            suggest = "geo_country_codes"
        elif key == "geoSubdivisionCodes":
            suggest = "geo_subdivision_codes"
        elif key == "ipv4Cidrs":
            suggest = "ipv4_cidrs"
        elif key == "ipv6Cidrs":
            suggest = "ipv6_cidrs"
        elif key == "ja3Fingerprints":
            suggest = "ja3_fingerprints"
        elif key == "ja4Fingerprints":
            suggest = "ja4_fingerprints"
        elif key == "userAgents":
            suggest = "user_agents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclRuleNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclRuleNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclRuleNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asns: Optional[Sequence[_builtins.int]] = None,
                 geo_country_codes: Optional[Sequence[_builtins.str]] = None,
                 geo_subdivision_codes: Optional[Sequence[_builtins.str]] = None,
                 ipv4_cidrs: Optional[Sequence[_builtins.str]] = None,
                 ipv6_cidrs: Optional[Sequence[_builtins.str]] = None,
                 ja3_fingerprints: Optional[Sequence[_builtins.str]] = None,
                 ja4_fingerprints: Optional[Sequence[_builtins.str]] = None,
                 user_agents: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.int] asns: ASNs. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_country_codes: Geo Country Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_subdivision_codes: Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ipv4_cidrs: IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ipv6_cidrs: IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ja3_fingerprints: JA3 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ja4_fingerprints: JA4 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] user_agents: User Agents. Must contain between 1 and 10 unique items.
        """
        if asns is not None:
            pulumi.set(__self__, "asns", asns)
        if geo_country_codes is not None:
            pulumi.set(__self__, "geo_country_codes", geo_country_codes)
        if geo_subdivision_codes is not None:
            pulumi.set(__self__, "geo_subdivision_codes", geo_subdivision_codes)
        if ipv4_cidrs is not None:
            pulumi.set(__self__, "ipv4_cidrs", ipv4_cidrs)
        if ipv6_cidrs is not None:
            pulumi.set(__self__, "ipv6_cidrs", ipv6_cidrs)
        if ja3_fingerprints is not None:
            pulumi.set(__self__, "ja3_fingerprints", ja3_fingerprints)
        if ja4_fingerprints is not None:
            pulumi.set(__self__, "ja4_fingerprints", ja4_fingerprints)
        if user_agents is not None:
            pulumi.set(__self__, "user_agents", user_agents)

    @_builtins.property
    @pulumi.getter
    def asns(self) -> Optional[Sequence[_builtins.int]]:
        """
        ASNs. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "asns")

    @_builtins.property
    @pulumi.getter(name="geoCountryCodes")
    def geo_country_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Geo Country Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_country_codes")

    @_builtins.property
    @pulumi.getter(name="geoSubdivisionCodes")
    def geo_subdivision_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_subdivision_codes")

    @_builtins.property
    @pulumi.getter(name="ipv4Cidrs")
    def ipv4_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv4_cidrs")

    @_builtins.property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidrs")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprints")
    def ja3_fingerprints(self) -> Optional[Sequence[_builtins.str]]:
        """
        JA3 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja3_fingerprints")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprints")
    def ja4_fingerprints(self) -> Optional[Sequence[_builtins.str]]:
        """
        JA4 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja4_fingerprints")

    @_builtins.property
    @pulumi.getter(name="userAgents")
    def user_agents(self) -> Optional[Sequence[_builtins.str]]:
        """
        User Agents. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "user_agents")


@pulumi.output_type
class OrganizationBranding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logoUrl":
            suggest = "logo_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationBranding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationBranding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationBranding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colors: Optional[Mapping[str, _builtins.str]] = None,
                 logo_url: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] colors: Color scheme used to customize the login pages.
        :param _builtins.str logo_url: URL of logo to display on login page.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Color scheme used to customize the login pages.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[_builtins.str]:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")


@pulumi.output_type
class OrganizationConnectionsEnabledConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"
        elif key == "assignMembershipOnLogin":
            suggest = "assign_membership_on_login"
        elif key == "isSignupEnabled":
            suggest = "is_signup_enabled"
        elif key == "showAsButton":
            suggest = "show_as_button"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationConnectionsEnabledConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationConnectionsEnabledConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationConnectionsEnabledConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_id: _builtins.str,
                 assign_membership_on_login: Optional[_builtins.bool] = None,
                 is_signup_enabled: Optional[_builtins.bool] = None,
                 show_as_button: Optional[_builtins.bool] = None):
        """
        :param _builtins.str connection_id: The ID of the connection to enable for the organization.
        :param _builtins.bool assign_membership_on_login: When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        :param _builtins.bool is_signup_enabled: Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        :param _builtins.bool show_as_button: Determines whether a connection should be displayed on this organization’s login prompt. Only applicable for enterprise connections.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        if assign_membership_on_login is not None:
            pulumi.set(__self__, "assign_membership_on_login", assign_membership_on_login)
        if is_signup_enabled is not None:
            pulumi.set(__self__, "is_signup_enabled", is_signup_enabled)
        if show_as_button is not None:
            pulumi.set(__self__, "show_as_button", show_as_button)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        The ID of the connection to enable for the organization.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="assignMembershipOnLogin")
    def assign_membership_on_login(self) -> Optional[_builtins.bool]:
        """
        When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        """
        return pulumi.get(self, "assign_membership_on_login")

    @_builtins.property
    @pulumi.getter(name="isSignupEnabled")
    def is_signup_enabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        """
        return pulumi.get(self, "is_signup_enabled")

    @_builtins.property
    @pulumi.getter(name="showAsButton")
    def show_as_button(self) -> Optional[_builtins.bool]:
        """
        Determines whether a connection should be displayed on this organization’s login prompt. Only applicable for enterprise connections.
        """
        return pulumi.get(self, "show_as_button")


@pulumi.output_type
class OrganizationTokenQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTokenQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTokenQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTokenQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials: 'outputs.OrganizationTokenQuotaClientCredentials'):
        """
        :param 'OrganizationTokenQuotaClientCredentialsArgs' client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> 'outputs.OrganizationTokenQuotaClientCredentials':
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class OrganizationTokenQuotaClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perDay":
            suggest = "per_day"
        elif key == "perHour":
            suggest = "per_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTokenQuotaClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTokenQuotaClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTokenQuotaClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce: Optional[_builtins.bool] = None,
                 per_day: Optional[_builtins.int] = None,
                 per_hour: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if per_day is not None:
            pulumi.set(__self__, "per_day", per_day)
        if per_hour is not None:
            pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.bool]:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class PagesChangePassword(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class PagesError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "showLogLink":
            suggest = "show_log_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PagesError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PagesError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PagesError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 show_log_link: _builtins.bool,
                 html: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool show_log_link: Indicates whether to show the link to logs as part of the default error page.
        :param _builtins.str html: Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        :param _builtins.str url: URL to redirect to when an error occurs, instead of showing the default error page.
        """
        pulumi.set(__self__, "show_log_link", show_log_link)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="showLogLink")
    def show_log_link(self) -> _builtins.bool:
        """
        Indicates whether to show the link to logs as part of the default error page.
        """
        return pulumi.get(self, "show_log_link")

    @_builtins.property
    @pulumi.getter
    def html(self) -> Optional[_builtins.str]:
        """
        Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL to redirect to when an error occurs, instead of showing the default error page.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PagesGuardianMfa(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class PagesLogin(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class PhoneProviderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryMethods":
            suggest = "delivery_methods"
        elif key == "defaultFrom":
            suggest = "default_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PhoneProviderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PhoneProviderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PhoneProviderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_methods: Sequence[_builtins.str],
                 default_from: Optional[_builtins.str] = None,
                 mssid: Optional[_builtins.str] = None,
                 sid: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] delivery_methods: Media set supported by a given provider to deliver a notification
        :param _builtins.str default_from: Default sender subject as "from" when no other value is specified.
        :param _builtins.str mssid: Twilio Messaging Service SID
        :param _builtins.str sid: Twilio Account SID.
        """
        pulumi.set(__self__, "delivery_methods", delivery_methods)
        if default_from is not None:
            pulumi.set(__self__, "default_from", default_from)
        if mssid is not None:
            pulumi.set(__self__, "mssid", mssid)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)

    @_builtins.property
    @pulumi.getter(name="deliveryMethods")
    def delivery_methods(self) -> Sequence[_builtins.str]:
        """
        Media set supported by a given provider to deliver a notification
        """
        return pulumi.get(self, "delivery_methods")

    @_builtins.property
    @pulumi.getter(name="defaultFrom")
    def default_from(self) -> Optional[_builtins.str]:
        """
        Default sender subject as "from" when no other value is specified.
        """
        return pulumi.get(self, "default_from")

    @_builtins.property
    @pulumi.getter
    def mssid(self) -> Optional[_builtins.str]:
        """
        Twilio Messaging Service SID
        """
        return pulumi.get(self, "mssid")

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[_builtins.str]:
        """
        Twilio Account SID.
        """
        return pulumi.get(self, "sid")


@pulumi.output_type
class PhoneProviderCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PhoneProviderCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PhoneProviderCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PhoneProviderCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_token: The Auth Token for the phone provider.
        """
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[_builtins.str]:
        """
        The Auth Token for the phone provider.
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class PromptScreenPartialInsertionPoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formContent":
            suggest = "form_content"
        elif key == "formContentEnd":
            suggest = "form_content_end"
        elif key == "formContentStart":
            suggest = "form_content_start"
        elif key == "formFooterEnd":
            suggest = "form_footer_end"
        elif key == "formFooterStart":
            suggest = "form_footer_start"
        elif key == "secondaryActionsEnd":
            suggest = "secondary_actions_end"
        elif key == "secondaryActionsStart":
            suggest = "secondary_actions_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptScreenPartialInsertionPoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptScreenPartialInsertionPoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptScreenPartialInsertionPoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 form_content: Optional[_builtins.str] = None,
                 form_content_end: Optional[_builtins.str] = None,
                 form_content_start: Optional[_builtins.str] = None,
                 form_footer_end: Optional[_builtins.str] = None,
                 form_footer_start: Optional[_builtins.str] = None,
                 secondary_actions_end: Optional[_builtins.str] = None,
                 secondary_actions_start: Optional[_builtins.str] = None):
        """
        :param _builtins.str form_content: Content that goes inside the form
        :param _builtins.str form_content_end: Content that goes at the end of the form.
        :param _builtins.str form_content_start: Content that goes at the start of the form.
        :param _builtins.str form_footer_end: Footer content for the end of the footer.
        :param _builtins.str form_footer_start: Footer content for the start of the footer.
        :param _builtins.str secondary_actions_end: Actions that go at the end of secondary actions.
        :param _builtins.str secondary_actions_start: Actions that go at the start of secondary actions.
        """
        if form_content is not None:
            pulumi.set(__self__, "form_content", form_content)
        if form_content_end is not None:
            pulumi.set(__self__, "form_content_end", form_content_end)
        if form_content_start is not None:
            pulumi.set(__self__, "form_content_start", form_content_start)
        if form_footer_end is not None:
            pulumi.set(__self__, "form_footer_end", form_footer_end)
        if form_footer_start is not None:
            pulumi.set(__self__, "form_footer_start", form_footer_start)
        if secondary_actions_end is not None:
            pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        if secondary_actions_start is not None:
            pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @_builtins.property
    @pulumi.getter(name="formContent")
    def form_content(self) -> Optional[_builtins.str]:
        """
        Content that goes inside the form
        """
        return pulumi.get(self, "form_content")

    @_builtins.property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> Optional[_builtins.str]:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @_builtins.property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> Optional[_builtins.str]:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @_builtins.property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> Optional[_builtins.str]:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @_builtins.property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> Optional[_builtins.str]:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> Optional[_builtins.str]:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> Optional[_builtins.str]:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")


@pulumi.output_type
class PromptScreenPartialsScreenPartial(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertionPoints":
            suggest = "insertion_points"
        elif key == "screenName":
            suggest = "screen_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptScreenPartialsScreenPartial. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptScreenPartialsScreenPartial.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptScreenPartialsScreenPartial.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insertion_points: 'outputs.PromptScreenPartialsScreenPartialInsertionPoints',
                 screen_name: _builtins.str):
        """
        :param _builtins.str screen_name: The name of the screen associated with the partials
        """
        pulumi.set(__self__, "insertion_points", insertion_points)
        pulumi.set(__self__, "screen_name", screen_name)

    @_builtins.property
    @pulumi.getter(name="insertionPoints")
    def insertion_points(self) -> 'outputs.PromptScreenPartialsScreenPartialInsertionPoints':
        return pulumi.get(self, "insertion_points")

    @_builtins.property
    @pulumi.getter(name="screenName")
    def screen_name(self) -> _builtins.str:
        """
        The name of the screen associated with the partials
        """
        return pulumi.get(self, "screen_name")


@pulumi.output_type
class PromptScreenPartialsScreenPartialInsertionPoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formContent":
            suggest = "form_content"
        elif key == "formContentEnd":
            suggest = "form_content_end"
        elif key == "formContentStart":
            suggest = "form_content_start"
        elif key == "formFooterEnd":
            suggest = "form_footer_end"
        elif key == "formFooterStart":
            suggest = "form_footer_start"
        elif key == "secondaryActionsEnd":
            suggest = "secondary_actions_end"
        elif key == "secondaryActionsStart":
            suggest = "secondary_actions_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptScreenPartialsScreenPartialInsertionPoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptScreenPartialsScreenPartialInsertionPoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptScreenPartialsScreenPartialInsertionPoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 form_content: Optional[_builtins.str] = None,
                 form_content_end: Optional[_builtins.str] = None,
                 form_content_start: Optional[_builtins.str] = None,
                 form_footer_end: Optional[_builtins.str] = None,
                 form_footer_start: Optional[_builtins.str] = None,
                 secondary_actions_end: Optional[_builtins.str] = None,
                 secondary_actions_start: Optional[_builtins.str] = None):
        """
        :param _builtins.str form_content: Content that goes inside the form
        :param _builtins.str form_content_end: Content that goes at the end of the form.
        :param _builtins.str form_content_start: Content that goes at the start of the form.
        :param _builtins.str form_footer_end: Footer content for the end of the footer.
        :param _builtins.str form_footer_start: Footer content for the start of the footer.
        :param _builtins.str secondary_actions_end: Actions that go at the end of secondary actions.
        :param _builtins.str secondary_actions_start: Actions that go at the start of secondary actions.
        """
        if form_content is not None:
            pulumi.set(__self__, "form_content", form_content)
        if form_content_end is not None:
            pulumi.set(__self__, "form_content_end", form_content_end)
        if form_content_start is not None:
            pulumi.set(__self__, "form_content_start", form_content_start)
        if form_footer_end is not None:
            pulumi.set(__self__, "form_footer_end", form_footer_end)
        if form_footer_start is not None:
            pulumi.set(__self__, "form_footer_start", form_footer_start)
        if secondary_actions_end is not None:
            pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        if secondary_actions_start is not None:
            pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @_builtins.property
    @pulumi.getter(name="formContent")
    def form_content(self) -> Optional[_builtins.str]:
        """
        Content that goes inside the form
        """
        return pulumi.get(self, "form_content")

    @_builtins.property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> Optional[_builtins.str]:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @_builtins.property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> Optional[_builtins.str]:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @_builtins.property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> Optional[_builtins.str]:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @_builtins.property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> Optional[_builtins.str]:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> Optional[_builtins.str]:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> Optional[_builtins.str]:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")


@pulumi.output_type
class PromptScreenRendererFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptScreenRendererFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptScreenRendererFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptScreenRendererFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 clients: Optional[_builtins.str] = None,
                 domains: Optional[_builtins.str] = None,
                 organizations: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: Type of match to apply. Options: `includes_any`, `excludes_any`.
        :param _builtins.str clients: An array of clients (applications) identified by id or a metadata key/value pair. Entity Limit: 25.
        :param _builtins.str domains: An array of domains identified by id or a metadata key/value pair. Entity Limit: 25.
        :param _builtins.str organizations: An array of organizations identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        pulumi.set(__self__, "match_type", match_type)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if organizations is not None:
            pulumi.set(__self__, "organizations", organizations)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Type of match to apply. Options: `includes_any`, `excludes_any`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[_builtins.str]:
        """
        An array of clients (applications) identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[_builtins.str]:
        """
        An array of domains identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Optional[_builtins.str]:
        """
        An array of organizations identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "organizations")


@pulumi.output_type
class ResourceServerAuthorizationDetail(dict):
    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable: Disable authorization details.
        :param _builtins.str type: Type of authorization details.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        Disable authorization details.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of authorization details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceServerProofOfPossession(dict):
    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 mechanism: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable: Disable proof-of-possession.
        :param _builtins.str mechanism: Mechanism used for proof-of-possession. `mtls` or `dpop` is supported.
        :param _builtins.bool required: Indicates whether proof-of-possession is required with this resource server.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        Disable proof-of-possession.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[_builtins.str]:
        """
        Mechanism used for proof-of-possession. `mtls` or `dpop` is supported.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Indicates whether proof-of-possession is required with this resource server.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class ResourceServerScopesScope(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
        :param _builtins.str description: User-friendly description of the scope (permission).
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        User-friendly description of the scope (permission).
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ResourceServerTokenEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKey":
            suggest = "encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceServerTokenEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceServerTokenEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceServerTokenEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 encryption_key: Optional['outputs.ResourceServerTokenEncryptionEncryptionKey'] = None,
                 format: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable: Disable token encryption.
        :param 'ResourceServerTokenEncryptionEncryptionKeyArgs' encryption_key: Authorization details for this resource server.
        :param _builtins.str format: Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        Disable token encryption.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional['outputs.ResourceServerTokenEncryptionEncryptionKey']:
        """
        Authorization details for this resource server.
        """
        return pulumi.get(self, "encryption_key")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class ResourceServerTokenEncryptionEncryptionKey(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 pem: _builtins.str,
                 kid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str algorithm: Algorithm used to encrypt the token.
        :param _builtins.str pem: PEM-formatted public key. Must be JSON escaped.
        :param _builtins.str kid: Key ID.
        :param _builtins.str name: Name of the encryption key.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "pem", pem)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        Algorithm used to encrypt the token.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def pem(self) -> _builtins.str:
        """
        PEM-formatted public key. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @_builtins.property
    @pulumi.getter
    def kid(self) -> Optional[_builtins.str]:
        """
        Key ID.
        """
        return pulumi.get(self, "kid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the encryption key.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RolePermissionsPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceServerIdentifier":
            suggest = "resource_server_identifier"
        elif key == "resourceServerName":
            suggest = "resource_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RolePermissionsPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RolePermissionsPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RolePermissionsPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_server_identifier: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 resource_server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of permission.
        :param _builtins.str resource_server_identifier: Resource server identifier associated with the permission.
        :param _builtins.str description: Description of the permission.
        :param _builtins.str resource_server_name: Name of resource server that the permission is associated with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_server_name is not None:
            pulumi.set(__self__, "resource_server_name", resource_server_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> _builtins.str:
        """
        Resource server identifier associated with the permission.
        """
        return pulumi.get(self, "resource_server_identifier")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> Optional[_builtins.str]:
        """
        Name of resource server that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")


@pulumi.output_type
class SelfServiceProfileBranding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logoUrl":
            suggest = "logo_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfServiceProfileBranding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfServiceProfileBranding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfServiceProfileBranding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colors: Optional['outputs.SelfServiceProfileBrandingColors'] = None,
                 logo_url: Optional[_builtins.str] = None):
        """
        :param 'SelfServiceProfileBrandingColorsArgs' colors: Configuration settings for colors for branding.
        :param _builtins.str logo_url: URL of logo to display on login page.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional['outputs.SelfServiceProfileBrandingColors']:
        """
        Configuration settings for colors for branding.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[_builtins.str]:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")


@pulumi.output_type
class SelfServiceProfileBrandingColors(dict):
    def __init__(__self__, *,
                 primary: Optional[_builtins.str] = None):
        """
        :param _builtins.str primary: Primary button background color in hexadecimal.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[_builtins.str]:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class SelfServiceProfileUserAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isOptional":
            suggest = "is_optional"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfServiceProfileUserAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfServiceProfileUserAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfServiceProfileUserAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 is_optional: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str description: A human readable description of the attribute.
        :param _builtins.bool is_optional: Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        :param _builtins.str name: Attribute’s name on Auth0 side
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "is_optional", is_optional)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A human readable description of the attribute.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> _builtins.bool:
        """
        Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        """
        return pulumi.get(self, "is_optional")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Attribute’s name on Auth0 side
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TenantDefaultTokenQuota(dict):
    def __init__(__self__, *,
                 clients: Optional['outputs.TenantDefaultTokenQuotaClients'] = None,
                 organizations: Optional['outputs.TenantDefaultTokenQuotaOrganizations'] = None):
        """
        :param 'TenantDefaultTokenQuotaClientsArgs' clients: The token quota configuration.
        :param 'TenantDefaultTokenQuotaOrganizationsArgs' organizations: The token quota configuration.
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if organizations is not None:
            pulumi.set(__self__, "organizations", organizations)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional['outputs.TenantDefaultTokenQuotaClients']:
        """
        The token quota configuration.
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Optional['outputs.TenantDefaultTokenQuotaOrganizations']:
        """
        The token quota configuration.
        """
        return pulumi.get(self, "organizations")


@pulumi.output_type
class TenantDefaultTokenQuotaClients(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantDefaultTokenQuotaClients. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantDefaultTokenQuotaClients.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantDefaultTokenQuotaClients.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials: 'outputs.TenantDefaultTokenQuotaClientsClientCredentials'):
        """
        :param 'TenantDefaultTokenQuotaClientsClientCredentialsArgs' client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> 'outputs.TenantDefaultTokenQuotaClientsClientCredentials':
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class TenantDefaultTokenQuotaClientsClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perDay":
            suggest = "per_day"
        elif key == "perHour":
            suggest = "per_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantDefaultTokenQuotaClientsClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantDefaultTokenQuotaClientsClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantDefaultTokenQuotaClientsClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce: Optional[_builtins.bool] = None,
                 per_day: Optional[_builtins.int] = None,
                 per_hour: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if per_day is not None:
            pulumi.set(__self__, "per_day", per_day)
        if per_hour is not None:
            pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.bool]:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class TenantDefaultTokenQuotaOrganizations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantDefaultTokenQuotaOrganizations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantDefaultTokenQuotaOrganizations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantDefaultTokenQuotaOrganizations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials: 'outputs.TenantDefaultTokenQuotaOrganizationsClientCredentials'):
        """
        :param 'TenantDefaultTokenQuotaOrganizationsClientCredentialsArgs' client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> 'outputs.TenantDefaultTokenQuotaOrganizationsClientCredentials':
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class TenantDefaultTokenQuotaOrganizationsClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perDay":
            suggest = "per_day"
        elif key == "perHour":
            suggest = "per_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantDefaultTokenQuotaOrganizationsClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantDefaultTokenQuotaOrganizationsClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantDefaultTokenQuotaOrganizationsClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce: Optional[_builtins.bool] = None,
                 per_day: Optional[_builtins.int] = None,
                 per_hour: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if per_day is not None:
            pulumi.set(__self__, "per_day", per_day)
        if per_hour is not None:
            pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.bool]:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> Optional[_builtins.int]:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class TenantErrorPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "showLogLink":
            suggest = "show_log_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantErrorPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantErrorPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantErrorPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html: Optional[_builtins.str] = None,
                 show_log_link: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str html: Custom Error HTML (Liquid syntax is supported)
        :param _builtins.bool show_log_link: Whether to show the link to log as part of the default error page (true, default) or not to show the link (false).
        :param _builtins.str url: URL to redirect to when an error occurs instead of showing the default error page
        """
        if html is not None:
            pulumi.set(__self__, "html", html)
        if show_log_link is not None:
            pulumi.set(__self__, "show_log_link", show_log_link)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def html(self) -> Optional[_builtins.str]:
        """
        Custom Error HTML (Liquid syntax is supported)
        """
        return pulumi.get(self, "html")

    @_builtins.property
    @pulumi.getter(name="showLogLink")
    def show_log_link(self) -> Optional[_builtins.bool]:
        """
        Whether to show the link to log as part of the default error page (true, default) or not to show the link (false).
        """
        return pulumi.get(self, "show_log_link")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL to redirect to when an error occurs instead of showing the default error page
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class TenantFlags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowLegacyDelegationGrantTypes":
            suggest = "allow_legacy_delegation_grant_types"
        elif key == "allowLegacyRoGrantTypes":
            suggest = "allow_legacy_ro_grant_types"
        elif key == "allowLegacyTokeninfoEndpoint":
            suggest = "allow_legacy_tokeninfo_endpoint"
        elif key == "dashboardInsightsView":
            suggest = "dashboard_insights_view"
        elif key == "dashboardLogStreamsNext":
            suggest = "dashboard_log_streams_next"
        elif key == "disableClickjackProtectionHeaders":
            suggest = "disable_clickjack_protection_headers"
        elif key == "disableFieldsMapFix":
            suggest = "disable_fields_map_fix"
        elif key == "disableManagementApiSmsObfuscation":
            suggest = "disable_management_api_sms_obfuscation"
        elif key == "enableAdfsWaadEmailVerification":
            suggest = "enable_adfs_waad_email_verification"
        elif key == "enableApisSection":
            suggest = "enable_apis_section"
        elif key == "enableClientConnections":
            suggest = "enable_client_connections"
        elif key == "enableCustomDomainInEmails":
            suggest = "enable_custom_domain_in_emails"
        elif key == "enableDynamicClientRegistration":
            suggest = "enable_dynamic_client_registration"
        elif key == "enableIdtokenApi2":
            suggest = "enable_idtoken_api2"
        elif key == "enableLegacyLogsSearchV2":
            suggest = "enable_legacy_logs_search_v2"
        elif key == "enableLegacyProfile":
            suggest = "enable_legacy_profile"
        elif key == "enablePipeline2":
            suggest = "enable_pipeline2"
        elif key == "enablePublicSignupUserExistsError":
            suggest = "enable_public_signup_user_exists_error"
        elif key == "enableSso":
            suggest = "enable_sso"
        elif key == "mfaShowFactorListOnEnrollment":
            suggest = "mfa_show_factor_list_on_enrollment"
        elif key == "noDiscloseEnterpriseConnections":
            suggest = "no_disclose_enterprise_connections"
        elif key == "removeAlgFromJwks":
            suggest = "remove_alg_from_jwks"
        elif key == "requirePushedAuthorizationRequests":
            suggest = "require_pushed_authorization_requests"
        elif key == "revokeRefreshTokenGrant":
            suggest = "revoke_refresh_token_grant"
        elif key == "useScopeDescriptionsForConsent":
            suggest = "use_scope_descriptions_for_consent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantFlags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantFlags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantFlags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_legacy_delegation_grant_types: Optional[_builtins.bool] = None,
                 allow_legacy_ro_grant_types: Optional[_builtins.bool] = None,
                 allow_legacy_tokeninfo_endpoint: Optional[_builtins.bool] = None,
                 dashboard_insights_view: Optional[_builtins.bool] = None,
                 dashboard_log_streams_next: Optional[_builtins.bool] = None,
                 disable_clickjack_protection_headers: Optional[_builtins.bool] = None,
                 disable_fields_map_fix: Optional[_builtins.bool] = None,
                 disable_management_api_sms_obfuscation: Optional[_builtins.bool] = None,
                 enable_adfs_waad_email_verification: Optional[_builtins.bool] = None,
                 enable_apis_section: Optional[_builtins.bool] = None,
                 enable_client_connections: Optional[_builtins.bool] = None,
                 enable_custom_domain_in_emails: Optional[_builtins.bool] = None,
                 enable_dynamic_client_registration: Optional[_builtins.bool] = None,
                 enable_idtoken_api2: Optional[_builtins.bool] = None,
                 enable_legacy_logs_search_v2: Optional[_builtins.bool] = None,
                 enable_legacy_profile: Optional[_builtins.bool] = None,
                 enable_pipeline2: Optional[_builtins.bool] = None,
                 enable_public_signup_user_exists_error: Optional[_builtins.bool] = None,
                 enable_sso: Optional[_builtins.bool] = None,
                 mfa_show_factor_list_on_enrollment: Optional[_builtins.bool] = None,
                 no_disclose_enterprise_connections: Optional[_builtins.bool] = None,
                 remove_alg_from_jwks: Optional[_builtins.bool] = None,
                 require_pushed_authorization_requests: Optional[_builtins.bool] = None,
                 revoke_refresh_token_grant: Optional[_builtins.bool] = None,
                 use_scope_descriptions_for_consent: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_legacy_delegation_grant_types: Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        :param _builtins.bool allow_legacy_ro_grant_types: Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        :param _builtins.bool allow_legacy_tokeninfo_endpoint: If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        :param _builtins.bool dashboard_insights_view: Enables new insights activity page view.
        :param _builtins.bool dashboard_log_streams_next: Enables beta access to log streaming changes.
        :param _builtins.bool disable_clickjack_protection_headers: Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        :param _builtins.bool disable_fields_map_fix: Disables SAML fields map fix for bad mappings with repeated attributes.
        :param _builtins.bool disable_management_api_sms_obfuscation: If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        :param _builtins.bool enable_adfs_waad_email_verification: If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        :param _builtins.bool enable_apis_section: Indicates whether the APIs section is enabled for the tenant.
        :param _builtins.bool enable_client_connections: Indicates whether all current connections should be enabled when a new client is created.
        :param _builtins.bool enable_custom_domain_in_emails: Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        :param _builtins.bool enable_dynamic_client_registration: Indicates whether the tenant allows dynamic client registration.
        :param _builtins.bool enable_idtoken_api2: Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        :param _builtins.bool enable_legacy_logs_search_v2: Indicates whether to use the older v2 legacy logs search.
        :param _builtins.bool enable_legacy_profile: Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        :param _builtins.bool enable_pipeline2: Indicates whether advanced API Authorization scenarios are enabled.
        :param _builtins.bool enable_public_signup_user_exists_error: Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        :param _builtins.bool enable_sso: Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        :param _builtins.bool mfa_show_factor_list_on_enrollment: Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        :param _builtins.bool no_disclose_enterprise_connections: Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        :param _builtins.bool remove_alg_from_jwks: Remove `alg` from jwks(JSON Web Key Sets).
        :param _builtins.bool require_pushed_authorization_requests: This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        :param _builtins.bool revoke_refresh_token_grant: Delete underlying grant when a refresh token is revoked via the Authentication API.
        :param _builtins.bool use_scope_descriptions_for_consent: Indicates whether to use scope descriptions for consent.
        """
        if allow_legacy_delegation_grant_types is not None:
            pulumi.set(__self__, "allow_legacy_delegation_grant_types", allow_legacy_delegation_grant_types)
        if allow_legacy_ro_grant_types is not None:
            pulumi.set(__self__, "allow_legacy_ro_grant_types", allow_legacy_ro_grant_types)
        if allow_legacy_tokeninfo_endpoint is not None:
            pulumi.set(__self__, "allow_legacy_tokeninfo_endpoint", allow_legacy_tokeninfo_endpoint)
        if dashboard_insights_view is not None:
            pulumi.set(__self__, "dashboard_insights_view", dashboard_insights_view)
        if dashboard_log_streams_next is not None:
            pulumi.set(__self__, "dashboard_log_streams_next", dashboard_log_streams_next)
        if disable_clickjack_protection_headers is not None:
            pulumi.set(__self__, "disable_clickjack_protection_headers", disable_clickjack_protection_headers)
        if disable_fields_map_fix is not None:
            pulumi.set(__self__, "disable_fields_map_fix", disable_fields_map_fix)
        if disable_management_api_sms_obfuscation is not None:
            pulumi.set(__self__, "disable_management_api_sms_obfuscation", disable_management_api_sms_obfuscation)
        if enable_adfs_waad_email_verification is not None:
            pulumi.set(__self__, "enable_adfs_waad_email_verification", enable_adfs_waad_email_verification)
        if enable_apis_section is not None:
            pulumi.set(__self__, "enable_apis_section", enable_apis_section)
        if enable_client_connections is not None:
            pulumi.set(__self__, "enable_client_connections", enable_client_connections)
        if enable_custom_domain_in_emails is not None:
            pulumi.set(__self__, "enable_custom_domain_in_emails", enable_custom_domain_in_emails)
        if enable_dynamic_client_registration is not None:
            pulumi.set(__self__, "enable_dynamic_client_registration", enable_dynamic_client_registration)
        if enable_idtoken_api2 is not None:
            pulumi.set(__self__, "enable_idtoken_api2", enable_idtoken_api2)
        if enable_legacy_logs_search_v2 is not None:
            pulumi.set(__self__, "enable_legacy_logs_search_v2", enable_legacy_logs_search_v2)
        if enable_legacy_profile is not None:
            pulumi.set(__self__, "enable_legacy_profile", enable_legacy_profile)
        if enable_pipeline2 is not None:
            pulumi.set(__self__, "enable_pipeline2", enable_pipeline2)
        if enable_public_signup_user_exists_error is not None:
            pulumi.set(__self__, "enable_public_signup_user_exists_error", enable_public_signup_user_exists_error)
        if enable_sso is not None:
            pulumi.set(__self__, "enable_sso", enable_sso)
        if mfa_show_factor_list_on_enrollment is not None:
            pulumi.set(__self__, "mfa_show_factor_list_on_enrollment", mfa_show_factor_list_on_enrollment)
        if no_disclose_enterprise_connections is not None:
            pulumi.set(__self__, "no_disclose_enterprise_connections", no_disclose_enterprise_connections)
        if remove_alg_from_jwks is not None:
            pulumi.set(__self__, "remove_alg_from_jwks", remove_alg_from_jwks)
        if require_pushed_authorization_requests is not None:
            pulumi.set(__self__, "require_pushed_authorization_requests", require_pushed_authorization_requests)
        if revoke_refresh_token_grant is not None:
            pulumi.set(__self__, "revoke_refresh_token_grant", revoke_refresh_token_grant)
        if use_scope_descriptions_for_consent is not None:
            pulumi.set(__self__, "use_scope_descriptions_for_consent", use_scope_descriptions_for_consent)

    @_builtins.property
    @pulumi.getter(name="allowLegacyDelegationGrantTypes")
    def allow_legacy_delegation_grant_types(self) -> Optional[_builtins.bool]:
        """
        Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_delegation_grant_types")

    @_builtins.property
    @pulumi.getter(name="allowLegacyRoGrantTypes")
    def allow_legacy_ro_grant_types(self) -> Optional[_builtins.bool]:
        """
        Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_ro_grant_types")

    @_builtins.property
    @pulumi.getter(name="allowLegacyTokeninfoEndpoint")
    def allow_legacy_tokeninfo_endpoint(self) -> Optional[_builtins.bool]:
        """
        If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        """
        return pulumi.get(self, "allow_legacy_tokeninfo_endpoint")

    @_builtins.property
    @pulumi.getter(name="dashboardInsightsView")
    def dashboard_insights_view(self) -> Optional[_builtins.bool]:
        """
        Enables new insights activity page view.
        """
        return pulumi.get(self, "dashboard_insights_view")

    @_builtins.property
    @pulumi.getter(name="dashboardLogStreamsNext")
    def dashboard_log_streams_next(self) -> Optional[_builtins.bool]:
        """
        Enables beta access to log streaming changes.
        """
        return pulumi.get(self, "dashboard_log_streams_next")

    @_builtins.property
    @pulumi.getter(name="disableClickjackProtectionHeaders")
    def disable_clickjack_protection_headers(self) -> Optional[_builtins.bool]:
        """
        Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        """
        return pulumi.get(self, "disable_clickjack_protection_headers")

    @_builtins.property
    @pulumi.getter(name="disableFieldsMapFix")
    def disable_fields_map_fix(self) -> Optional[_builtins.bool]:
        """
        Disables SAML fields map fix for bad mappings with repeated attributes.
        """
        return pulumi.get(self, "disable_fields_map_fix")

    @_builtins.property
    @pulumi.getter(name="disableManagementApiSmsObfuscation")
    def disable_management_api_sms_obfuscation(self) -> Optional[_builtins.bool]:
        """
        If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        """
        return pulumi.get(self, "disable_management_api_sms_obfuscation")

    @_builtins.property
    @pulumi.getter(name="enableAdfsWaadEmailVerification")
    def enable_adfs_waad_email_verification(self) -> Optional[_builtins.bool]:
        """
        If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        """
        return pulumi.get(self, "enable_adfs_waad_email_verification")

    @_builtins.property
    @pulumi.getter(name="enableApisSection")
    def enable_apis_section(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the APIs section is enabled for the tenant.
        """
        return pulumi.get(self, "enable_apis_section")

    @_builtins.property
    @pulumi.getter(name="enableClientConnections")
    def enable_client_connections(self) -> Optional[_builtins.bool]:
        """
        Indicates whether all current connections should be enabled when a new client is created.
        """
        return pulumi.get(self, "enable_client_connections")

    @_builtins.property
    @pulumi.getter(name="enableCustomDomainInEmails")
    def enable_custom_domain_in_emails(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        """
        return pulumi.get(self, "enable_custom_domain_in_emails")

    @_builtins.property
    @pulumi.getter(name="enableDynamicClientRegistration")
    def enable_dynamic_client_registration(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the tenant allows dynamic client registration.
        """
        return pulumi.get(self, "enable_dynamic_client_registration")

    @_builtins.property
    @pulumi.getter(name="enableIdtokenApi2")
    def enable_idtoken_api2(self) -> Optional[_builtins.bool]:
        """
        Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        """
        return pulumi.get(self, "enable_idtoken_api2")

    @_builtins.property
    @pulumi.getter(name="enableLegacyLogsSearchV2")
    def enable_legacy_logs_search_v2(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use the older v2 legacy logs search.
        """
        return pulumi.get(self, "enable_legacy_logs_search_v2")

    @_builtins.property
    @pulumi.getter(name="enableLegacyProfile")
    def enable_legacy_profile(self) -> Optional[_builtins.bool]:
        """
        Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        """
        return pulumi.get(self, "enable_legacy_profile")

    @_builtins.property
    @pulumi.getter(name="enablePipeline2")
    def enable_pipeline2(self) -> Optional[_builtins.bool]:
        """
        Indicates whether advanced API Authorization scenarios are enabled.
        """
        return pulumi.get(self, "enable_pipeline2")

    @_builtins.property
    @pulumi.getter(name="enablePublicSignupUserExistsError")
    def enable_public_signup_user_exists_error(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        """
        return pulumi.get(self, "enable_public_signup_user_exists_error")

    @_builtins.property
    @pulumi.getter(name="enableSso")
    def enable_sso(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        """
        return pulumi.get(self, "enable_sso")

    @_builtins.property
    @pulumi.getter(name="mfaShowFactorListOnEnrollment")
    def mfa_show_factor_list_on_enrollment(self) -> Optional[_builtins.bool]:
        """
        Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        """
        return pulumi.get(self, "mfa_show_factor_list_on_enrollment")

    @_builtins.property
    @pulumi.getter(name="noDiscloseEnterpriseConnections")
    def no_disclose_enterprise_connections(self) -> Optional[_builtins.bool]:
        """
        Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        """
        return pulumi.get(self, "no_disclose_enterprise_connections")

    @_builtins.property
    @pulumi.getter(name="removeAlgFromJwks")
    def remove_alg_from_jwks(self) -> Optional[_builtins.bool]:
        """
        Remove `alg` from jwks(JSON Web Key Sets).
        """
        return pulumi.get(self, "remove_alg_from_jwks")

    @_builtins.property
    @pulumi.getter(name="requirePushedAuthorizationRequests")
    @_utilities.deprecated("""This Flag is not supported by the Auth0 Management API and will be removed in the next major release.""")
    def require_pushed_authorization_requests(self) -> Optional[_builtins.bool]:
        """
        This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        """
        return pulumi.get(self, "require_pushed_authorization_requests")

    @_builtins.property
    @pulumi.getter(name="revokeRefreshTokenGrant")
    def revoke_refresh_token_grant(self) -> Optional[_builtins.bool]:
        """
        Delete underlying grant when a refresh token is revoked via the Authentication API.
        """
        return pulumi.get(self, "revoke_refresh_token_grant")

    @_builtins.property
    @pulumi.getter(name="useScopeDescriptionsForConsent")
    def use_scope_descriptions_for_consent(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use scope descriptions for consent.
        """
        return pulumi.get(self, "use_scope_descriptions_for_consent")


@pulumi.output_type
class TenantMtls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEndpointAliases":
            suggest = "enable_endpoint_aliases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantMtls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantMtls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantMtls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 enable_endpoint_aliases: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable: Disable mTLS settings.
        :param _builtins.bool enable_endpoint_aliases: Enable mTLS endpoint aliases.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if enable_endpoint_aliases is not None:
            pulumi.set(__self__, "enable_endpoint_aliases", enable_endpoint_aliases)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        Disable mTLS settings.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="enableEndpointAliases")
    def enable_endpoint_aliases(self) -> Optional[_builtins.bool]:
        """
        Enable mTLS endpoint aliases.
        """
        return pulumi.get(self, "enable_endpoint_aliases")


@pulumi.output_type
class TenantOidcLogout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rpLogoutEndSessionEndpointDiscovery":
            suggest = "rp_logout_end_session_endpoint_discovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantOidcLogout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantOidcLogout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantOidcLogout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rp_logout_end_session_endpoint_discovery: _builtins.bool):
        """
        :param _builtins.bool rp_logout_end_session_endpoint_discovery: Enable the end*session*endpoint URL in the .well-known discovery configuration.
        """
        pulumi.set(__self__, "rp_logout_end_session_endpoint_discovery", rp_logout_end_session_endpoint_discovery)

    @_builtins.property
    @pulumi.getter(name="rpLogoutEndSessionEndpointDiscovery")
    def rp_logout_end_session_endpoint_discovery(self) -> _builtins.bool:
        """
        Enable the end*session*endpoint URL in the .well-known discovery configuration.
        """
        return pulumi.get(self, "rp_logout_end_session_endpoint_discovery")


@pulumi.output_type
class TenantSessionCookie(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TenantSessions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oidcLogoutPromptEnabled":
            suggest = "oidc_logout_prompt_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantSessions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantSessions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantSessions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oidc_logout_prompt_enabled: _builtins.bool):
        """
        :param _builtins.bool oidc_logout_prompt_enabled: When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        pulumi.set(__self__, "oidc_logout_prompt_enabled", oidc_logout_prompt_enabled)

    @_builtins.property
    @pulumi.getter(name="oidcLogoutPromptEnabled")
    def oidc_logout_prompt_enabled(self) -> _builtins.bool:
        """
        When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        return pulumi.get(self, "oidc_logout_prompt_enabled")


@pulumi.output_type
class TriggerActionsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerActionsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerActionsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerActionsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str display_name: The display name of the action within the flow.
        :param _builtins.str id: Action ID.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the action within the flow.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Action ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class UserPermissionsPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceServerIdentifier":
            suggest = "resource_server_identifier"
        elif key == "resourceServerName":
            suggest = "resource_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPermissionsPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPermissionsPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPermissionsPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_server_identifier: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 resource_server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of permission.
        :param _builtins.str resource_server_identifier: Resource server identifier associated with the permission.
        :param _builtins.str description: Description of the permission.
        :param _builtins.str resource_server_name: Name of resource server that the permission is associated with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_server_name is not None:
            pulumi.set(__self__, "resource_server_name", resource_server_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> _builtins.str:
        """
        Resource server identifier associated with the permission.
        """
        return pulumi.get(self, "resource_server_identifier")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> Optional[_builtins.str]:
        """
        Name of resource server that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")


@pulumi.output_type
class GetActionDependencyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: Dependency name, e.g. `lodash`.
        :param _builtins.str version: Dependency version, e.g. `latest` or `4.17.21`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Dependency name, e.g. `lodash`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Dependency version, e.g. `latest` or `4.17.21`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetActionSecretResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Secret name.
        :param _builtins.str value: Secret value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Secret name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Secret value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetActionSupportedTriggerResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: The trigger ID.
        :param _builtins.str version: The trigger version. This regulates which `runtime` versions are supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The trigger ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The trigger version. This regulates which `runtime` versions are supported.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAttackProtectionBreachedPasswordDetectionResult(dict):
    def __init__(__self__, *,
                 admin_notification_frequencies: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 method: _builtins.str,
                 pre_change_passwords: Sequence['outputs.GetAttackProtectionBreachedPasswordDetectionPreChangePasswordResult'],
                 pre_user_registrations: Sequence['outputs.GetAttackProtectionBreachedPasswordDetectionPreUserRegistrationResult'],
                 shields: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] admin_notification_frequencies: When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        :param _builtins.bool enabled: Whether breached password detection is active.
        :param _builtins.str method: The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        :param Sequence['GetAttackProtectionBreachedPasswordDetectionPreChangePasswordArgs'] pre_change_passwords: Configuration options that apply before every password change attempt.
        :param Sequence['GetAttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs'] pre_user_registrations: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        pulumi.set(__self__, "admin_notification_frequencies", admin_notification_frequencies)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "pre_change_passwords", pre_change_passwords)
        pulumi.set(__self__, "pre_user_registrations", pre_user_registrations)
        pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter(name="adminNotificationFrequencies")
    def admin_notification_frequencies(self) -> Sequence[_builtins.str]:
        """
        When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        """
        return pulumi.get(self, "admin_notification_frequencies")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether breached password detection is active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="preChangePasswords")
    def pre_change_passwords(self) -> Sequence['outputs.GetAttackProtectionBreachedPasswordDetectionPreChangePasswordResult']:
        """
        Configuration options that apply before every password change attempt.
        """
        return pulumi.get(self, "pre_change_passwords")

    @_builtins.property
    @pulumi.getter(name="preUserRegistrations")
    def pre_user_registrations(self) -> Sequence['outputs.GetAttackProtectionBreachedPasswordDetectionPreUserRegistrationResult']:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registrations")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Sequence[_builtins.str]:
        """
        Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class GetAttackProtectionBreachedPasswordDetectionPreChangePasswordResult(dict):
    def __init__(__self__, *,
                 shields: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected before the password is changed. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Sequence[_builtins.str]:
        """
        Action to take when a breached password is detected before the password is changed. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class GetAttackProtectionBreachedPasswordDetectionPreUserRegistrationResult(dict):
    def __init__(__self__, *,
                 shields: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] shields: Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Sequence[_builtins.str]:
        """
        Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class GetAttackProtectionBruteForceProtectionResult(dict):
    def __init__(__self__, *,
                 allowlists: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 max_attempts: _builtins.int,
                 mode: _builtins.str,
                 shields: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param _builtins.bool enabled: Whether brute force attack protections are active.
        :param _builtins.int max_attempts: Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        :param _builtins.str mode: Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        :param Sequence[_builtins.str] shields: Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        pulumi.set(__self__, "allowlists", allowlists)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def allowlists(self) -> Sequence[_builtins.str]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether brute force attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> _builtins.int:
        """
        Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Sequence[_builtins.str]:
        """
        Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class GetAttackProtectionSuspiciousIpThrottlingResult(dict):
    def __init__(__self__, *,
                 allowlists: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 pre_logins: Sequence['outputs.GetAttackProtectionSuspiciousIpThrottlingPreLoginResult'],
                 pre_user_registrations: Sequence['outputs.GetAttackProtectionSuspiciousIpThrottlingPreUserRegistrationResult'],
                 shields: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param _builtins.bool enabled: Whether suspicious IP throttling attack protections are active.
        :param Sequence['GetAttackProtectionSuspiciousIpThrottlingPreLoginArgs'] pre_logins: Configuration options that apply before every login attempt. Only available on public tenants.
        :param Sequence['GetAttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs'] pre_user_registrations: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param Sequence[_builtins.str] shields: Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        pulumi.set(__self__, "allowlists", allowlists)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "pre_logins", pre_logins)
        pulumi.set(__self__, "pre_user_registrations", pre_user_registrations)
        pulumi.set(__self__, "shields", shields)

    @_builtins.property
    @pulumi.getter
    def allowlists(self) -> Sequence[_builtins.str]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether suspicious IP throttling attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="preLogins")
    def pre_logins(self) -> Sequence['outputs.GetAttackProtectionSuspiciousIpThrottlingPreLoginResult']:
        """
        Configuration options that apply before every login attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_logins")

    @_builtins.property
    @pulumi.getter(name="preUserRegistrations")
    def pre_user_registrations(self) -> Sequence['outputs.GetAttackProtectionSuspiciousIpThrottlingPreUserRegistrationResult']:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registrations")

    @_builtins.property
    @pulumi.getter
    def shields(self) -> Sequence[_builtins.str]:
        """
        Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        return pulumi.get(self, "shields")


@pulumi.output_type
class GetAttackProtectionSuspiciousIpThrottlingPreLoginResult(dict):
    def __init__(__self__, *,
                 max_attempts: _builtins.int,
                 rate: _builtins.int):
        """
        :param _builtins.int max_attempts: The maximum number of failed login attempts allowed from a single IP address.
        :param _builtins.int rate: Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "rate", rate)

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> _builtins.int:
        """
        The maximum number of failed login attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> _builtins.int:
        """
        Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")


@pulumi.output_type
class GetAttackProtectionSuspiciousIpThrottlingPreUserRegistrationResult(dict):
    def __init__(__self__, *,
                 max_attempts: _builtins.int,
                 rate: _builtins.int):
        """
        :param _builtins.int max_attempts: The maximum number of sign up attempts allowed from a single IP address.
        :param _builtins.int rate: Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "rate", rate)

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> _builtins.int:
        """
        The maximum number of sign up attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> _builtins.int:
        """
        Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")


@pulumi.output_type
class GetBrandingColorResult(dict):
    def __init__(__self__, *,
                 page_background: _builtins.str,
                 primary: _builtins.str):
        """
        :param _builtins.str page_background: Background color of login pages in hexadecimal.
        :param _builtins.str primary: Primary button background color in hexadecimal.
        """
        pulumi.set(__self__, "page_background", page_background)
        pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter(name="pageBackground")
    def page_background(self) -> _builtins.str:
        """
        Background color of login pages in hexadecimal.
        """
        return pulumi.get(self, "page_background")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.str:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class GetBrandingFontResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: URL for the custom font.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL for the custom font.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetBrandingThemeBorderResult(dict):
    def __init__(__self__, *,
                 button_border_radius: _builtins.float,
                 button_border_weight: _builtins.float,
                 buttons_style: _builtins.str,
                 input_border_radius: _builtins.float,
                 input_border_weight: _builtins.float,
                 inputs_style: _builtins.str,
                 show_widget_shadow: _builtins.bool,
                 widget_border_weight: _builtins.float,
                 widget_corner_radius: _builtins.float):
        """
        :param _builtins.float button_border_radius: Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        :param _builtins.float button_border_weight: Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        :param _builtins.str buttons_style: Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param _builtins.float input_border_radius: Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        :param _builtins.float input_border_weight: Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        :param _builtins.str inputs_style: Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param _builtins.bool show_widget_shadow: Show widget shadow. Defaults to `true`.
        :param _builtins.float widget_border_weight: Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        :param _builtins.float widget_corner_radius: Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        pulumi.set(__self__, "button_border_radius", button_border_radius)
        pulumi.set(__self__, "button_border_weight", button_border_weight)
        pulumi.set(__self__, "buttons_style", buttons_style)
        pulumi.set(__self__, "input_border_radius", input_border_radius)
        pulumi.set(__self__, "input_border_weight", input_border_weight)
        pulumi.set(__self__, "inputs_style", inputs_style)
        pulumi.set(__self__, "show_widget_shadow", show_widget_shadow)
        pulumi.set(__self__, "widget_border_weight", widget_border_weight)
        pulumi.set(__self__, "widget_corner_radius", widget_corner_radius)

    @_builtins.property
    @pulumi.getter(name="buttonBorderRadius")
    def button_border_radius(self) -> _builtins.float:
        """
        Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "button_border_radius")

    @_builtins.property
    @pulumi.getter(name="buttonBorderWeight")
    def button_border_weight(self) -> _builtins.float:
        """
        Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        """
        return pulumi.get(self, "button_border_weight")

    @_builtins.property
    @pulumi.getter(name="buttonsStyle")
    def buttons_style(self) -> _builtins.str:
        """
        Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "buttons_style")

    @_builtins.property
    @pulumi.getter(name="inputBorderRadius")
    def input_border_radius(self) -> _builtins.float:
        """
        Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "input_border_radius")

    @_builtins.property
    @pulumi.getter(name="inputBorderWeight")
    def input_border_weight(self) -> _builtins.float:
        """
        Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        """
        return pulumi.get(self, "input_border_weight")

    @_builtins.property
    @pulumi.getter(name="inputsStyle")
    def inputs_style(self) -> _builtins.str:
        """
        Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "inputs_style")

    @_builtins.property
    @pulumi.getter(name="showWidgetShadow")
    def show_widget_shadow(self) -> _builtins.bool:
        """
        Show widget shadow. Defaults to `true`.
        """
        return pulumi.get(self, "show_widget_shadow")

    @_builtins.property
    @pulumi.getter(name="widgetBorderWeight")
    def widget_border_weight(self) -> _builtins.float:
        """
        Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        """
        return pulumi.get(self, "widget_border_weight")

    @_builtins.property
    @pulumi.getter(name="widgetCornerRadius")
    def widget_corner_radius(self) -> _builtins.float:
        """
        Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        return pulumi.get(self, "widget_corner_radius")


@pulumi.output_type
class GetBrandingThemeColorResult(dict):
    def __init__(__self__, *,
                 base_focus_color: _builtins.str,
                 base_hover_color: _builtins.str,
                 body_text: _builtins.str,
                 captcha_widget_theme: _builtins.str,
                 error: _builtins.str,
                 header: _builtins.str,
                 icons: _builtins.str,
                 input_background: _builtins.str,
                 input_border: _builtins.str,
                 input_filled_text: _builtins.str,
                 input_labels_placeholders: _builtins.str,
                 links_focused_components: _builtins.str,
                 primary_button: _builtins.str,
                 primary_button_label: _builtins.str,
                 secondary_button_border: _builtins.str,
                 secondary_button_label: _builtins.str,
                 success: _builtins.str,
                 widget_background: _builtins.str,
                 widget_border: _builtins.str):
        """
        :param _builtins.str base_focus_color: Base focus color. Defaults to `#635dff`.
        :param _builtins.str base_hover_color: Base hover color. Defaults to `#000000`.
        :param _builtins.str body_text: Body text. Defaults to `#1e212a`.
        :param _builtins.str captcha_widget_theme: Captcha Widget Theme.
        :param _builtins.str error: Error. Defaults to `#d03c38`.
        :param _builtins.str header: Header. Defaults to `#1e212a`.
        :param _builtins.str icons: Icons. Defaults to `#65676e`.
        :param _builtins.str input_background: Input background. Defaults to `#ffffff`.
        :param _builtins.str input_border: Input border. Defaults to `#c9cace`.
        :param _builtins.str input_filled_text: Input filled text. Defaults to `#000000`.
        :param _builtins.str input_labels_placeholders: Input labels & placeholders. Defaults to `#65676e`.
        :param _builtins.str links_focused_components: Links & focused components. Defaults to `#635dff`.
        :param _builtins.str primary_button: Primary button. Defaults to `#635dff`.
        :param _builtins.str primary_button_label: Primary button label. Defaults to `#ffffff`.
        :param _builtins.str secondary_button_border: Secondary button border. Defaults to `#c9cace`.
        :param _builtins.str secondary_button_label: Secondary button label. Defaults to `#1e212a`.
        :param _builtins.str success: Success. Defaults to `#13a688`.
        :param _builtins.str widget_background: Widget background. Defaults to `#ffffff`.
        :param _builtins.str widget_border: Widget border. Defaults to `#c9cace`.
        """
        pulumi.set(__self__, "base_focus_color", base_focus_color)
        pulumi.set(__self__, "base_hover_color", base_hover_color)
        pulumi.set(__self__, "body_text", body_text)
        pulumi.set(__self__, "captcha_widget_theme", captcha_widget_theme)
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "icons", icons)
        pulumi.set(__self__, "input_background", input_background)
        pulumi.set(__self__, "input_border", input_border)
        pulumi.set(__self__, "input_filled_text", input_filled_text)
        pulumi.set(__self__, "input_labels_placeholders", input_labels_placeholders)
        pulumi.set(__self__, "links_focused_components", links_focused_components)
        pulumi.set(__self__, "primary_button", primary_button)
        pulumi.set(__self__, "primary_button_label", primary_button_label)
        pulumi.set(__self__, "secondary_button_border", secondary_button_border)
        pulumi.set(__self__, "secondary_button_label", secondary_button_label)
        pulumi.set(__self__, "success", success)
        pulumi.set(__self__, "widget_background", widget_background)
        pulumi.set(__self__, "widget_border", widget_border)

    @_builtins.property
    @pulumi.getter(name="baseFocusColor")
    def base_focus_color(self) -> _builtins.str:
        """
        Base focus color. Defaults to `#635dff`.
        """
        return pulumi.get(self, "base_focus_color")

    @_builtins.property
    @pulumi.getter(name="baseHoverColor")
    def base_hover_color(self) -> _builtins.str:
        """
        Base hover color. Defaults to `#000000`.
        """
        return pulumi.get(self, "base_hover_color")

    @_builtins.property
    @pulumi.getter(name="bodyText")
    def body_text(self) -> _builtins.str:
        """
        Body text. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "body_text")

    @_builtins.property
    @pulumi.getter(name="captchaWidgetTheme")
    def captcha_widget_theme(self) -> _builtins.str:
        """
        Captcha Widget Theme.
        """
        return pulumi.get(self, "captcha_widget_theme")

    @_builtins.property
    @pulumi.getter
    def error(self) -> _builtins.str:
        """
        Error. Defaults to `#d03c38`.
        """
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        """
        Header. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def icons(self) -> _builtins.str:
        """
        Icons. Defaults to `#65676e`.
        """
        return pulumi.get(self, "icons")

    @_builtins.property
    @pulumi.getter(name="inputBackground")
    def input_background(self) -> _builtins.str:
        """
        Input background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "input_background")

    @_builtins.property
    @pulumi.getter(name="inputBorder")
    def input_border(self) -> _builtins.str:
        """
        Input border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "input_border")

    @_builtins.property
    @pulumi.getter(name="inputFilledText")
    def input_filled_text(self) -> _builtins.str:
        """
        Input filled text. Defaults to `#000000`.
        """
        return pulumi.get(self, "input_filled_text")

    @_builtins.property
    @pulumi.getter(name="inputLabelsPlaceholders")
    def input_labels_placeholders(self) -> _builtins.str:
        """
        Input labels & placeholders. Defaults to `#65676e`.
        """
        return pulumi.get(self, "input_labels_placeholders")

    @_builtins.property
    @pulumi.getter(name="linksFocusedComponents")
    def links_focused_components(self) -> _builtins.str:
        """
        Links & focused components. Defaults to `#635dff`.
        """
        return pulumi.get(self, "links_focused_components")

    @_builtins.property
    @pulumi.getter(name="primaryButton")
    def primary_button(self) -> _builtins.str:
        """
        Primary button. Defaults to `#635dff`.
        """
        return pulumi.get(self, "primary_button")

    @_builtins.property
    @pulumi.getter(name="primaryButtonLabel")
    def primary_button_label(self) -> _builtins.str:
        """
        Primary button label. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "primary_button_label")

    @_builtins.property
    @pulumi.getter(name="secondaryButtonBorder")
    def secondary_button_border(self) -> _builtins.str:
        """
        Secondary button border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "secondary_button_border")

    @_builtins.property
    @pulumi.getter(name="secondaryButtonLabel")
    def secondary_button_label(self) -> _builtins.str:
        """
        Secondary button label. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "secondary_button_label")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.str:
        """
        Success. Defaults to `#13a688`.
        """
        return pulumi.get(self, "success")

    @_builtins.property
    @pulumi.getter(name="widgetBackground")
    def widget_background(self) -> _builtins.str:
        """
        Widget background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "widget_background")

    @_builtins.property
    @pulumi.getter(name="widgetBorder")
    def widget_border(self) -> _builtins.str:
        """
        Widget border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "widget_border")


@pulumi.output_type
class GetBrandingThemeFontResult(dict):
    def __init__(__self__, *,
                 body_texts: Sequence['outputs.GetBrandingThemeFontBodyTextResult'],
                 buttons_texts: Sequence['outputs.GetBrandingThemeFontButtonsTextResult'],
                 font_url: _builtins.str,
                 input_labels: Sequence['outputs.GetBrandingThemeFontInputLabelResult'],
                 links: Sequence['outputs.GetBrandingThemeFontLinkResult'],
                 links_style: _builtins.str,
                 reference_text_size: _builtins.float,
                 subtitles: Sequence['outputs.GetBrandingThemeFontSubtitleResult'],
                 titles: Sequence['outputs.GetBrandingThemeFontTitleResult']):
        """
        :param Sequence['GetBrandingThemeFontBodyTextArgs'] body_texts: Body text.
        :param Sequence['GetBrandingThemeFontButtonsTextArgs'] buttons_texts: Buttons text.
        :param _builtins.str font_url: Font URL. Defaults to an empty string.
        :param Sequence['GetBrandingThemeFontInputLabelArgs'] input_labels: Input labels.
        :param Sequence['GetBrandingThemeFontLinkArgs'] links: Links.
        :param _builtins.str links_style: Links style. Defaults to `normal`.
        :param _builtins.float reference_text_size: Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        :param Sequence['GetBrandingThemeFontSubtitleArgs'] subtitles: Subtitle.
        :param Sequence['GetBrandingThemeFontTitleArgs'] titles: Title.
        """
        pulumi.set(__self__, "body_texts", body_texts)
        pulumi.set(__self__, "buttons_texts", buttons_texts)
        pulumi.set(__self__, "font_url", font_url)
        pulumi.set(__self__, "input_labels", input_labels)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "links_style", links_style)
        pulumi.set(__self__, "reference_text_size", reference_text_size)
        pulumi.set(__self__, "subtitles", subtitles)
        pulumi.set(__self__, "titles", titles)

    @_builtins.property
    @pulumi.getter(name="bodyTexts")
    def body_texts(self) -> Sequence['outputs.GetBrandingThemeFontBodyTextResult']:
        """
        Body text.
        """
        return pulumi.get(self, "body_texts")

    @_builtins.property
    @pulumi.getter(name="buttonsTexts")
    def buttons_texts(self) -> Sequence['outputs.GetBrandingThemeFontButtonsTextResult']:
        """
        Buttons text.
        """
        return pulumi.get(self, "buttons_texts")

    @_builtins.property
    @pulumi.getter(name="fontUrl")
    def font_url(self) -> _builtins.str:
        """
        Font URL. Defaults to an empty string.
        """
        return pulumi.get(self, "font_url")

    @_builtins.property
    @pulumi.getter(name="inputLabels")
    def input_labels(self) -> Sequence['outputs.GetBrandingThemeFontInputLabelResult']:
        """
        Input labels.
        """
        return pulumi.get(self, "input_labels")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetBrandingThemeFontLinkResult']:
        """
        Links.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="linksStyle")
    def links_style(self) -> _builtins.str:
        """
        Links style. Defaults to `normal`.
        """
        return pulumi.get(self, "links_style")

    @_builtins.property
    @pulumi.getter(name="referenceTextSize")
    def reference_text_size(self) -> _builtins.float:
        """
        Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
        return pulumi.get(self, "reference_text_size")

    @_builtins.property
    @pulumi.getter
    def subtitles(self) -> Sequence['outputs.GetBrandingThemeFontSubtitleResult']:
        """
        Subtitle.
        """
        return pulumi.get(self, "subtitles")

    @_builtins.property
    @pulumi.getter
    def titles(self) -> Sequence['outputs.GetBrandingThemeFontTitleResult']:
        """
        Title.
        """
        return pulumi.get(self, "titles")


@pulumi.output_type
class GetBrandingThemeFontBodyTextResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Body text bold. Defaults to `false`.
        :param _builtins.float size: Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Body text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemeFontButtonsTextResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Buttons text bold. Defaults to `false`.
        :param _builtins.float size: Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Buttons text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemeFontInputLabelResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Input labels bold. Defaults to `false`.
        :param _builtins.float size: Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Input labels bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemeFontLinkResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Links bold. Defaults to `true`.
        :param _builtins.float size: Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Links bold. Defaults to `true`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemeFontSubtitleResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Subtitle bold. Defaults to `false`.
        :param _builtins.float size: Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Subtitle bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemeFontTitleResult(dict):
    def __init__(__self__, *,
                 bold: _builtins.bool,
                 size: _builtins.float):
        """
        :param _builtins.bool bold: Title bold. Defaults to `false`.
        :param _builtins.float size: Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        pulumi.set(__self__, "bold", bold)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def bold(self) -> _builtins.bool:
        """
        Title bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetBrandingThemePageBackgroundResult(dict):
    def __init__(__self__, *,
                 background_color: _builtins.str,
                 background_image_url: _builtins.str,
                 page_layout: _builtins.str):
        """
        :param _builtins.str background_color: Background color. Defaults to `#000000`.
        :param _builtins.str background_image_url: Background image url. Defaults to an empty string.
        :param _builtins.str page_layout: Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        pulumi.set(__self__, "background_color", background_color)
        pulumi.set(__self__, "background_image_url", background_image_url)
        pulumi.set(__self__, "page_layout", page_layout)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> _builtins.str:
        """
        Background color. Defaults to `#000000`.
        """
        return pulumi.get(self, "background_color")

    @_builtins.property
    @pulumi.getter(name="backgroundImageUrl")
    def background_image_url(self) -> _builtins.str:
        """
        Background image url. Defaults to an empty string.
        """
        return pulumi.get(self, "background_image_url")

    @_builtins.property
    @pulumi.getter(name="pageLayout")
    def page_layout(self) -> _builtins.str:
        """
        Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "page_layout")


@pulumi.output_type
class GetBrandingThemeWidgetResult(dict):
    def __init__(__self__, *,
                 header_text_alignment: _builtins.str,
                 logo_height: _builtins.float,
                 logo_position: _builtins.str,
                 logo_url: _builtins.str,
                 social_buttons_layout: _builtins.str):
        """
        :param _builtins.str header_text_alignment: Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        :param _builtins.float logo_height: Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        :param _builtins.str logo_position: Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        :param _builtins.str logo_url: Logo url. Defaults to an empty string.
        :param _builtins.str social_buttons_layout: Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        pulumi.set(__self__, "header_text_alignment", header_text_alignment)
        pulumi.set(__self__, "logo_height", logo_height)
        pulumi.set(__self__, "logo_position", logo_position)
        pulumi.set(__self__, "logo_url", logo_url)
        pulumi.set(__self__, "social_buttons_layout", social_buttons_layout)

    @_builtins.property
    @pulumi.getter(name="headerTextAlignment")
    def header_text_alignment(self) -> _builtins.str:
        """
        Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "header_text_alignment")

    @_builtins.property
    @pulumi.getter(name="logoHeight")
    def logo_height(self) -> _builtins.float:
        """
        Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        """
        return pulumi.get(self, "logo_height")

    @_builtins.property
    @pulumi.getter(name="logoPosition")
    def logo_position(self) -> _builtins.str:
        """
        Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        """
        return pulumi.get(self, "logo_position")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> _builtins.str:
        """
        Logo url. Defaults to an empty string.
        """
        return pulumi.get(self, "logo_url")

    @_builtins.property
    @pulumi.getter(name="socialButtonsLayout")
    def social_buttons_layout(self) -> _builtins.str:
        """
        Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        return pulumi.get(self, "social_buttons_layout")


@pulumi.output_type
class GetBrandingUniversalLoginResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str):
        """
        :param _builtins.str body: The html template for the New Universal Login Experience.
        """
        pulumi.set(__self__, "body", body)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The html template for the New Universal Login Experience.
        """
        return pulumi.get(self, "body")


@pulumi.output_type
class GetClientAddonResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetClientAddonAwResult'],
                 azure_blobs: Sequence['outputs.GetClientAddonAzureBlobResult'],
                 azure_sbs: Sequence['outputs.GetClientAddonAzureSbResult'],
                 boxes: Sequence['outputs.GetClientAddonBoxResult'],
                 cloudbees: Sequence['outputs.GetClientAddonCloudbeeResult'],
                 concurs: Sequence['outputs.GetClientAddonConcurResult'],
                 dropboxes: Sequence['outputs.GetClientAddonDropboxResult'],
                 echosigns: Sequence['outputs.GetClientAddonEchosignResult'],
                 egnytes: Sequence['outputs.GetClientAddonEgnyteResult'],
                 firebases: Sequence['outputs.GetClientAddonFirebaseResult'],
                 layers: Sequence['outputs.GetClientAddonLayerResult'],
                 mscrms: Sequence['outputs.GetClientAddonMscrmResult'],
                 newrelics: Sequence['outputs.GetClientAddonNewrelicResult'],
                 office365s: Sequence['outputs.GetClientAddonOffice365Result'],
                 rms: Sequence['outputs.GetClientAddonRmResult'],
                 salesforce_apis: Sequence['outputs.GetClientAddonSalesforceApiResult'],
                 salesforce_sandbox_apis: Sequence['outputs.GetClientAddonSalesforceSandboxApiResult'],
                 salesforces: Sequence['outputs.GetClientAddonSalesforceResult'],
                 samlps: Sequence['outputs.GetClientAddonSamlpResult'],
                 sap_apis: Sequence['outputs.GetClientAddonSapApiResult'],
                 sentries: Sequence['outputs.GetClientAddonSentryResult'],
                 sharepoints: Sequence['outputs.GetClientAddonSharepointResult'],
                 slacks: Sequence['outputs.GetClientAddonSlackResult'],
                 springcms: Sequence['outputs.GetClientAddonSpringcmResult'],
                 sso_integrations: Sequence['outputs.GetClientAddonSsoIntegrationResult'],
                 wams: Sequence['outputs.GetClientAddonWamResult'],
                 wsfeds: Sequence['outputs.GetClientAddonWsfedResult'],
                 zendesks: Sequence['outputs.GetClientAddonZendeskResult'],
                 zooms: Sequence['outputs.GetClientAddonZoomResult']):
        """
        :param Sequence['GetClientAddonAwArgs'] aws: AWS Addon configuration.
        :param Sequence['GetClientAddonAzureBlobArgs'] azure_blobs: Azure Blob Storage Addon configuration.
        :param Sequence['GetClientAddonAzureSbArgs'] azure_sbs: Azure Storage Bus Addon configuration.
        :param Sequence['GetClientAddonBoxArgs'] boxes: Box SSO indicator (no configuration settings needed for Box SSO).
        :param Sequence['GetClientAddonCloudbeeArgs'] cloudbees: CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        :param Sequence['GetClientAddonConcurArgs'] concurs: Concur SSO indicator (no configuration settings needed for Concur SSO).
        :param Sequence['GetClientAddonDropboxArgs'] dropboxes: Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        :param Sequence['GetClientAddonEchosignArgs'] echosigns: Adobe EchoSign SSO configuration.
        :param Sequence['GetClientAddonEgnyteArgs'] egnytes: Egnyte SSO configuration.
        :param Sequence['GetClientAddonFirebaseArgs'] firebases: Google Firebase addon configuration.
        :param Sequence['GetClientAddonLayerArgs'] layers: Layer addon configuration.
        :param Sequence['GetClientAddonMscrmArgs'] mscrms: Microsoft Dynamics CRM SSO configuration.
        :param Sequence['GetClientAddonNewrelicArgs'] newrelics: New Relic SSO configuration.
        :param Sequence['GetClientAddonOffice365Args'] office365s: Microsoft Office 365 SSO configuration.
        :param Sequence['GetClientAddonRmArgs'] rms: Active Directory Rights Management Service SSO configuration.
        :param Sequence['GetClientAddonSalesforceApiArgs'] salesforce_apis: Salesforce API addon configuration.
        :param Sequence['GetClientAddonSalesforceSandboxApiArgs'] salesforce_sandbox_apis: Salesforce Sandbox addon configuration.
        :param Sequence['GetClientAddonSalesforceArgs'] salesforces: Salesforce SSO configuration.
        :param Sequence['GetClientAddonSamlpArgs'] samlps: Configuration settings for a SAML add-on.
        :param Sequence['GetClientAddonSapApiArgs'] sap_apis: SAP API addon configuration.
        :param Sequence['GetClientAddonSentryArgs'] sentries: Sentry SSO configuration.
        :param Sequence['GetClientAddonSharepointArgs'] sharepoints: SharePoint SSO configuration.
        :param Sequence['GetClientAddonSlackArgs'] slacks: Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        :param Sequence['GetClientAddonSpringcmArgs'] springcms: SpringCM SSO configuration.
        :param Sequence['GetClientAddonSsoIntegrationArgs'] sso_integrations: Generic SSO configuration.
        :param Sequence['GetClientAddonWamArgs'] wams: Windows Azure Mobile Services addon configuration.
        :param Sequence['GetClientAddonWsfedArgs'] wsfeds: WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        :param Sequence['GetClientAddonZendeskArgs'] zendesks: Zendesk SSO configuration.
        :param Sequence['GetClientAddonZoomArgs'] zooms: Zoom SSO configuration.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azure_blobs", azure_blobs)
        pulumi.set(__self__, "azure_sbs", azure_sbs)
        pulumi.set(__self__, "boxes", boxes)
        pulumi.set(__self__, "cloudbees", cloudbees)
        pulumi.set(__self__, "concurs", concurs)
        pulumi.set(__self__, "dropboxes", dropboxes)
        pulumi.set(__self__, "echosigns", echosigns)
        pulumi.set(__self__, "egnytes", egnytes)
        pulumi.set(__self__, "firebases", firebases)
        pulumi.set(__self__, "layers", layers)
        pulumi.set(__self__, "mscrms", mscrms)
        pulumi.set(__self__, "newrelics", newrelics)
        pulumi.set(__self__, "office365s", office365s)
        pulumi.set(__self__, "rms", rms)
        pulumi.set(__self__, "salesforce_apis", salesforce_apis)
        pulumi.set(__self__, "salesforce_sandbox_apis", salesforce_sandbox_apis)
        pulumi.set(__self__, "salesforces", salesforces)
        pulumi.set(__self__, "samlps", samlps)
        pulumi.set(__self__, "sap_apis", sap_apis)
        pulumi.set(__self__, "sentries", sentries)
        pulumi.set(__self__, "sharepoints", sharepoints)
        pulumi.set(__self__, "slacks", slacks)
        pulumi.set(__self__, "springcms", springcms)
        pulumi.set(__self__, "sso_integrations", sso_integrations)
        pulumi.set(__self__, "wams", wams)
        pulumi.set(__self__, "wsfeds", wsfeds)
        pulumi.set(__self__, "zendesks", zendesks)
        pulumi.set(__self__, "zooms", zooms)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetClientAddonAwResult']:
        """
        AWS Addon configuration.
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter(name="azureBlobs")
    def azure_blobs(self) -> Sequence['outputs.GetClientAddonAzureBlobResult']:
        """
        Azure Blob Storage Addon configuration.
        """
        return pulumi.get(self, "azure_blobs")

    @_builtins.property
    @pulumi.getter(name="azureSbs")
    def azure_sbs(self) -> Sequence['outputs.GetClientAddonAzureSbResult']:
        """
        Azure Storage Bus Addon configuration.
        """
        return pulumi.get(self, "azure_sbs")

    @_builtins.property
    @pulumi.getter
    def boxes(self) -> Sequence['outputs.GetClientAddonBoxResult']:
        """
        Box SSO indicator (no configuration settings needed for Box SSO).
        """
        return pulumi.get(self, "boxes")

    @_builtins.property
    @pulumi.getter
    def cloudbees(self) -> Sequence['outputs.GetClientAddonCloudbeeResult']:
        """
        CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        """
        return pulumi.get(self, "cloudbees")

    @_builtins.property
    @pulumi.getter
    def concurs(self) -> Sequence['outputs.GetClientAddonConcurResult']:
        """
        Concur SSO indicator (no configuration settings needed for Concur SSO).
        """
        return pulumi.get(self, "concurs")

    @_builtins.property
    @pulumi.getter
    def dropboxes(self) -> Sequence['outputs.GetClientAddonDropboxResult']:
        """
        Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        """
        return pulumi.get(self, "dropboxes")

    @_builtins.property
    @pulumi.getter
    def echosigns(self) -> Sequence['outputs.GetClientAddonEchosignResult']:
        """
        Adobe EchoSign SSO configuration.
        """
        return pulumi.get(self, "echosigns")

    @_builtins.property
    @pulumi.getter
    def egnytes(self) -> Sequence['outputs.GetClientAddonEgnyteResult']:
        """
        Egnyte SSO configuration.
        """
        return pulumi.get(self, "egnytes")

    @_builtins.property
    @pulumi.getter
    def firebases(self) -> Sequence['outputs.GetClientAddonFirebaseResult']:
        """
        Google Firebase addon configuration.
        """
        return pulumi.get(self, "firebases")

    @_builtins.property
    @pulumi.getter
    def layers(self) -> Sequence['outputs.GetClientAddonLayerResult']:
        """
        Layer addon configuration.
        """
        return pulumi.get(self, "layers")

    @_builtins.property
    @pulumi.getter
    def mscrms(self) -> Sequence['outputs.GetClientAddonMscrmResult']:
        """
        Microsoft Dynamics CRM SSO configuration.
        """
        return pulumi.get(self, "mscrms")

    @_builtins.property
    @pulumi.getter
    def newrelics(self) -> Sequence['outputs.GetClientAddonNewrelicResult']:
        """
        New Relic SSO configuration.
        """
        return pulumi.get(self, "newrelics")

    @_builtins.property
    @pulumi.getter
    def office365s(self) -> Sequence['outputs.GetClientAddonOffice365Result']:
        """
        Microsoft Office 365 SSO configuration.
        """
        return pulumi.get(self, "office365s")

    @_builtins.property
    @pulumi.getter
    def rms(self) -> Sequence['outputs.GetClientAddonRmResult']:
        """
        Active Directory Rights Management Service SSO configuration.
        """
        return pulumi.get(self, "rms")

    @_builtins.property
    @pulumi.getter(name="salesforceApis")
    def salesforce_apis(self) -> Sequence['outputs.GetClientAddonSalesforceApiResult']:
        """
        Salesforce API addon configuration.
        """
        return pulumi.get(self, "salesforce_apis")

    @_builtins.property
    @pulumi.getter(name="salesforceSandboxApis")
    def salesforce_sandbox_apis(self) -> Sequence['outputs.GetClientAddonSalesforceSandboxApiResult']:
        """
        Salesforce Sandbox addon configuration.
        """
        return pulumi.get(self, "salesforce_sandbox_apis")

    @_builtins.property
    @pulumi.getter
    def salesforces(self) -> Sequence['outputs.GetClientAddonSalesforceResult']:
        """
        Salesforce SSO configuration.
        """
        return pulumi.get(self, "salesforces")

    @_builtins.property
    @pulumi.getter
    def samlps(self) -> Sequence['outputs.GetClientAddonSamlpResult']:
        """
        Configuration settings for a SAML add-on.
        """
        return pulumi.get(self, "samlps")

    @_builtins.property
    @pulumi.getter(name="sapApis")
    def sap_apis(self) -> Sequence['outputs.GetClientAddonSapApiResult']:
        """
        SAP API addon configuration.
        """
        return pulumi.get(self, "sap_apis")

    @_builtins.property
    @pulumi.getter
    def sentries(self) -> Sequence['outputs.GetClientAddonSentryResult']:
        """
        Sentry SSO configuration.
        """
        return pulumi.get(self, "sentries")

    @_builtins.property
    @pulumi.getter
    def sharepoints(self) -> Sequence['outputs.GetClientAddonSharepointResult']:
        """
        SharePoint SSO configuration.
        """
        return pulumi.get(self, "sharepoints")

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Sequence['outputs.GetClientAddonSlackResult']:
        """
        Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        """
        return pulumi.get(self, "slacks")

    @_builtins.property
    @pulumi.getter
    def springcms(self) -> Sequence['outputs.GetClientAddonSpringcmResult']:
        """
        SpringCM SSO configuration.
        """
        return pulumi.get(self, "springcms")

    @_builtins.property
    @pulumi.getter(name="ssoIntegrations")
    def sso_integrations(self) -> Sequence['outputs.GetClientAddonSsoIntegrationResult']:
        """
        Generic SSO configuration.
        """
        return pulumi.get(self, "sso_integrations")

    @_builtins.property
    @pulumi.getter
    def wams(self) -> Sequence['outputs.GetClientAddonWamResult']:
        """
        Windows Azure Mobile Services addon configuration.
        """
        return pulumi.get(self, "wams")

    @_builtins.property
    @pulumi.getter
    def wsfeds(self) -> Sequence['outputs.GetClientAddonWsfedResult']:
        """
        WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        """
        return pulumi.get(self, "wsfeds")

    @_builtins.property
    @pulumi.getter
    def zendesks(self) -> Sequence['outputs.GetClientAddonZendeskResult']:
        """
        Zendesk SSO configuration.
        """
        return pulumi.get(self, "zendesks")

    @_builtins.property
    @pulumi.getter
    def zooms(self) -> Sequence['outputs.GetClientAddonZoomResult']:
        """
        Zoom SSO configuration.
        """
        return pulumi.get(self, "zooms")


@pulumi.output_type
class GetClientAddonAwResult(dict):
    def __init__(__self__, *,
                 lifetime_in_seconds: _builtins.int,
                 principal: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.int lifetime_in_seconds: AWS token lifetime in seconds.
        :param _builtins.str principal: AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        :param _builtins.str role: AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> _builtins.int:
        """
        AWS token lifetime in seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        """
        AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetClientAddonAzureBlobResult(dict):
    def __init__(__self__, *,
                 account_name: _builtins.str,
                 blob_delete: _builtins.bool,
                 blob_name: _builtins.str,
                 blob_read: _builtins.bool,
                 blob_write: _builtins.bool,
                 container_delete: _builtins.bool,
                 container_list: _builtins.bool,
                 container_name: _builtins.str,
                 container_read: _builtins.bool,
                 container_write: _builtins.bool,
                 expiration: _builtins.int,
                 signed_identifier: _builtins.str,
                 storage_access_key: _builtins.str):
        """
        :param _builtins.str account_name: Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        :param _builtins.bool blob_delete: Indicates if the issued token has permission to delete the blob.
        :param _builtins.str blob_name: Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        :param _builtins.bool blob_read: Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        :param _builtins.bool blob_write: Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param _builtins.bool container_delete: Indicates if issued token has permission to delete any blob in the container.
        :param _builtins.bool container_list: Indicates if the issued token has permission to list blobs in the container.
        :param _builtins.str container_name: Container to request a token for, such as `my-container`.
        :param _builtins.bool container_read: Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        :param _builtins.bool container_write: Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param _builtins.int expiration: Expiration in minutes for the generated token (default of 5 minutes).
        :param _builtins.str signed_identifier: Shared access policy identifier defined in your storage account resource.
        :param _builtins.str storage_access_key: Access key associated with this storage account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "blob_delete", blob_delete)
        pulumi.set(__self__, "blob_name", blob_name)
        pulumi.set(__self__, "blob_read", blob_read)
        pulumi.set(__self__, "blob_write", blob_write)
        pulumi.set(__self__, "container_delete", container_delete)
        pulumi.set(__self__, "container_list", container_list)
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "container_read", container_read)
        pulumi.set(__self__, "container_write", container_write)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "signed_identifier", signed_identifier)
        pulumi.set(__self__, "storage_access_key", storage_access_key)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> _builtins.str:
        """
        Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="blobDelete")
    def blob_delete(self) -> _builtins.bool:
        """
        Indicates if the issued token has permission to delete the blob.
        """
        return pulumi.get(self, "blob_delete")

    @_builtins.property
    @pulumi.getter(name="blobName")
    def blob_name(self) -> _builtins.str:
        """
        Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        """
        return pulumi.get(self, "blob_name")

    @_builtins.property
    @pulumi.getter(name="blobRead")
    def blob_read(self) -> _builtins.bool:
        """
        Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        """
        return pulumi.get(self, "blob_read")

    @_builtins.property
    @pulumi.getter(name="blobWrite")
    def blob_write(self) -> _builtins.bool:
        """
        Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "blob_write")

    @_builtins.property
    @pulumi.getter(name="containerDelete")
    def container_delete(self) -> _builtins.bool:
        """
        Indicates if issued token has permission to delete any blob in the container.
        """
        return pulumi.get(self, "container_delete")

    @_builtins.property
    @pulumi.getter(name="containerList")
    def container_list(self) -> _builtins.bool:
        """
        Indicates if the issued token has permission to list blobs in the container.
        """
        return pulumi.get(self, "container_list")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> _builtins.str:
        """
        Container to request a token for, such as `my-container`.
        """
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter(name="containerRead")
    def container_read(self) -> _builtins.bool:
        """
        Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        """
        return pulumi.get(self, "container_read")

    @_builtins.property
    @pulumi.getter(name="containerWrite")
    def container_write(self) -> _builtins.bool:
        """
        Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "container_write")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> _builtins.int:
        """
        Expiration in minutes for the generated token (default of 5 minutes).
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="signedIdentifier")
    def signed_identifier(self) -> _builtins.str:
        """
        Shared access policy identifier defined in your storage account resource.
        """
        return pulumi.get(self, "signed_identifier")

    @_builtins.property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> _builtins.str:
        """
        Access key associated with this storage account.
        """
        return pulumi.get(self, "storage_access_key")


@pulumi.output_type
class GetClientAddonAzureSbResult(dict):
    def __init__(__self__, *,
                 entity_path: _builtins.str,
                 expiration: _builtins.int,
                 namespace: _builtins.str,
                 sas_key: _builtins.str,
                 sas_key_name: _builtins.str):
        """
        :param _builtins.str entity_path: Entity you want to request a token for, such as `my-queue`.
        :param _builtins.int expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param _builtins.str namespace: Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        :param _builtins.str sas_key: Primary Key associated with your shared access policy.
        :param _builtins.str sas_key_name: Your shared access policy name defined in your Service Bus entity.
        """
        pulumi.set(__self__, "entity_path", entity_path)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "sas_key", sas_key)
        pulumi.set(__self__, "sas_key_name", sas_key_name)

    @_builtins.property
    @pulumi.getter(name="entityPath")
    def entity_path(self) -> _builtins.str:
        """
        Entity you want to request a token for, such as `my-queue`.
        """
        return pulumi.get(self, "entity_path")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> _builtins.int:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="sasKey")
    def sas_key(self) -> _builtins.str:
        """
        Primary Key associated with your shared access policy.
        """
        return pulumi.get(self, "sas_key")

    @_builtins.property
    @pulumi.getter(name="sasKeyName")
    def sas_key_name(self) -> _builtins.str:
        """
        Your shared access policy name defined in your Service Bus entity.
        """
        return pulumi.get(self, "sas_key_name")


@pulumi.output_type
class GetClientAddonBoxResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientAddonCloudbeeResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientAddonConcurResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientAddonDropboxResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientAddonEchosignResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str):
        """
        :param _builtins.str domain: Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetClientAddonEgnyteResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str):
        """
        :param _builtins.str domain: Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetClientAddonFirebaseResult(dict):
    def __init__(__self__, *,
                 client_email: _builtins.str,
                 lifetime_in_seconds: _builtins.int,
                 private_key: _builtins.str,
                 private_key_id: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str client_email: ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        :param _builtins.int lifetime_in_seconds: Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        :param _builtins.str private_key: Private Key for signing the token (SDK v3+ tokens only).
        :param _builtins.str private_key_id: Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        :param _builtins.str secret: Google Firebase Secret. (SDK v2 only).
        """
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> _builtins.str:
        """
        ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        """
        return pulumi.get(self, "client_email")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> _builtins.int:
        """
        Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        Private Key for signing the token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> _builtins.str:
        """
        Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Google Firebase Secret. (SDK v2 only).
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetClientAddonLayerResult(dict):
    def __init__(__self__, *,
                 expiration: _builtins.int,
                 key_id: _builtins.str,
                 principal: _builtins.str,
                 private_key: _builtins.str,
                 provider_id: _builtins.str):
        """
        :param _builtins.int expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param _builtins.str key_id: Authentication Key identifier used to sign the Layer token.
        :param _builtins.str principal: Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        :param _builtins.str private_key: Private key for signing the Layer token.
        :param _builtins.str provider_id: Provider ID of your Layer account.
        """
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "provider_id", provider_id)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> _builtins.int:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        Authentication Key identifier used to sign the Layer token.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        """
        Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        Private key for signing the Layer token.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        """
        Provider ID of your Layer account.
        """
        return pulumi.get(self, "provider_id")


@pulumi.output_type
class GetClientAddonMscrmResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: Microsoft Dynamics CRM application URL.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Microsoft Dynamics CRM application URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClientAddonNewrelicResult(dict):
    def __init__(__self__, *,
                 account: _builtins.str):
        """
        :param _builtins.str account: Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def account(self) -> _builtins.str:
        """
        Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class GetClientAddonOffice365Result(dict):
    def __init__(__self__, *,
                 connection: _builtins.str,
                 domain: _builtins.str):
        """
        :param _builtins.str connection: Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        :param _builtins.str domain: Your Office 365 domain name, for example `acme-org.com`.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> _builtins.str:
        """
        Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Your Office 365 domain name, for example `acme-org.com`.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class GetClientAddonRmResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClientAddonSalesforceResult(dict):
    def __init__(__self__, *,
                 entity_id: _builtins.str):
        """
        :param _builtins.str entity_id: Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        pulumi.set(__self__, "entity_id", entity_id)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> _builtins.str:
        """
        Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        return pulumi.get(self, "entity_id")


@pulumi.output_type
class GetClientAddonSalesforceApiResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 community_name: _builtins.str,
                 community_url_section: _builtins.str,
                 principal: _builtins.str):
        """
        :param _builtins.str client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param _builtins.str community_name: Community name.
        :param _builtins.str community_url_section: Community URL section.
        :param _builtins.str principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "community_name", community_name)
        pulumi.set(__self__, "community_url_section", community_url_section)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> _builtins.str:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> _builtins.str:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class GetClientAddonSalesforceSandboxApiResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 community_name: _builtins.str,
                 community_url_section: _builtins.str,
                 principal: _builtins.str):
        """
        :param _builtins.str client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param _builtins.str community_name: Community name.
        :param _builtins.str community_url_section: Community URL section.
        :param _builtins.str principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "community_name", community_name)
        pulumi.set(__self__, "community_url_section", community_url_section)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> _builtins.str:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> _builtins.str:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class GetClientAddonSamlpResult(dict):
    def __init__(__self__, *,
                 audience: _builtins.str,
                 authn_context_class_ref: _builtins.str,
                 binding: _builtins.str,
                 create_upn_claim: _builtins.bool,
                 destination: _builtins.str,
                 digest_algorithm: _builtins.str,
                 flexible_mappings: _builtins.str,
                 include_attribute_name_format: _builtins.bool,
                 issuer: _builtins.str,
                 lifetime_in_seconds: _builtins.int,
                 logouts: Sequence['outputs.GetClientAddonSamlpLogoutResult'],
                 map_identities: _builtins.bool,
                 map_unknown_claims_as_is: _builtins.bool,
                 mappings: Mapping[str, _builtins.str],
                 name_identifier_format: _builtins.str,
                 name_identifier_probes: Sequence[_builtins.str],
                 passthrough_claims_with_no_mapping: _builtins.bool,
                 recipient: _builtins.str,
                 sign_response: _builtins.bool,
                 signature_algorithm: _builtins.str,
                 signing_cert: _builtins.str,
                 typed_attributes: _builtins.bool):
        """
        :param _builtins.str audience: Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        :param _builtins.str authn_context_class_ref: Class reference of the authentication context.
        :param _builtins.str binding: Protocol binding used for SAML logout responses.
        :param _builtins.bool create_upn_claim: Indicates whether a UPN claim should be created. Defaults to `true`.
        :param _builtins.str destination: Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        :param _builtins.str digest_algorithm: Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        :param _builtins.str flexible_mappings: This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
        :param _builtins.bool include_attribute_name_format: Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        :param _builtins.str issuer: Issuer of the SAML Assertion.
        :param _builtins.int lifetime_in_seconds: Number of seconds during which the token is valid. Defaults to `3600` seconds.
        :param Sequence['GetClientAddonSamlpLogoutArgs'] logouts: Configuration settings for logout.
        :param _builtins.bool map_identities: Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        :param _builtins.bool map_unknown_claims_as_is: Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        :param Mapping[str, _builtins.str] mappings: Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        :param _builtins.str name_identifier_format: Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param Sequence[_builtins.str] name_identifier_probes: Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        :param _builtins.bool passthrough_claims_with_no_mapping: Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        :param _builtins.str recipient: Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        :param _builtins.bool sign_response: Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        :param _builtins.str signature_algorithm: Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        :param _builtins.str signing_cert: Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        :param _builtins.bool typed_attributes: Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "authn_context_class_ref", authn_context_class_ref)
        pulumi.set(__self__, "binding", binding)
        pulumi.set(__self__, "create_upn_claim", create_upn_claim)
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        pulumi.set(__self__, "flexible_mappings", flexible_mappings)
        pulumi.set(__self__, "include_attribute_name_format", include_attribute_name_format)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        pulumi.set(__self__, "logouts", logouts)
        pulumi.set(__self__, "map_identities", map_identities)
        pulumi.set(__self__, "map_unknown_claims_as_is", map_unknown_claims_as_is)
        pulumi.set(__self__, "mappings", mappings)
        pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        pulumi.set(__self__, "name_identifier_probes", name_identifier_probes)
        pulumi.set(__self__, "passthrough_claims_with_no_mapping", passthrough_claims_with_no_mapping)
        pulumi.set(__self__, "recipient", recipient)
        pulumi.set(__self__, "sign_response", sign_response)
        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        pulumi.set(__self__, "signing_cert", signing_cert)
        pulumi.set(__self__, "typed_attributes", typed_attributes)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter(name="authnContextClassRef")
    def authn_context_class_ref(self) -> _builtins.str:
        """
        Class reference of the authentication context.
        """
        return pulumi.get(self, "authn_context_class_ref")

    @_builtins.property
    @pulumi.getter
    def binding(self) -> _builtins.str:
        """
        Protocol binding used for SAML logout responses.
        """
        return pulumi.get(self, "binding")

    @_builtins.property
    @pulumi.getter(name="createUpnClaim")
    def create_upn_claim(self) -> _builtins.bool:
        """
        Indicates whether a UPN claim should be created. Defaults to `true`.
        """
        return pulumi.get(self, "create_upn_claim")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> _builtins.str:
        """
        Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        """
        return pulumi.get(self, "digest_algorithm")

    @_builtins.property
    @pulumi.getter(name="flexibleMappings")
    def flexible_mappings(self) -> _builtins.str:
        """
        This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
        """
        return pulumi.get(self, "flexible_mappings")

    @_builtins.property
    @pulumi.getter(name="includeAttributeNameFormat")
    def include_attribute_name_format(self) -> _builtins.bool:
        """
        Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        """
        return pulumi.get(self, "include_attribute_name_format")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        Issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> _builtins.int:
        """
        Number of seconds during which the token is valid. Defaults to `3600` seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def logouts(self) -> Sequence['outputs.GetClientAddonSamlpLogoutResult']:
        """
        Configuration settings for logout.
        """
        return pulumi.get(self, "logouts")

    @_builtins.property
    @pulumi.getter(name="mapIdentities")
    def map_identities(self) -> _builtins.bool:
        """
        Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        """
        return pulumi.get(self, "map_identities")

    @_builtins.property
    @pulumi.getter(name="mapUnknownClaimsAsIs")
    def map_unknown_claims_as_is(self) -> _builtins.bool:
        """
        Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        """
        return pulumi.get(self, "map_unknown_claims_as_is")

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Mapping[str, _builtins.str]:
        """
        Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        """
        return pulumi.get(self, "mappings")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> _builtins.str:
        """
        Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierProbes")
    def name_identifier_probes(self) -> Sequence[_builtins.str]:
        """
        Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        """
        return pulumi.get(self, "name_identifier_probes")

    @_builtins.property
    @pulumi.getter(name="passthroughClaimsWithNoMapping")
    def passthrough_claims_with_no_mapping(self) -> _builtins.bool:
        """
        Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        """
        return pulumi.get(self, "passthrough_claims_with_no_mapping")

    @_builtins.property
    @pulumi.getter
    def recipient(self) -> _builtins.str:
        """
        Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        """
        return pulumi.get(self, "recipient")

    @_builtins.property
    @pulumi.getter(name="signResponse")
    def sign_response(self) -> _builtins.bool:
        """
        Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        """
        return pulumi.get(self, "sign_response")

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> _builtins.str:
        """
        Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        """
        return pulumi.get(self, "signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> _builtins.str:
        """
        Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        """
        return pulumi.get(self, "signing_cert")

    @_builtins.property
    @pulumi.getter(name="typedAttributes")
    def typed_attributes(self) -> _builtins.bool:
        """
        Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        return pulumi.get(self, "typed_attributes")


@pulumi.output_type
class GetClientAddonSamlpLogoutResult(dict):
    def __init__(__self__, *,
                 callback: _builtins.str,
                 slo_enabled: _builtins.bool):
        """
        :param _builtins.str callback: The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        :param _builtins.bool slo_enabled: Controls whether Auth0 should notify service providers of session termination.
        """
        pulumi.set(__self__, "callback", callback)
        pulumi.set(__self__, "slo_enabled", slo_enabled)

    @_builtins.property
    @pulumi.getter
    def callback(self) -> _builtins.str:
        """
        The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        """
        return pulumi.get(self, "callback")

    @_builtins.property
    @pulumi.getter(name="sloEnabled")
    def slo_enabled(self) -> _builtins.bool:
        """
        Controls whether Auth0 should notify service providers of session termination.
        """
        return pulumi.get(self, "slo_enabled")


@pulumi.output_type
class GetClientAddonSapApiResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 name_identifier_format: _builtins.str,
                 scope: _builtins.str,
                 service_password: _builtins.str,
                 token_endpoint_url: _builtins.str,
                 username_attribute: _builtins.str):
        """
        :param _builtins.str client_id: If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute `client_id` must be set and equal the `client_id` form parameter of the access token request.
        :param _builtins.str name_identifier_format: NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param _builtins.str scope: Requested scope for SAP APIs.
        :param _builtins.str service_password: Service account password to use to authenticate API calls to the token endpoint.
        :param _builtins.str token_endpoint_url: The OAuth2 token endpoint URL of your SAP OData server.
        :param _builtins.str username_attribute: Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "service_password", service_password)
        pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        pulumi.set(__self__, "username_attribute", username_attribute)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute `client_id` must be set and equal the `client_id` form parameter of the access token request.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> _builtins.str:
        """
        NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Requested scope for SAP APIs.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="servicePassword")
    def service_password(self) -> _builtins.str:
        """
        Service account password to use to authenticate API calls to the token endpoint.
        """
        return pulumi.get(self, "service_password")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> _builtins.str:
        """
        The OAuth2 token endpoint URL of your SAP OData server.
        """
        return pulumi.get(self, "token_endpoint_url")

    @_builtins.property
    @pulumi.getter(name="usernameAttribute")
    def username_attribute(self) -> _builtins.str:
        """
        Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        return pulumi.get(self, "username_attribute")


@pulumi.output_type
class GetClientAddonSentryResult(dict):
    def __init__(__self__, *,
                 base_url: _builtins.str,
                 org_slug: _builtins.str):
        """
        :param _builtins.str base_url: URL prefix only if running Sentry Community Edition, otherwise leave empty.
        :param _builtins.str org_slug: Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "org_slug", org_slug)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        URL prefix only if running Sentry Community Edition, otherwise leave empty.
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="orgSlug")
    def org_slug(self) -> _builtins.str:
        """
        Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        return pulumi.get(self, "org_slug")


@pulumi.output_type
class GetClientAddonSharepointResult(dict):
    def __init__(__self__, *,
                 external_urls: Sequence[_builtins.str],
                 url: _builtins.str):
        """
        :param Sequence[_builtins.str] external_urls: External SharePoint application URLs if exposed to the Internet.
        :param _builtins.str url: Internal SharePoint application URL.
        """
        pulumi.set(__self__, "external_urls", external_urls)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Sequence[_builtins.str]:
        """
        External SharePoint application URLs if exposed to the Internet.
        """
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Internal SharePoint application URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClientAddonSlackResult(dict):
    def __init__(__self__, *,
                 team: _builtins.str):
        """
        :param _builtins.str team: Slack team name.
        """
        pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter
    def team(self) -> _builtins.str:
        """
        Slack team name.
        """
        return pulumi.get(self, "team")


@pulumi.output_type
class GetClientAddonSpringcmResult(dict):
    def __init__(__self__, *,
                 acs_url: _builtins.str):
        """
        :param _builtins.str acs_url: SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        pulumi.set(__self__, "acs_url", acs_url)

    @_builtins.property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> _builtins.str:
        """
        SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        return pulumi.get(self, "acs_url")


@pulumi.output_type
class GetClientAddonSsoIntegrationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: SSO integration name.
        :param _builtins.str version: SSO integration version installed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        SSO integration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        SSO integration version installed.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClientAddonWamResult(dict):
    def __init__(__self__, *,
                 master_key: _builtins.str):
        """
        :param _builtins.str master_key: Your master key for Windows Azure Mobile Services.
        """
        pulumi.set(__self__, "master_key", master_key)

    @_builtins.property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> _builtins.str:
        """
        Your master key for Windows Azure Mobile Services.
        """
        return pulumi.get(self, "master_key")


@pulumi.output_type
class GetClientAddonWsfedResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClientAddonZendeskResult(dict):
    def __init__(__self__, *,
                 account_name: _builtins.str):
        """
        :param _builtins.str account_name: Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        pulumi.set(__self__, "account_name", account_name)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> _builtins.str:
        """
        Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        return pulumi.get(self, "account_name")


@pulumi.output_type
class GetClientAddonZoomResult(dict):
    def __init__(__self__, *,
                 account: _builtins.str):
        """
        :param _builtins.str account: Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        pulumi.set(__self__, "account", account)

    @_builtins.property
    @pulumi.getter
    def account(self) -> _builtins.str:
        """
        Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        return pulumi.get(self, "account")


@pulumi.output_type
class GetClientClientAuthenticationMethodResult(dict):
    def __init__(__self__, *,
                 private_key_jwts: Sequence['outputs.GetClientClientAuthenticationMethodPrivateKeyJwtResult'],
                 self_signed_tls_client_auths: Sequence['outputs.GetClientClientAuthenticationMethodSelfSignedTlsClientAuthResult'],
                 tls_client_auths: Sequence['outputs.GetClientClientAuthenticationMethodTlsClientAuthResult']):
        """
        :param Sequence['GetClientClientAuthenticationMethodPrivateKeyJwtArgs'] private_key_jwts: If this is defined, the client is enabled to use the Private Key JWT authentication method.
        :param Sequence['GetClientClientAuthenticationMethodSelfSignedTlsClientAuthArgs'] self_signed_tls_client_auths: If this is defined, the client is enabled to use the mTLS authentication method utilizing a self-signed certificate.
        :param Sequence['GetClientClientAuthenticationMethodTlsClientAuthArgs'] tls_client_auths: If this is defined, the client is enabled to use the CA-based mTLS authentication method.
        """
        pulumi.set(__self__, "private_key_jwts", private_key_jwts)
        pulumi.set(__self__, "self_signed_tls_client_auths", self_signed_tls_client_auths)
        pulumi.set(__self__, "tls_client_auths", tls_client_auths)

    @_builtins.property
    @pulumi.getter(name="privateKeyJwts")
    def private_key_jwts(self) -> Sequence['outputs.GetClientClientAuthenticationMethodPrivateKeyJwtResult']:
        """
        If this is defined, the client is enabled to use the Private Key JWT authentication method.
        """
        return pulumi.get(self, "private_key_jwts")

    @_builtins.property
    @pulumi.getter(name="selfSignedTlsClientAuths")
    def self_signed_tls_client_auths(self) -> Sequence['outputs.GetClientClientAuthenticationMethodSelfSignedTlsClientAuthResult']:
        """
        If this is defined, the client is enabled to use the mTLS authentication method utilizing a self-signed certificate.
        """
        return pulumi.get(self, "self_signed_tls_client_auths")

    @_builtins.property
    @pulumi.getter(name="tlsClientAuths")
    def tls_client_auths(self) -> Sequence['outputs.GetClientClientAuthenticationMethodTlsClientAuthResult']:
        """
        If this is defined, the client is enabled to use the CA-based mTLS authentication method.
        """
        return pulumi.get(self, "tls_client_auths")


@pulumi.output_type
class GetClientClientAuthenticationMethodPrivateKeyJwtResult(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.GetClientClientAuthenticationMethodPrivateKeyJwtCredentialResult']):
        """
        :param Sequence['GetClientClientAuthenticationMethodPrivateKeyJwtCredentialArgs'] credentials: Credentials that will be enabled on the client for Private Key JWT authentication.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.GetClientClientAuthenticationMethodPrivateKeyJwtCredentialResult']:
        """
        Credentials that will be enabled on the client for Private Key JWT authentication.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class GetClientClientAuthenticationMethodPrivateKeyJwtCredentialResult(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 created_at: _builtins.str,
                 credential_type: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 key_id: _builtins.str,
                 name: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str credential_type: Credential type. Supported types: `public_key`.
        :param _builtins.str expires_at: The ISO 8601 formatted date representing the expiration of the credential.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str key_id: The key identifier of the credential, generated on creation.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date representing the expiration of the credential.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetClientClientAuthenticationMethodSelfSignedTlsClientAuthResult(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.GetClientClientAuthenticationMethodSelfSignedTlsClientAuthCredentialResult']):
        """
        :param Sequence['GetClientClientAuthenticationMethodSelfSignedTlsClientAuthCredentialArgs'] credentials: Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.GetClientClientAuthenticationMethodSelfSignedTlsClientAuthCredentialResult']:
        """
        Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class GetClientClientAuthenticationMethodSelfSignedTlsClientAuthCredentialResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 credential_type: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str credential_type: Credential type. Supported types: `x509_cert`.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `x509_cert`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetClientClientAuthenticationMethodTlsClientAuthResult(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.GetClientClientAuthenticationMethodTlsClientAuthCredentialResult']):
        """
        :param Sequence['GetClientClientAuthenticationMethodTlsClientAuthCredentialArgs'] credentials: Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        pulumi.set(__self__, "credentials", credentials)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.GetClientClientAuthenticationMethodTlsClientAuthCredentialResult']:
        """
        Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class GetClientClientAuthenticationMethodTlsClientAuthCredentialResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 credential_type: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 subject_dn: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str credential_type: Credential type. Supported types: `cert_subject_dn`.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str subject_dn: Subject Distinguished Name. Mutually exlusive with `pem` property.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject_dn", subject_dn)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `cert_subject_dn`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subjectDn")
    def subject_dn(self) -> _builtins.str:
        """
        Subject Distinguished Name. Mutually exlusive with `pem` property.
        """
        return pulumi.get(self, "subject_dn")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetClientDefaultOrganizationResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 flows: Sequence[_builtins.str],
                 organization_id: _builtins.str):
        """
        :param _builtins.bool disable: If set, the `default_organization` will be removed.
        :param Sequence[_builtins.str] flows: Definition of the flow that needs to be configured. Eg. client_credentials
        :param _builtins.str organization_id: The unique identifier of the organization
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "flows", flows)
        pulumi.set(__self__, "organization_id", organization_id)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        If set, the `default_organization` will be removed.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Sequence[_builtins.str]:
        """
        Definition of the flow that needs to be configured. Eg. client_credentials
        """
        return pulumi.get(self, "flows")

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> _builtins.str:
        """
        The unique identifier of the organization
        """
        return pulumi.get(self, "organization_id")


@pulumi.output_type
class GetClientJwtConfigurationResult(dict):
    def __init__(__self__, *,
                 alg: _builtins.str,
                 lifetime_in_seconds: _builtins.int,
                 scopes: Mapping[str, _builtins.str],
                 secret_encoded: _builtins.bool):
        """
        :param _builtins.str alg: Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        :param _builtins.int lifetime_in_seconds: Number of seconds during which the JWT will be valid.
        :param Mapping[str, _builtins.str] scopes: Permissions (scopes) included in JWTs.
        :param _builtins.bool secret_encoded: Indicates whether the client secret is Base64-encoded.
        """
        pulumi.set(__self__, "alg", alg)
        pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "secret_encoded", secret_encoded)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> _builtins.str:
        """
        Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        """
        return pulumi.get(self, "alg")

    @_builtins.property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> _builtins.int:
        """
        Number of seconds during which the JWT will be valid.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Mapping[str, _builtins.str]:
        """
        Permissions (scopes) included in JWTs.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="secretEncoded")
    def secret_encoded(self) -> _builtins.bool:
        """
        Indicates whether the client secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_encoded")


@pulumi.output_type
class GetClientMobileResult(dict):
    def __init__(__self__, *,
                 androids: Sequence['outputs.GetClientMobileAndroidResult'],
                 ios: Sequence['outputs.GetClientMobileIoResult']):
        """
        :param Sequence['GetClientMobileAndroidArgs'] androids: Configuration settings for Android native apps.
        :param Sequence['GetClientMobileIoArgs'] ios: Configuration settings for i0S native apps.
        """
        pulumi.set(__self__, "androids", androids)
        pulumi.set(__self__, "ios", ios)

    @_builtins.property
    @pulumi.getter
    def androids(self) -> Sequence['outputs.GetClientMobileAndroidResult']:
        """
        Configuration settings for Android native apps.
        """
        return pulumi.get(self, "androids")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetClientMobileIoResult']:
        """
        Configuration settings for i0S native apps.
        """
        return pulumi.get(self, "ios")


@pulumi.output_type
class GetClientMobileAndroidResult(dict):
    def __init__(__self__, *,
                 app_package_name: _builtins.str,
                 sha256_cert_fingerprints: Sequence[_builtins.str]):
        pulumi.set(__self__, "app_package_name", app_package_name)
        pulumi.set(__self__, "sha256_cert_fingerprints", sha256_cert_fingerprints)

    @_builtins.property
    @pulumi.getter(name="appPackageName")
    def app_package_name(self) -> _builtins.str:
        return pulumi.get(self, "app_package_name")

    @_builtins.property
    @pulumi.getter(name="sha256CertFingerprints")
    def sha256_cert_fingerprints(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "sha256_cert_fingerprints")


@pulumi.output_type
class GetClientMobileIoResult(dict):
    def __init__(__self__, *,
                 app_bundle_identifier: _builtins.str,
                 team_id: _builtins.str):
        pulumi.set(__self__, "app_bundle_identifier", app_bundle_identifier)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="appBundleIdentifier")
    def app_bundle_identifier(self) -> _builtins.str:
        return pulumi.get(self, "app_bundle_identifier")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetClientNativeSocialLoginResult(dict):
    def __init__(__self__, *,
                 apples: Sequence['outputs.GetClientNativeSocialLoginAppleResult'],
                 facebooks: Sequence['outputs.GetClientNativeSocialLoginFacebookResult'],
                 googles: Sequence['outputs.GetClientNativeSocialLoginGoogleResult']):
        pulumi.set(__self__, "apples", apples)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "googles", googles)

    @_builtins.property
    @pulumi.getter
    def apples(self) -> Sequence['outputs.GetClientNativeSocialLoginAppleResult']:
        return pulumi.get(self, "apples")

    @_builtins.property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetClientNativeSocialLoginFacebookResult']:
        return pulumi.get(self, "facebooks")

    @_builtins.property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetClientNativeSocialLoginGoogleResult']:
        return pulumi.get(self, "googles")


@pulumi.output_type
class GetClientNativeSocialLoginAppleResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClientNativeSocialLoginFacebookResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClientNativeSocialLoginGoogleResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClientOidcLogoutResult(dict):
    def __init__(__self__, *,
                 backchannel_logout_initiators: Sequence['outputs.GetClientOidcLogoutBackchannelLogoutInitiatorResult'],
                 backchannel_logout_urls: Sequence[_builtins.str]):
        """
        :param Sequence['GetClientOidcLogoutBackchannelLogoutInitiatorArgs'] backchannel_logout_initiators: Configure OIDC logout initiators for the Client
        :param Sequence[_builtins.str] backchannel_logout_urls: Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        """
        pulumi.set(__self__, "backchannel_logout_initiators", backchannel_logout_initiators)
        pulumi.set(__self__, "backchannel_logout_urls", backchannel_logout_urls)

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutInitiators")
    def backchannel_logout_initiators(self) -> Sequence['outputs.GetClientOidcLogoutBackchannelLogoutInitiatorResult']:
        """
        Configure OIDC logout initiators for the Client
        """
        return pulumi.get(self, "backchannel_logout_initiators")

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutUrls")
    def backchannel_logout_urls(self) -> Sequence[_builtins.str]:
        """
        Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        """
        return pulumi.get(self, "backchannel_logout_urls")


@pulumi.output_type
class GetClientOidcLogoutBackchannelLogoutInitiatorResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 selected_initiators: Sequence[_builtins.str]):
        """
        :param _builtins.str mode: Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel_logout_selected_initiators set, `all` enables all current and future initiators.
        :param Sequence[_builtins.str] selected_initiators: Contains the list of initiators to be enabled for the given client.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "selected_initiators", selected_initiators)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel_logout_selected_initiators set, `all` enables all current and future initiators.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="selectedInitiators")
    def selected_initiators(self) -> Sequence[_builtins.str]:
        """
        Contains the list of initiators to be enabled for the given client.
        """
        return pulumi.get(self, "selected_initiators")


@pulumi.output_type
class GetClientRefreshTokenResult(dict):
    def __init__(__self__, *,
                 expiration_type: _builtins.str,
                 idle_token_lifetime: _builtins.int,
                 infinite_idle_token_lifetime: _builtins.bool,
                 infinite_token_lifetime: _builtins.bool,
                 leeway: _builtins.int,
                 policies: Sequence['outputs.GetClientRefreshTokenPolicyResult'],
                 rotation_type: _builtins.str,
                 token_lifetime: _builtins.int):
        """
        :param _builtins.str expiration_type: Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        :param _builtins.int idle_token_lifetime: The time in seconds after which inactive refresh tokens will expire.
        :param _builtins.bool infinite_idle_token_lifetime: Whether inactive refresh tokens should remain valid indefinitely.
        :param _builtins.bool infinite_token_lifetime: Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        :param _builtins.int leeway: The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        :param Sequence['GetClientRefreshTokenPolicyArgs'] policies: A collection of policies governing multi-resource refresh token exchange (MRRT), defining how refresh tokens can be used across different resource servers
        :param _builtins.str rotation_type: Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        :param _builtins.int token_lifetime: The absolute lifetime of a refresh token in seconds.
        """
        pulumi.set(__self__, "expiration_type", expiration_type)
        pulumi.set(__self__, "idle_token_lifetime", idle_token_lifetime)
        pulumi.set(__self__, "infinite_idle_token_lifetime", infinite_idle_token_lifetime)
        pulumi.set(__self__, "infinite_token_lifetime", infinite_token_lifetime)
        pulumi.set(__self__, "leeway", leeway)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "rotation_type", rotation_type)
        pulumi.set(__self__, "token_lifetime", token_lifetime)

    @_builtins.property
    @pulumi.getter(name="expirationType")
    def expiration_type(self) -> _builtins.str:
        """
        Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        """
        return pulumi.get(self, "expiration_type")

    @_builtins.property
    @pulumi.getter(name="idleTokenLifetime")
    def idle_token_lifetime(self) -> _builtins.int:
        """
        The time in seconds after which inactive refresh tokens will expire.
        """
        return pulumi.get(self, "idle_token_lifetime")

    @_builtins.property
    @pulumi.getter(name="infiniteIdleTokenLifetime")
    def infinite_idle_token_lifetime(self) -> _builtins.bool:
        """
        Whether inactive refresh tokens should remain valid indefinitely.
        """
        return pulumi.get(self, "infinite_idle_token_lifetime")

    @_builtins.property
    @pulumi.getter(name="infiniteTokenLifetime")
    def infinite_token_lifetime(self) -> _builtins.bool:
        """
        Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        """
        return pulumi.get(self, "infinite_token_lifetime")

    @_builtins.property
    @pulumi.getter
    def leeway(self) -> _builtins.int:
        """
        The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        """
        return pulumi.get(self, "leeway")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClientRefreshTokenPolicyResult']:
        """
        A collection of policies governing multi-resource refresh token exchange (MRRT), defining how refresh tokens can be used across different resource servers
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="rotationType")
    def rotation_type(self) -> _builtins.str:
        """
        Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        """
        return pulumi.get(self, "rotation_type")

    @_builtins.property
    @pulumi.getter(name="tokenLifetime")
    def token_lifetime(self) -> _builtins.int:
        """
        The absolute lifetime of a refresh token in seconds.
        """
        return pulumi.get(self, "token_lifetime")


@pulumi.output_type
class GetClientRefreshTokenPolicyResult(dict):
    def __init__(__self__, *,
                 audience: _builtins.str,
                 scopes: Sequence[_builtins.str]):
        """
        :param _builtins.str audience: The identifier of the resource server to which the Multi Resource Refresh Token Policy applies
        :param Sequence[_builtins.str] scopes: The resource server permissions granted under the Multi Resource Refresh Token Policy, defining the context in which an access token can be used
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        The identifier of the resource server to which the Multi Resource Refresh Token Policy applies
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        The resource server permissions granted under the Multi Resource Refresh Token Policy, defining the context in which an access token can be used
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetClientSessionTransferResult(dict):
    def __init__(__self__, *,
                 allow_refresh_token: _builtins.bool,
                 allowed_authentication_methods: Sequence[_builtins.str],
                 can_create_session_transfer_token: _builtins.bool,
                 enforce_device_binding: _builtins.str):
        """
        :param _builtins.bool allow_refresh_token: Indicates whether the application is allowed to use a refresh token when using a session_transfer_token session.
        :param _builtins.bool can_create_session_transfer_token: Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session_transfer_token
        :param _builtins.str enforce_device_binding: Configures the level of device binding enforced when a session_transfer_token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        pulumi.set(__self__, "allow_refresh_token", allow_refresh_token)
        pulumi.set(__self__, "allowed_authentication_methods", allowed_authentication_methods)
        pulumi.set(__self__, "can_create_session_transfer_token", can_create_session_transfer_token)
        pulumi.set(__self__, "enforce_device_binding", enforce_device_binding)

    @_builtins.property
    @pulumi.getter(name="allowRefreshToken")
    def allow_refresh_token(self) -> _builtins.bool:
        """
        Indicates whether the application is allowed to use a refresh token when using a session_transfer_token session.
        """
        return pulumi.get(self, "allow_refresh_token")

    @_builtins.property
    @pulumi.getter(name="allowedAuthenticationMethods")
    def allowed_authentication_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_authentication_methods")

    @_builtins.property
    @pulumi.getter(name="canCreateSessionTransferToken")
    def can_create_session_transfer_token(self) -> _builtins.bool:
        """
        Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session_transfer_token
        """
        return pulumi.get(self, "can_create_session_transfer_token")

    @_builtins.property
    @pulumi.getter(name="enforceDeviceBinding")
    def enforce_device_binding(self) -> _builtins.str:
        """
        Configures the level of device binding enforced when a session_transfer_token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        return pulumi.get(self, "enforce_device_binding")


@pulumi.output_type
class GetClientSignedRequestObjectResult(dict):
    def __init__(__self__, *,
                 credentials: Sequence['outputs.GetClientSignedRequestObjectCredentialResult'],
                 required: _builtins.bool):
        """
        :param Sequence['GetClientSignedRequestObjectCredentialArgs'] credentials: Credentials that will be enabled on the client for JWT-secured authorization requests.
        :param _builtins.bool required: Require JWT-secured authorization requests.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Sequence['outputs.GetClientSignedRequestObjectCredentialResult']:
        """
        Credentials that will be enabled on the client for JWT-secured authorization requests.
        """
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        """
        Require JWT-secured authorization requests.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class GetClientSignedRequestObjectCredentialResult(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 created_at: _builtins.str,
                 credential_type: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 key_id: _builtins.str,
                 name: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param _builtins.str created_at: The ISO 8601 formatted date the credential was created.
        :param _builtins.str credential_type: Credential type. Supported types: `public_key`.
        :param _builtins.str expires_at: The ISO 8601 formatted date representing the expiration of the credential.
        :param _builtins.str id: The ID of the client credential.
        :param _builtins.str key_id: The key identifier of the credential, generated on creation.
        :param _builtins.str name: Friendly name for a credential.
        :param _builtins.str updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> _builtins.str:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date representing the expiration of the credential.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetClientTokenExchangeResult(dict):
    def __init__(__self__, *,
                 allow_any_profile_of_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allow_any_profile_of_types: List of allowed profile types for token exchange
        """
        pulumi.set(__self__, "allow_any_profile_of_types", allow_any_profile_of_types)

    @_builtins.property
    @pulumi.getter(name="allowAnyProfileOfTypes")
    def allow_any_profile_of_types(self) -> Sequence[_builtins.str]:
        """
        List of allowed profile types for token exchange
        """
        return pulumi.get(self, "allow_any_profile_of_types")


@pulumi.output_type
class GetClientTokenQuotaResult(dict):
    def __init__(__self__, *,
                 client_credentials: Sequence['outputs.GetClientTokenQuotaClientCredentialResult']):
        """
        :param Sequence['GetClientTokenQuotaClientCredentialArgs'] client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Sequence['outputs.GetClientTokenQuotaClientCredentialResult']:
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class GetClientTokenQuotaClientCredentialResult(dict):
    def __init__(__self__, *,
                 enforce: _builtins.bool,
                 per_day: _builtins.int,
                 per_hour: _builtins.int):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        pulumi.set(__self__, "enforce", enforce)
        pulumi.set(__self__, "per_day", per_day)
        pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> _builtins.bool:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> _builtins.int:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> _builtins.int:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class GetClientsClientResult(dict):
    def __init__(__self__, *,
                 allowed_clients: Sequence[_builtins.str],
                 allowed_logout_urls: Sequence[_builtins.str],
                 allowed_origins: Sequence[_builtins.str],
                 app_type: _builtins.str,
                 callbacks: Sequence[_builtins.str],
                 client_metadata: Mapping[str, _builtins.str],
                 client_secret: _builtins.str,
                 description: _builtins.str,
                 grant_types: Sequence[_builtins.str],
                 is_first_party: _builtins.bool,
                 is_token_endpoint_ip_header_trusted: _builtins.bool,
                 oidc_logouts: Sequence['outputs.GetClientsClientOidcLogoutResult'],
                 session_transfers: Sequence['outputs.GetClientsClientSessionTransferResult'],
                 token_exchanges: Sequence['outputs.GetClientsClientTokenExchangeResult'],
                 token_quotas: Sequence['outputs.GetClientsClientTokenQuotaResult'],
                 web_origins: Sequence[_builtins.str],
                 client_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_clients: List of applications ID's that will be allowed to make delegation request. By default, all applications will be allowed.
        :param Sequence[_builtins.str] allowed_logout_urls: URLs that Auth0 may redirect to after logout.
        :param Sequence[_builtins.str] allowed_origins: URLs that represent valid origins for cross-origin resource sharing. By default, all your callback URLs will be allowed.
        :param _builtins.str app_type: Type of application the client represents. Possible values are: `native`, `spa`, `regular_web`, `non_interactive`, `sso_integration`. Specific SSO integrations types accepted as well are: `rms`, `box`, `cloudbees`, `concur`, `dropbox`, `mscrm`, `echosign`, `egnyte`, `newrelic`, `office365`, `salesforce`, `sentry`, `sharepoint`, `slack`, `springcm`, `zendesk`, `zoom`.
        :param Sequence[_builtins.str] callbacks: URLs that Auth0 may call back to after a user authenticates for the client. Make sure to specify the protocol (https://) otherwise the callback may fail in some cases. With the exception of custom URI schemes for native clients, all callbacks should use protocol https://.
        :param Mapping[str, _builtins.str] client_metadata: Metadata associated with the client, in the form of an object with string values (max 255 chars). Maximum of 10 metadata properties allowed. Field names (max 255 chars) are alphanumeric and may only include the following special characters: `:,-+=_*?"/\\()<>@ [Tab] [Space]`.
        :param _builtins.str description: Description of the purpose of the client.
        :param Sequence[_builtins.str] grant_types: Types of grants that this client is authorized to use.
        :param _builtins.bool is_first_party: Indicates whether this client is a first-party client.Defaults to true from the API
        :param _builtins.bool is_token_endpoint_ip_header_trusted: Indicates whether the token endpoint IP header is trusted. Requires the authentication method to be set to `client_secret_post` or `client_secret_basic`. Setting this property when creating the resource, will default the authentication method to `client_secret_post`. To change the authentication method to `client_secret_basic` use the `ClientCredentials` resource.
        :param Sequence['GetClientsClientOidcLogoutArgs'] oidc_logouts: Configure OIDC logout for the Client
        :param Sequence['GetClientsClientTokenExchangeArgs'] token_exchanges: Allows configuration for token exchange
        :param Sequence['GetClientsClientTokenQuotaArgs'] token_quotas: The token quota configuration.
        :param Sequence[_builtins.str] web_origins: URLs that represent valid web origins for use with web message response mode.
        :param _builtins.str client_id: The ID of the client. If not provided, `name` must be set.
        :param _builtins.str name: The name of the client. If not provided, `client_id` must be set.
        """
        pulumi.set(__self__, "allowed_clients", allowed_clients)
        pulumi.set(__self__, "allowed_logout_urls", allowed_logout_urls)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "app_type", app_type)
        pulumi.set(__self__, "callbacks", callbacks)
        pulumi.set(__self__, "client_metadata", client_metadata)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "grant_types", grant_types)
        pulumi.set(__self__, "is_first_party", is_first_party)
        pulumi.set(__self__, "is_token_endpoint_ip_header_trusted", is_token_endpoint_ip_header_trusted)
        pulumi.set(__self__, "oidc_logouts", oidc_logouts)
        pulumi.set(__self__, "session_transfers", session_transfers)
        pulumi.set(__self__, "token_exchanges", token_exchanges)
        pulumi.set(__self__, "token_quotas", token_quotas)
        pulumi.set(__self__, "web_origins", web_origins)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Sequence[_builtins.str]:
        """
        List of applications ID's that will be allowed to make delegation request. By default, all applications will be allowed.
        """
        return pulumi.get(self, "allowed_clients")

    @_builtins.property
    @pulumi.getter(name="allowedLogoutUrls")
    def allowed_logout_urls(self) -> Sequence[_builtins.str]:
        """
        URLs that Auth0 may redirect to after logout.
        """
        return pulumi.get(self, "allowed_logout_urls")

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        URLs that represent valid origins for cross-origin resource sharing. By default, all your callback URLs will be allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @_builtins.property
    @pulumi.getter(name="appType")
    def app_type(self) -> _builtins.str:
        """
        Type of application the client represents. Possible values are: `native`, `spa`, `regular_web`, `non_interactive`, `sso_integration`. Specific SSO integrations types accepted as well are: `rms`, `box`, `cloudbees`, `concur`, `dropbox`, `mscrm`, `echosign`, `egnyte`, `newrelic`, `office365`, `salesforce`, `sentry`, `sharepoint`, `slack`, `springcm`, `zendesk`, `zoom`.
        """
        return pulumi.get(self, "app_type")

    @_builtins.property
    @pulumi.getter
    def callbacks(self) -> Sequence[_builtins.str]:
        """
        URLs that Auth0 may call back to after a user authenticates for the client. Make sure to specify the protocol (https://) otherwise the callback may fail in some cases. With the exception of custom URI schemes for native clients, all callbacks should use protocol https://.
        """
        return pulumi.get(self, "callbacks")

    @_builtins.property
    @pulumi.getter(name="clientMetadata")
    def client_metadata(self) -> Mapping[str, _builtins.str]:
        """
        Metadata associated with the client, in the form of an object with string values (max 255 chars). Maximum of 10 metadata properties allowed. Field names (max 255 chars) are alphanumeric and may only include the following special characters: `:,-+=_*?"/\\()<>@ [Tab] [Space]`.
        """
        return pulumi.get(self, "client_metadata")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the purpose of the client.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Sequence[_builtins.str]:
        """
        Types of grants that this client is authorized to use.
        """
        return pulumi.get(self, "grant_types")

    @_builtins.property
    @pulumi.getter(name="isFirstParty")
    def is_first_party(self) -> _builtins.bool:
        """
        Indicates whether this client is a first-party client.Defaults to true from the API
        """
        return pulumi.get(self, "is_first_party")

    @_builtins.property
    @pulumi.getter(name="isTokenEndpointIpHeaderTrusted")
    def is_token_endpoint_ip_header_trusted(self) -> _builtins.bool:
        """
        Indicates whether the token endpoint IP header is trusted. Requires the authentication method to be set to `client_secret_post` or `client_secret_basic`. Setting this property when creating the resource, will default the authentication method to `client_secret_post`. To change the authentication method to `client_secret_basic` use the `ClientCredentials` resource.
        """
        return pulumi.get(self, "is_token_endpoint_ip_header_trusted")

    @_builtins.property
    @pulumi.getter(name="oidcLogouts")
    def oidc_logouts(self) -> Sequence['outputs.GetClientsClientOidcLogoutResult']:
        """
        Configure OIDC logout for the Client
        """
        return pulumi.get(self, "oidc_logouts")

    @_builtins.property
    @pulumi.getter(name="sessionTransfers")
    def session_transfers(self) -> Sequence['outputs.GetClientsClientSessionTransferResult']:
        return pulumi.get(self, "session_transfers")

    @_builtins.property
    @pulumi.getter(name="tokenExchanges")
    def token_exchanges(self) -> Sequence['outputs.GetClientsClientTokenExchangeResult']:
        """
        Allows configuration for token exchange
        """
        return pulumi.get(self, "token_exchanges")

    @_builtins.property
    @pulumi.getter(name="tokenQuotas")
    def token_quotas(self) -> Sequence['outputs.GetClientsClientTokenQuotaResult']:
        """
        The token quota configuration.
        """
        return pulumi.get(self, "token_quotas")

    @_builtins.property
    @pulumi.getter(name="webOrigins")
    def web_origins(self) -> Sequence[_builtins.str]:
        """
        URLs that represent valid web origins for use with web message response mode.
        """
        return pulumi.get(self, "web_origins")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The ID of the client. If not provided, `name` must be set.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the client. If not provided, `client_id` must be set.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClientsClientOidcLogoutResult(dict):
    def __init__(__self__, *,
                 backchannel_logout_initiators: Sequence['outputs.GetClientsClientOidcLogoutBackchannelLogoutInitiatorResult'],
                 backchannel_logout_urls: Sequence[_builtins.str]):
        """
        :param Sequence['GetClientsClientOidcLogoutBackchannelLogoutInitiatorArgs'] backchannel_logout_initiators: Configure OIDC logout initiators for the Client
        :param Sequence[_builtins.str] backchannel_logout_urls: Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        """
        pulumi.set(__self__, "backchannel_logout_initiators", backchannel_logout_initiators)
        pulumi.set(__self__, "backchannel_logout_urls", backchannel_logout_urls)

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutInitiators")
    def backchannel_logout_initiators(self) -> Sequence['outputs.GetClientsClientOidcLogoutBackchannelLogoutInitiatorResult']:
        """
        Configure OIDC logout initiators for the Client
        """
        return pulumi.get(self, "backchannel_logout_initiators")

    @_builtins.property
    @pulumi.getter(name="backchannelLogoutUrls")
    def backchannel_logout_urls(self) -> Sequence[_builtins.str]:
        """
        Set of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
        """
        return pulumi.get(self, "backchannel_logout_urls")


@pulumi.output_type
class GetClientsClientOidcLogoutBackchannelLogoutInitiatorResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 selected_initiators: Sequence[_builtins.str]):
        """
        :param _builtins.str mode: Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel_logout_selected_initiators set, `all` enables all current and future initiators.
        :param Sequence[_builtins.str] selected_initiators: Contains the list of initiators to be enabled for the given client.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "selected_initiators", selected_initiators)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the backchannel_logout_selected_initiators set, `all` enables all current and future initiators.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="selectedInitiators")
    def selected_initiators(self) -> Sequence[_builtins.str]:
        """
        Contains the list of initiators to be enabled for the given client.
        """
        return pulumi.get(self, "selected_initiators")


@pulumi.output_type
class GetClientsClientSessionTransferResult(dict):
    def __init__(__self__, *,
                 allow_refresh_token: _builtins.bool,
                 allowed_authentication_methods: Sequence[_builtins.str],
                 can_create_session_transfer_token: _builtins.bool,
                 enforce_device_binding: _builtins.str):
        """
        :param _builtins.bool allow_refresh_token: Indicates whether the application is allowed to use a refresh token when using a session_transfer_token session.
        :param _builtins.bool can_create_session_transfer_token: Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session_transfer_token
        :param _builtins.str enforce_device_binding: Configures the level of device binding enforced when a session_transfer_token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        pulumi.set(__self__, "allow_refresh_token", allow_refresh_token)
        pulumi.set(__self__, "allowed_authentication_methods", allowed_authentication_methods)
        pulumi.set(__self__, "can_create_session_transfer_token", can_create_session_transfer_token)
        pulumi.set(__self__, "enforce_device_binding", enforce_device_binding)

    @_builtins.property
    @pulumi.getter(name="allowRefreshToken")
    def allow_refresh_token(self) -> _builtins.bool:
        """
        Indicates whether the application is allowed to use a refresh token when using a session_transfer_token session.
        """
        return pulumi.get(self, "allow_refresh_token")

    @_builtins.property
    @pulumi.getter(name="allowedAuthenticationMethods")
    def allowed_authentication_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_authentication_methods")

    @_builtins.property
    @pulumi.getter(name="canCreateSessionTransferToken")
    def can_create_session_transfer_token(self) -> _builtins.bool:
        """
        Indicates whether the application(Native app) can use the Token Exchange endpoint to create a session_transfer_token
        """
        return pulumi.get(self, "can_create_session_transfer_token")

    @_builtins.property
    @pulumi.getter(name="enforceDeviceBinding")
    def enforce_device_binding(self) -> _builtins.str:
        """
        Configures the level of device binding enforced when a session_transfer_token is consumed. Can be one of `ip`, `asn` or `none`.
        """
        return pulumi.get(self, "enforce_device_binding")


@pulumi.output_type
class GetClientsClientTokenExchangeResult(dict):
    def __init__(__self__, *,
                 allow_any_profile_of_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allow_any_profile_of_types: List of allowed profile types for token exchange
        """
        pulumi.set(__self__, "allow_any_profile_of_types", allow_any_profile_of_types)

    @_builtins.property
    @pulumi.getter(name="allowAnyProfileOfTypes")
    def allow_any_profile_of_types(self) -> Sequence[_builtins.str]:
        """
        List of allowed profile types for token exchange
        """
        return pulumi.get(self, "allow_any_profile_of_types")


@pulumi.output_type
class GetClientsClientTokenQuotaResult(dict):
    def __init__(__self__, *,
                 client_credentials: Sequence['outputs.GetClientsClientTokenQuotaClientCredentialResult']):
        """
        :param Sequence['GetClientsClientTokenQuotaClientCredentialArgs'] client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Sequence['outputs.GetClientsClientTokenQuotaClientCredentialResult']:
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class GetClientsClientTokenQuotaClientCredentialResult(dict):
    def __init__(__self__, *,
                 enforce: _builtins.bool,
                 per_day: _builtins.int,
                 per_hour: _builtins.int):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        pulumi.set(__self__, "enforce", enforce)
        pulumi.set(__self__, "per_day", per_day)
        pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> _builtins.bool:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> _builtins.int:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> _builtins.int:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class GetConnectionKeysKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 cert: _builtins.str,
                 connection_id: _builtins.str,
                 current: _builtins.bool,
                 current_since: _builtins.str,
                 fingerprint: _builtins.str,
                 key_use: _builtins.str,
                 kid: _builtins.str,
                 next: _builtins.bool,
                 pkcs: _builtins.str,
                 previous: _builtins.bool,
                 subject_dn: _builtins.str,
                 thumbprint: _builtins.str,
                 triggers: Mapping[str, _builtins.str]):
        """
        :param _builtins.str algorithm: The signing key algorithm.
        :param _builtins.str cert: The public certificate of the signing key.
        :param _builtins.bool current: True if the key is the current key.
        :param _builtins.str current_since: The date and time when the key became the current key.
        :param _builtins.str fingerprint: The certificate fingerprint.
        :param _builtins.str key_use: The signing key use, whether for encryption or signing.
        :param _builtins.str kid: The key ID of the signing key.
        :param _builtins.bool next: True if the key is the next key.
        :param _builtins.str pkcs: The public certificate of the signing key in PKCS7 format.
        :param _builtins.bool previous: True if the key is the previous key.
        :param _builtins.str subject_dn: The subject distinguished name (DN) of the certificate.
        :param _builtins.str thumbprint: The certificate thumbprint.
        :param Mapping[str, _builtins.str] triggers: This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "current", current)
        pulumi.set(__self__, "current_since", current_since)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "key_use", key_use)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "pkcs", pkcs)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "subject_dn", subject_dn)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        The signing key algorithm.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        """
        The public certificate of the signing key.
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter
    def current(self) -> _builtins.bool:
        """
        True if the key is the current key.
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter(name="currentSince")
    def current_since(self) -> _builtins.str:
        """
        The date and time when the key became the current key.
        """
        return pulumi.get(self, "current_since")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The certificate fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter(name="keyUse")
    def key_use(self) -> _builtins.str:
        """
        The signing key use, whether for encryption or signing.
        """
        return pulumi.get(self, "key_use")

    @_builtins.property
    @pulumi.getter
    def kid(self) -> _builtins.str:
        """
        The key ID of the signing key.
        """
        return pulumi.get(self, "kid")

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.bool:
        """
        True if the key is the next key.
        """
        return pulumi.get(self, "next")

    @_builtins.property
    @pulumi.getter
    def pkcs(self) -> _builtins.str:
        """
        The public certificate of the signing key in PKCS7 format.
        """
        return pulumi.get(self, "pkcs")

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.bool:
        """
        True if the key is the previous key.
        """
        return pulumi.get(self, "previous")

    @_builtins.property
    @pulumi.getter(name="subjectDn")
    def subject_dn(self) -> _builtins.str:
        """
        The subject distinguished name (DN) of the certificate.
        """
        return pulumi.get(self, "subject_dn")

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> _builtins.str:
        """
        The certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Mapping[str, _builtins.str]:
        """
        This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetConnectionOptionResult(dict):
    def __init__(__self__, *,
                 adfs_server: _builtins.str,
                 allowed_audiences: Sequence[_builtins.str],
                 api_enable_users: _builtins.bool,
                 app_id: _builtins.str,
                 attribute_maps: Sequence['outputs.GetConnectionOptionAttributeMapResult'],
                 attributes: Sequence['outputs.GetConnectionOptionAttributeResult'],
                 auth_params: Mapping[str, _builtins.str],
                 authentication_methods: Sequence['outputs.GetConnectionOptionAuthenticationMethodResult'],
                 authorization_endpoint: _builtins.str,
                 brute_force_protection: _builtins.bool,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 community_base_url: _builtins.str,
                 configuration: Mapping[str, _builtins.str],
                 connection_settings: Sequence['outputs.GetConnectionOptionConnectionSettingResult'],
                 custom_headers: Sequence['outputs.GetConnectionOptionCustomHeaderResult'],
                 custom_scripts: Mapping[str, _builtins.str],
                 debug: _builtins.bool,
                 decryption_keys: Sequence['outputs.GetConnectionOptionDecryptionKeyResult'],
                 digest_algorithm: _builtins.str,
                 disable_cache: _builtins.bool,
                 disable_self_service_change_password: _builtins.bool,
                 disable_sign_out: _builtins.bool,
                 disable_signup: _builtins.bool,
                 discovery_url: _builtins.str,
                 domain: _builtins.str,
                 domain_aliases: Sequence[_builtins.str],
                 enable_script_context: _builtins.bool,
                 enabled_database_customization: _builtins.bool,
                 entity_id: _builtins.str,
                 fed_metadata_xml: _builtins.str,
                 fields_map: _builtins.str,
                 forward_request_info: _builtins.bool,
                 from_: _builtins.str,
                 gateway_authentications: Sequence['outputs.GetConnectionOptionGatewayAuthenticationResult'],
                 gateway_url: _builtins.str,
                 global_token_revocation_jwt_iss: _builtins.str,
                 global_token_revocation_jwt_sub: _builtins.str,
                 icon_url: _builtins.str,
                 identity_api: _builtins.str,
                 idp_initiateds: Sequence['outputs.GetConnectionOptionIdpInitiatedResult'],
                 import_mode: _builtins.bool,
                 ips: Sequence[_builtins.str],
                 issuer: _builtins.str,
                 jwks_uri: _builtins.str,
                 key_id: _builtins.str,
                 map_user_id_to_id: _builtins.bool,
                 max_groups_to_retrieve: _builtins.str,
                 messaging_service_sid: _builtins.str,
                 metadata_url: _builtins.str,
                 metadata_xml: _builtins.str,
                 mfas: Sequence['outputs.GetConnectionOptionMfaResult'],
                 name: _builtins.str,
                 non_persistent_attrs: Sequence[_builtins.str],
                 passkey_options: Sequence['outputs.GetConnectionOptionPasskeyOptionResult'],
                 password_complexity_options: Sequence['outputs.GetConnectionOptionPasswordComplexityOptionResult'],
                 password_dictionaries: Sequence['outputs.GetConnectionOptionPasswordDictionaryResult'],
                 password_histories: Sequence['outputs.GetConnectionOptionPasswordHistoryResult'],
                 password_no_personal_infos: Sequence['outputs.GetConnectionOptionPasswordNoPersonalInfoResult'],
                 password_policy: _builtins.str,
                 ping_federate_base_url: _builtins.str,
                 pkce_enabled: _builtins.bool,
                 precedences: Sequence[_builtins.str],
                 protocol_binding: _builtins.str,
                 provider: _builtins.str,
                 realm_fallback: _builtins.bool,
                 request_template: _builtins.str,
                 requires_username: _builtins.bool,
                 scopes: Sequence[_builtins.str],
                 scripts: Mapping[str, _builtins.str],
                 set_user_root_attributes: _builtins.str,
                 should_trust_email_verified_connection: _builtins.str,
                 sign_in_endpoint: _builtins.str,
                 sign_out_endpoint: _builtins.str,
                 sign_saml_request: _builtins.bool,
                 signature_algorithm: _builtins.str,
                 signing_cert: _builtins.str,
                 signing_keys: Sequence['outputs.GetConnectionOptionSigningKeyResult'],
                 strategy_version: _builtins.int,
                 subject: _builtins.str,
                 syntax: _builtins.str,
                 team_id: _builtins.str,
                 template: _builtins.str,
                 tenant_domain: _builtins.str,
                 token_endpoint: _builtins.str,
                 token_endpoint_auth_method: _builtins.str,
                 token_endpoint_auth_signing_alg: _builtins.str,
                 totps: Sequence['outputs.GetConnectionOptionTotpResult'],
                 twilio_sid: _builtins.str,
                 twilio_token: _builtins.str,
                 type: _builtins.str,
                 upstream_params: _builtins.str,
                 use_cert_auth: _builtins.bool,
                 use_kerberos: _builtins.bool,
                 use_wsfed: _builtins.bool,
                 user_id_attribute: _builtins.str,
                 userinfo_endpoint: _builtins.str,
                 validations: Sequence['outputs.GetConnectionOptionValidationResult'],
                 waad_common_endpoint: _builtins.bool,
                 waad_protocol: _builtins.str):
        """
        :param _builtins.str adfs_server: ADFS URL where to fetch the metadata source.
        :param Sequence[_builtins.str] allowed_audiences: List of allowed audiences.
        :param _builtins.bool api_enable_users: Enable API Access to users.
        :param _builtins.str app_id: App ID.
        :param Sequence['GetConnectionOptionAttributeMapArgs'] attribute_maps: OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        :param Sequence['GetConnectionOptionAttributeArgs'] attributes: Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
        :param Mapping[str, _builtins.str] auth_params: Query string parameters to be included as part of the generated passwordless email link.
        :param Sequence['GetConnectionOptionAuthenticationMethodArgs'] authentication_methods: Specifies the authentication methods and their configuration (enabled or disabled)
        :param _builtins.str authorization_endpoint: Authorization endpoint.
        :param _builtins.bool brute_force_protection: Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        :param _builtins.str client_id: The strategy's client ID.
        :param _builtins.str client_secret: The strategy's client secret.
        :param _builtins.str community_base_url: Salesforce community base URL.
        :param Mapping[str, _builtins.str] configuration: A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        :param Sequence['GetConnectionOptionConnectionSettingArgs'] connection_settings: Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        :param Sequence['GetConnectionOptionCustomHeaderArgs'] custom_headers: Configure extra headers to the Token endpoint of an OAuth 2.0 provider
        :param Mapping[str, _builtins.str] custom_scripts: A map of scripts used to integrate with a custom database.
        :param _builtins.bool debug: When enabled, additional debug information will be generated.
        :param Sequence['GetConnectionOptionDecryptionKeyArgs'] decryption_keys: The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param _builtins.str digest_algorithm: Sign Request Algorithm Digest.
        :param _builtins.bool disable_cache: Indicates whether to disable the cache or not.
        :param _builtins.bool disable_self_service_change_password: Indicates whether to remove the forgot password link within the New Universal Login.
        :param _builtins.bool disable_sign_out: When enabled, will disable sign out.
        :param _builtins.bool disable_signup: Indicates whether to allow user sign-ups to your application.
        :param _builtins.str discovery_url: OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        :param _builtins.str domain: Domain name.
        :param Sequence[_builtins.str] domain_aliases: List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        :param _builtins.bool enable_script_context: Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        :param _builtins.bool enabled_database_customization: Set to `true` to use a legacy user store.
        :param _builtins.str entity_id: Custom Entity ID for the connection.
        :param _builtins.str fed_metadata_xml: Federation Metadata for the ADFS connection.
        :param _builtins.str fields_map: If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        :param _builtins.bool forward_request_info: Specifies whether or not request info should be forwarded to sms gateway.
        :param _builtins.str from_: Address to use as the sender.
        :param Sequence['GetConnectionOptionGatewayAuthenticationArgs'] gateway_authentications: Defines the parameters used to generate the auth token for the custom gateway.
        :param _builtins.str gateway_url: Defines a custom sms gateway to use instead of Twilio.
        :param _builtins.str global_token_revocation_jwt_iss: Specifies the issuer of the JWT used for global token revocation for the SAML connection.
        :param _builtins.str global_token_revocation_jwt_sub: Specifies the subject of the JWT used for global token revocation for the SAML connection.
        :param _builtins.str icon_url: Icon URL.
        :param _builtins.str identity_api: Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        :param Sequence['GetConnectionOptionIdpInitiatedArgs'] idp_initiateds: Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        :param _builtins.bool import_mode: Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        :param Sequence[_builtins.str] ips: A list of IPs.
        :param _builtins.str issuer: Issuer URL, e.g. `https://auth.example.com`.
        :param _builtins.str jwks_uri: JWKS URI.
        :param _builtins.str key_id: Apple Key ID.
        :param _builtins.bool map_user_id_to_id: By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        :param _builtins.str max_groups_to_retrieve: Maximum number of groups to retrieve.
        :param _builtins.str messaging_service_sid: SID for Copilot. Used when SMS Source is Copilot.
        :param _builtins.str metadata_url: The URL of the SAML metadata document.
        :param _builtins.str metadata_xml: The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        :param Sequence['GetConnectionOptionMfaArgs'] mfas: Configuration options for multifactor authentication.
        :param _builtins.str name: The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        :param Sequence[_builtins.str] non_persistent_attrs: If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        :param Sequence['GetConnectionOptionPasskeyOptionArgs'] passkey_options: Defines options for the passkey authentication method
        :param Sequence['GetConnectionOptionPasswordComplexityOptionArgs'] password_complexity_options: Configuration settings for password complexity.
        :param Sequence['GetConnectionOptionPasswordDictionaryArgs'] password_dictionaries: Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        :param Sequence['GetConnectionOptionPasswordHistoryArgs'] password_histories: Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        :param Sequence['GetConnectionOptionPasswordNoPersonalInfoArgs'] password_no_personal_infos: Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        :param _builtins.str password_policy: Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        :param _builtins.str ping_federate_base_url: Ping Federate Server URL.
        :param _builtins.bool pkce_enabled: Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        :param Sequence[_builtins.str] precedences: Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
        :param _builtins.str protocol_binding: The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        :param _builtins.str provider: Defines the custom `sms_gateway` provider.
        :param _builtins.bool realm_fallback: Allows configuration if connections_realm_fallback flag is enabled for the tenant
        :param _builtins.str request_template: Template that formats the SAML request.
        :param _builtins.bool requires_username: Indicates whether the user is required to provide a username in addition to an email address.
        :param Sequence[_builtins.str] scopes: Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        :param Mapping[str, _builtins.str] scripts: A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        :param _builtins.str set_user_root_attributes: Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
        :param _builtins.str should_trust_email_verified_connection: Choose how Auth0 sets the email_verified field in the user profile.
        :param _builtins.str sign_in_endpoint: SAML single login URL for the connection.
        :param _builtins.str sign_out_endpoint: SAML single logout URL for the connection.
        :param _builtins.bool sign_saml_request: When enabled, the SAML authentication request will be signed.
        :param _builtins.str signature_algorithm: Sign Request Algorithm.
        :param _builtins.str signing_cert: X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        :param Sequence['GetConnectionOptionSigningKeyArgs'] signing_keys: The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param _builtins.int strategy_version: Version 1 is deprecated, use version 2.
        :param _builtins.str subject: Subject line of the email.
        :param _builtins.str syntax: Syntax of the template body.
        :param _builtins.str team_id: Apple Team ID.
        :param _builtins.str template: Body of the template.
        :param _builtins.str tenant_domain: Tenant domain name.
        :param _builtins.str token_endpoint: Token endpoint.
        :param _builtins.str token_endpoint_auth_method: Specifies the authentication method for the token endpoint. (Okta/OIDC Connections)
        :param _builtins.str token_endpoint_auth_signing_alg: Specifies the signing algorithm for the token endpoint. (Okta/OIDC Connections)
        :param Sequence['GetConnectionOptionTotpArgs'] totps: Configuration options for one-time passwords.
        :param _builtins.str twilio_sid: SID for your Twilio account.
        :param _builtins.str twilio_token: AuthToken for your Twilio account.
        :param _builtins.str type: Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        :param _builtins.str upstream_params: You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        :param _builtins.bool use_cert_auth: Indicates whether to use cert auth or not.
        :param _builtins.bool use_kerberos: Indicates whether to use Kerberos or not.
        :param _builtins.bool use_wsfed: Whether to use WS-Fed.
        :param _builtins.str user_id_attribute: Attribute in the token that will be mapped to the user_id property in Auth0.
        :param _builtins.str userinfo_endpoint: User info endpoint.
        :param Sequence['GetConnectionOptionValidationArgs'] validations: Validation of the minimum and maximum values allowed for a user to have as username.
        :param _builtins.bool waad_common_endpoint: Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        :param _builtins.str waad_protocol: Protocol to use.
        """
        pulumi.set(__self__, "adfs_server", adfs_server)
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "api_enable_users", api_enable_users)
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "attribute_maps", attribute_maps)
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "auth_params", auth_params)
        pulumi.set(__self__, "authentication_methods", authentication_methods)
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "brute_force_protection", brute_force_protection)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "community_base_url", community_base_url)
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "connection_settings", connection_settings)
        pulumi.set(__self__, "custom_headers", custom_headers)
        pulumi.set(__self__, "custom_scripts", custom_scripts)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "decryption_keys", decryption_keys)
        pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        pulumi.set(__self__, "disable_cache", disable_cache)
        pulumi.set(__self__, "disable_self_service_change_password", disable_self_service_change_password)
        pulumi.set(__self__, "disable_sign_out", disable_sign_out)
        pulumi.set(__self__, "disable_signup", disable_signup)
        pulumi.set(__self__, "discovery_url", discovery_url)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "domain_aliases", domain_aliases)
        pulumi.set(__self__, "enable_script_context", enable_script_context)
        pulumi.set(__self__, "enabled_database_customization", enabled_database_customization)
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "fed_metadata_xml", fed_metadata_xml)
        pulumi.set(__self__, "fields_map", fields_map)
        pulumi.set(__self__, "forward_request_info", forward_request_info)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "gateway_authentications", gateway_authentications)
        pulumi.set(__self__, "gateway_url", gateway_url)
        pulumi.set(__self__, "global_token_revocation_jwt_iss", global_token_revocation_jwt_iss)
        pulumi.set(__self__, "global_token_revocation_jwt_sub", global_token_revocation_jwt_sub)
        pulumi.set(__self__, "icon_url", icon_url)
        pulumi.set(__self__, "identity_api", identity_api)
        pulumi.set(__self__, "idp_initiateds", idp_initiateds)
        pulumi.set(__self__, "import_mode", import_mode)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "jwks_uri", jwks_uri)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "map_user_id_to_id", map_user_id_to_id)
        pulumi.set(__self__, "max_groups_to_retrieve", max_groups_to_retrieve)
        pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        pulumi.set(__self__, "metadata_url", metadata_url)
        pulumi.set(__self__, "metadata_xml", metadata_xml)
        pulumi.set(__self__, "mfas", mfas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "non_persistent_attrs", non_persistent_attrs)
        pulumi.set(__self__, "passkey_options", passkey_options)
        pulumi.set(__self__, "password_complexity_options", password_complexity_options)
        pulumi.set(__self__, "password_dictionaries", password_dictionaries)
        pulumi.set(__self__, "password_histories", password_histories)
        pulumi.set(__self__, "password_no_personal_infos", password_no_personal_infos)
        pulumi.set(__self__, "password_policy", password_policy)
        pulumi.set(__self__, "ping_federate_base_url", ping_federate_base_url)
        pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        pulumi.set(__self__, "precedences", precedences)
        pulumi.set(__self__, "protocol_binding", protocol_binding)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "realm_fallback", realm_fallback)
        pulumi.set(__self__, "request_template", request_template)
        pulumi.set(__self__, "requires_username", requires_username)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "scripts", scripts)
        pulumi.set(__self__, "set_user_root_attributes", set_user_root_attributes)
        pulumi.set(__self__, "should_trust_email_verified_connection", should_trust_email_verified_connection)
        pulumi.set(__self__, "sign_in_endpoint", sign_in_endpoint)
        pulumi.set(__self__, "sign_out_endpoint", sign_out_endpoint)
        pulumi.set(__self__, "sign_saml_request", sign_saml_request)
        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        pulumi.set(__self__, "signing_cert", signing_cert)
        pulumi.set(__self__, "signing_keys", signing_keys)
        pulumi.set(__self__, "strategy_version", strategy_version)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "syntax", syntax)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "tenant_domain", tenant_domain)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)
        pulumi.set(__self__, "token_endpoint_auth_signing_alg", token_endpoint_auth_signing_alg)
        pulumi.set(__self__, "totps", totps)
        pulumi.set(__self__, "twilio_sid", twilio_sid)
        pulumi.set(__self__, "twilio_token", twilio_token)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upstream_params", upstream_params)
        pulumi.set(__self__, "use_cert_auth", use_cert_auth)
        pulumi.set(__self__, "use_kerberos", use_kerberos)
        pulumi.set(__self__, "use_wsfed", use_wsfed)
        pulumi.set(__self__, "user_id_attribute", user_id_attribute)
        pulumi.set(__self__, "userinfo_endpoint", userinfo_endpoint)
        pulumi.set(__self__, "validations", validations)
        pulumi.set(__self__, "waad_common_endpoint", waad_common_endpoint)
        pulumi.set(__self__, "waad_protocol", waad_protocol)

    @_builtins.property
    @pulumi.getter(name="adfsServer")
    def adfs_server(self) -> _builtins.str:
        """
        ADFS URL where to fetch the metadata source.
        """
        return pulumi.get(self, "adfs_server")

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[_builtins.str]:
        """
        List of allowed audiences.
        """
        return pulumi.get(self, "allowed_audiences")

    @_builtins.property
    @pulumi.getter(name="apiEnableUsers")
    def api_enable_users(self) -> _builtins.bool:
        """
        Enable API Access to users.
        """
        return pulumi.get(self, "api_enable_users")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        App ID.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="attributeMaps")
    def attribute_maps(self) -> Sequence['outputs.GetConnectionOptionAttributeMapResult']:
        """
        OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        """
        return pulumi.get(self, "attribute_maps")

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Sequence['outputs.GetConnectionOptionAttributeResult']:
        """
        Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="authParams")
    def auth_params(self) -> Mapping[str, _builtins.str]:
        """
        Query string parameters to be included as part of the generated passwordless email link.
        """
        return pulumi.get(self, "auth_params")

    @_builtins.property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> Sequence['outputs.GetConnectionOptionAuthenticationMethodResult']:
        """
        Specifies the authentication methods and their configuration (enabled or disabled)
        """
        return pulumi.get(self, "authentication_methods")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> _builtins.str:
        """
        Authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="bruteForceProtection")
    def brute_force_protection(self) -> _builtins.bool:
        """
        Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        """
        return pulumi.get(self, "brute_force_protection")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The strategy's client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The strategy's client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="communityBaseUrl")
    def community_base_url(self) -> _builtins.str:
        """
        Salesforce community base URL.
        """
        return pulumi.get(self, "community_base_url")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Mapping[str, _builtins.str]:
        """
        A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="connectionSettings")
    def connection_settings(self) -> Sequence['outputs.GetConnectionOptionConnectionSettingResult']:
        """
        Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        """
        return pulumi.get(self, "connection_settings")

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Sequence['outputs.GetConnectionOptionCustomHeaderResult']:
        """
        Configure extra headers to the Token endpoint of an OAuth 2.0 provider
        """
        return pulumi.get(self, "custom_headers")

    @_builtins.property
    @pulumi.getter(name="customScripts")
    def custom_scripts(self) -> Mapping[str, _builtins.str]:
        """
        A map of scripts used to integrate with a custom database.
        """
        return pulumi.get(self, "custom_scripts")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> _builtins.bool:
        """
        When enabled, additional debug information will be generated.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="decryptionKeys")
    def decryption_keys(self) -> Sequence['outputs.GetConnectionOptionDecryptionKeyResult']:
        """
        The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "decryption_keys")

    @_builtins.property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> _builtins.str:
        """
        Sign Request Algorithm Digest.
        """
        return pulumi.get(self, "digest_algorithm")

    @_builtins.property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> _builtins.bool:
        """
        Indicates whether to disable the cache or not.
        """
        return pulumi.get(self, "disable_cache")

    @_builtins.property
    @pulumi.getter(name="disableSelfServiceChangePassword")
    def disable_self_service_change_password(self) -> _builtins.bool:
        """
        Indicates whether to remove the forgot password link within the New Universal Login.
        """
        return pulumi.get(self, "disable_self_service_change_password")

    @_builtins.property
    @pulumi.getter(name="disableSignOut")
    def disable_sign_out(self) -> _builtins.bool:
        """
        When enabled, will disable sign out.
        """
        return pulumi.get(self, "disable_sign_out")

    @_builtins.property
    @pulumi.getter(name="disableSignup")
    def disable_signup(self) -> _builtins.bool:
        """
        Indicates whether to allow user sign-ups to your application.
        """
        return pulumi.get(self, "disable_signup")

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> _builtins.str:
        """
        OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        """
        return pulumi.get(self, "discovery_url")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="domainAliases")
    def domain_aliases(self) -> Sequence[_builtins.str]:
        """
        List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        """
        return pulumi.get(self, "domain_aliases")

    @_builtins.property
    @pulumi.getter(name="enableScriptContext")
    def enable_script_context(self) -> _builtins.bool:
        """
        Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        """
        return pulumi.get(self, "enable_script_context")

    @_builtins.property
    @pulumi.getter(name="enabledDatabaseCustomization")
    def enabled_database_customization(self) -> _builtins.bool:
        """
        Set to `true` to use a legacy user store.
        """
        return pulumi.get(self, "enabled_database_customization")

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> _builtins.str:
        """
        Custom Entity ID for the connection.
        """
        return pulumi.get(self, "entity_id")

    @_builtins.property
    @pulumi.getter(name="fedMetadataXml")
    def fed_metadata_xml(self) -> _builtins.str:
        """
        Federation Metadata for the ADFS connection.
        """
        return pulumi.get(self, "fed_metadata_xml")

    @_builtins.property
    @pulumi.getter(name="fieldsMap")
    def fields_map(self) -> _builtins.str:
        """
        If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        """
        return pulumi.get(self, "fields_map")

    @_builtins.property
    @pulumi.getter(name="forwardRequestInfo")
    def forward_request_info(self) -> _builtins.bool:
        """
        Specifies whether or not request info should be forwarded to sms gateway.
        """
        return pulumi.get(self, "forward_request_info")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        Address to use as the sender.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter(name="gatewayAuthentications")
    def gateway_authentications(self) -> Sequence['outputs.GetConnectionOptionGatewayAuthenticationResult']:
        """
        Defines the parameters used to generate the auth token for the custom gateway.
        """
        return pulumi.get(self, "gateway_authentications")

    @_builtins.property
    @pulumi.getter(name="gatewayUrl")
    def gateway_url(self) -> _builtins.str:
        """
        Defines a custom sms gateway to use instead of Twilio.
        """
        return pulumi.get(self, "gateway_url")

    @_builtins.property
    @pulumi.getter(name="globalTokenRevocationJwtIss")
    def global_token_revocation_jwt_iss(self) -> _builtins.str:
        """
        Specifies the issuer of the JWT used for global token revocation for the SAML connection.
        """
        return pulumi.get(self, "global_token_revocation_jwt_iss")

    @_builtins.property
    @pulumi.getter(name="globalTokenRevocationJwtSub")
    def global_token_revocation_jwt_sub(self) -> _builtins.str:
        """
        Specifies the subject of the JWT used for global token revocation for the SAML connection.
        """
        return pulumi.get(self, "global_token_revocation_jwt_sub")

    @_builtins.property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> _builtins.str:
        """
        Icon URL.
        """
        return pulumi.get(self, "icon_url")

    @_builtins.property
    @pulumi.getter(name="identityApi")
    def identity_api(self) -> _builtins.str:
        """
        Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        """
        return pulumi.get(self, "identity_api")

    @_builtins.property
    @pulumi.getter(name="idpInitiateds")
    def idp_initiateds(self) -> Sequence['outputs.GetConnectionOptionIdpInitiatedResult']:
        """
        Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        """
        return pulumi.get(self, "idp_initiateds")

    @_builtins.property
    @pulumi.getter(name="importMode")
    def import_mode(self) -> _builtins.bool:
        """
        Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        """
        return pulumi.get(self, "import_mode")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        A list of IPs.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        Issuer URL, e.g. `https://auth.example.com`.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> _builtins.str:
        """
        JWKS URI.
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        Apple Key ID.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="mapUserIdToId")
    def map_user_id_to_id(self) -> _builtins.bool:
        """
        By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        """
        return pulumi.get(self, "map_user_id_to_id")

    @_builtins.property
    @pulumi.getter(name="maxGroupsToRetrieve")
    def max_groups_to_retrieve(self) -> _builtins.str:
        """
        Maximum number of groups to retrieve.
        """
        return pulumi.get(self, "max_groups_to_retrieve")

    @_builtins.property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> _builtins.str:
        """
        SID for Copilot. Used when SMS Source is Copilot.
        """
        return pulumi.get(self, "messaging_service_sid")

    @_builtins.property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> _builtins.str:
        """
        The URL of the SAML metadata document.
        """
        return pulumi.get(self, "metadata_url")

    @_builtins.property
    @pulumi.getter(name="metadataXml")
    def metadata_xml(self) -> _builtins.str:
        """
        The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        """
        return pulumi.get(self, "metadata_xml")

    @_builtins.property
    @pulumi.getter
    def mfas(self) -> Sequence['outputs.GetConnectionOptionMfaResult']:
        """
        Configuration options for multifactor authentication.
        """
        return pulumi.get(self, "mfas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonPersistentAttrs")
    def non_persistent_attrs(self) -> Sequence[_builtins.str]:
        """
        If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        """
        return pulumi.get(self, "non_persistent_attrs")

    @_builtins.property
    @pulumi.getter(name="passkeyOptions")
    def passkey_options(self) -> Sequence['outputs.GetConnectionOptionPasskeyOptionResult']:
        """
        Defines options for the passkey authentication method
        """
        return pulumi.get(self, "passkey_options")

    @_builtins.property
    @pulumi.getter(name="passwordComplexityOptions")
    def password_complexity_options(self) -> Sequence['outputs.GetConnectionOptionPasswordComplexityOptionResult']:
        """
        Configuration settings for password complexity.
        """
        return pulumi.get(self, "password_complexity_options")

    @_builtins.property
    @pulumi.getter(name="passwordDictionaries")
    def password_dictionaries(self) -> Sequence['outputs.GetConnectionOptionPasswordDictionaryResult']:
        """
        Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        """
        return pulumi.get(self, "password_dictionaries")

    @_builtins.property
    @pulumi.getter(name="passwordHistories")
    def password_histories(self) -> Sequence['outputs.GetConnectionOptionPasswordHistoryResult']:
        """
        Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        """
        return pulumi.get(self, "password_histories")

    @_builtins.property
    @pulumi.getter(name="passwordNoPersonalInfos")
    def password_no_personal_infos(self) -> Sequence['outputs.GetConnectionOptionPasswordNoPersonalInfoResult']:
        """
        Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        """
        return pulumi.get(self, "password_no_personal_infos")

    @_builtins.property
    @pulumi.getter(name="passwordPolicy")
    def password_policy(self) -> _builtins.str:
        """
        Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        """
        return pulumi.get(self, "password_policy")

    @_builtins.property
    @pulumi.getter(name="pingFederateBaseUrl")
    def ping_federate_base_url(self) -> _builtins.str:
        """
        Ping Federate Server URL.
        """
        return pulumi.get(self, "ping_federate_base_url")

    @_builtins.property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> _builtins.bool:
        """
        Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        """
        return pulumi.get(self, "pkce_enabled")

    @_builtins.property
    @pulumi.getter
    def precedences(self) -> Sequence[_builtins.str]:
        """
        Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
        """
        return pulumi.get(self, "precedences")

    @_builtins.property
    @pulumi.getter(name="protocolBinding")
    def protocol_binding(self) -> _builtins.str:
        """
        The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        """
        return pulumi.get(self, "protocol_binding")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        Defines the custom `sms_gateway` provider.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="realmFallback")
    def realm_fallback(self) -> _builtins.bool:
        """
        Allows configuration if connections_realm_fallback flag is enabled for the tenant
        """
        return pulumi.get(self, "realm_fallback")

    @_builtins.property
    @pulumi.getter(name="requestTemplate")
    def request_template(self) -> _builtins.str:
        """
        Template that formats the SAML request.
        """
        return pulumi.get(self, "request_template")

    @_builtins.property
    @pulumi.getter(name="requiresUsername")
    def requires_username(self) -> _builtins.bool:
        """
        Indicates whether the user is required to provide a username in addition to an email address.
        """
        return pulumi.get(self, "requires_username")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def scripts(self) -> Mapping[str, _builtins.str]:
        """
        A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        """
        return pulumi.get(self, "scripts")

    @_builtins.property
    @pulumi.getter(name="setUserRootAttributes")
    def set_user_root_attributes(self) -> _builtins.str:
        """
        Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
        """
        return pulumi.get(self, "set_user_root_attributes")

    @_builtins.property
    @pulumi.getter(name="shouldTrustEmailVerifiedConnection")
    def should_trust_email_verified_connection(self) -> _builtins.str:
        """
        Choose how Auth0 sets the email_verified field in the user profile.
        """
        return pulumi.get(self, "should_trust_email_verified_connection")

    @_builtins.property
    @pulumi.getter(name="signInEndpoint")
    def sign_in_endpoint(self) -> _builtins.str:
        """
        SAML single login URL for the connection.
        """
        return pulumi.get(self, "sign_in_endpoint")

    @_builtins.property
    @pulumi.getter(name="signOutEndpoint")
    def sign_out_endpoint(self) -> _builtins.str:
        """
        SAML single logout URL for the connection.
        """
        return pulumi.get(self, "sign_out_endpoint")

    @_builtins.property
    @pulumi.getter(name="signSamlRequest")
    def sign_saml_request(self) -> _builtins.bool:
        """
        When enabled, the SAML authentication request will be signed.
        """
        return pulumi.get(self, "sign_saml_request")

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> _builtins.str:
        """
        Sign Request Algorithm.
        """
        return pulumi.get(self, "signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> _builtins.str:
        """
        X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        """
        return pulumi.get(self, "signing_cert")

    @_builtins.property
    @pulumi.getter(name="signingKeys")
    def signing_keys(self) -> Sequence['outputs.GetConnectionOptionSigningKeyResult']:
        """
        The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "signing_keys")

    @_builtins.property
    @pulumi.getter(name="strategyVersion")
    def strategy_version(self) -> _builtins.int:
        """
        Version 1 is deprecated, use version 2.
        """
        return pulumi.get(self, "strategy_version")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def syntax(self) -> _builtins.str:
        """
        Syntax of the template body.
        """
        return pulumi.get(self, "syntax")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        Apple Team ID.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        Body of the template.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="tenantDomain")
    def tenant_domain(self) -> _builtins.str:
        """
        Tenant domain name.
        """
        return pulumi.get(self, "tenant_domain")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> _builtins.str:
        """
        Token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> _builtins.str:
        """
        Specifies the authentication method for the token endpoint. (Okta/OIDC Connections)
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointAuthSigningAlg")
    def token_endpoint_auth_signing_alg(self) -> _builtins.str:
        """
        Specifies the signing algorithm for the token endpoint. (Okta/OIDC Connections)
        """
        return pulumi.get(self, "token_endpoint_auth_signing_alg")

    @_builtins.property
    @pulumi.getter
    def totps(self) -> Sequence['outputs.GetConnectionOptionTotpResult']:
        """
        Configuration options for one-time passwords.
        """
        return pulumi.get(self, "totps")

    @_builtins.property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> _builtins.str:
        """
        SID for your Twilio account.
        """
        return pulumi.get(self, "twilio_sid")

    @_builtins.property
    @pulumi.getter(name="twilioToken")
    def twilio_token(self) -> _builtins.str:
        """
        AuthToken for your Twilio account.
        """
        return pulumi.get(self, "twilio_token")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upstreamParams")
    def upstream_params(self) -> _builtins.str:
        """
        You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        """
        return pulumi.get(self, "upstream_params")

    @_builtins.property
    @pulumi.getter(name="useCertAuth")
    def use_cert_auth(self) -> _builtins.bool:
        """
        Indicates whether to use cert auth or not.
        """
        return pulumi.get(self, "use_cert_auth")

    @_builtins.property
    @pulumi.getter(name="useKerberos")
    def use_kerberos(self) -> _builtins.bool:
        """
        Indicates whether to use Kerberos or not.
        """
        return pulumi.get(self, "use_kerberos")

    @_builtins.property
    @pulumi.getter(name="useWsfed")
    def use_wsfed(self) -> _builtins.bool:
        """
        Whether to use WS-Fed.
        """
        return pulumi.get(self, "use_wsfed")

    @_builtins.property
    @pulumi.getter(name="userIdAttribute")
    def user_id_attribute(self) -> _builtins.str:
        """
        Attribute in the token that will be mapped to the user_id property in Auth0.
        """
        return pulumi.get(self, "user_id_attribute")

    @_builtins.property
    @pulumi.getter(name="userinfoEndpoint")
    def userinfo_endpoint(self) -> _builtins.str:
        """
        User info endpoint.
        """
        return pulumi.get(self, "userinfo_endpoint")

    @_builtins.property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetConnectionOptionValidationResult']:
        """
        Validation of the minimum and maximum values allowed for a user to have as username.
        """
        return pulumi.get(self, "validations")

    @_builtins.property
    @pulumi.getter(name="waadCommonEndpoint")
    def waad_common_endpoint(self) -> _builtins.bool:
        """
        Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        """
        return pulumi.get(self, "waad_common_endpoint")

    @_builtins.property
    @pulumi.getter(name="waadProtocol")
    def waad_protocol(self) -> _builtins.str:
        """
        Protocol to use.
        """
        return pulumi.get(self, "waad_protocol")


@pulumi.output_type
class GetConnectionOptionAttributeResult(dict):
    def __init__(__self__, *,
                 emails: Sequence['outputs.GetConnectionOptionAttributeEmailResult'],
                 phone_numbers: Sequence['outputs.GetConnectionOptionAttributePhoneNumberResult'],
                 usernames: Sequence['outputs.GetConnectionOptionAttributeUsernameResult']):
        """
        :param Sequence['GetConnectionOptionAttributeEmailArgs'] emails: Connection Options for Email Attribute
        :param Sequence['GetConnectionOptionAttributePhoneNumberArgs'] phone_numbers: Connection Options for Phone Number Attribute
        :param Sequence['GetConnectionOptionAttributeUsernameArgs'] usernames: Connection Options for User Name Attribute
        """
        pulumi.set(__self__, "emails", emails)
        pulumi.set(__self__, "phone_numbers", phone_numbers)
        pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Sequence['outputs.GetConnectionOptionAttributeEmailResult']:
        """
        Connection Options for Email Attribute
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Sequence['outputs.GetConnectionOptionAttributePhoneNumberResult']:
        """
        Connection Options for Phone Number Attribute
        """
        return pulumi.get(self, "phone_numbers")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Sequence['outputs.GetConnectionOptionAttributeUsernameResult']:
        """
        Connection Options for User Name Attribute
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetConnectionOptionAttributeEmailResult(dict):
    def __init__(__self__, *,
                 identifiers: Sequence['outputs.GetConnectionOptionAttributeEmailIdentifierResult'],
                 profile_required: _builtins.bool,
                 signups: Sequence['outputs.GetConnectionOptionAttributeEmailSignupResult'],
                 verification_method: _builtins.str):
        """
        :param Sequence['GetConnectionOptionAttributeEmailIdentifierArgs'] identifiers: Connection Options Email Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['GetConnectionOptionAttributeEmailSignupArgs'] signups: Defines signup settings for Email attribute
        :param _builtins.str verification_method: Defines whether whether user will receive a link or an OTP during user signup for email verification and password reset for email verification
        """
        pulumi.set(__self__, "identifiers", identifiers)
        pulumi.set(__self__, "profile_required", profile_required)
        pulumi.set(__self__, "signups", signups)
        pulumi.set(__self__, "verification_method", verification_method)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence['outputs.GetConnectionOptionAttributeEmailIdentifierResult']:
        """
        Connection Options Email Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> _builtins.bool:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Sequence['outputs.GetConnectionOptionAttributeEmailSignupResult']:
        """
        Defines signup settings for Email attribute
        """
        return pulumi.get(self, "signups")

    @_builtins.property
    @pulumi.getter(name="verificationMethod")
    def verification_method(self) -> _builtins.str:
        """
        Defines whether whether user will receive a link or an OTP during user signup for email verification and password reset for email verification
        """
        return pulumi.get(self, "verification_method")


@pulumi.output_type
class GetConnectionOptionAttributeEmailIdentifierResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool):
        """
        :param _builtins.bool active: Defines whether email attribute is active as an identifier
        """
        pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Defines whether email attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetConnectionOptionAttributeEmailSignupResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str,
                 verifications: Sequence['outputs.GetConnectionOptionAttributeEmailSignupVerificationResult']):
        """
        :param _builtins.str status: Defines signup status for Email Attribute
        :param Sequence['GetConnectionOptionAttributeEmailSignupVerificationArgs'] verifications: Defines settings for Verification under Email attribute
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "verifications", verifications)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Defines signup status for Email Attribute
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def verifications(self) -> Sequence['outputs.GetConnectionOptionAttributeEmailSignupVerificationResult']:
        """
        Defines settings for Verification under Email attribute
        """
        return pulumi.get(self, "verifications")


@pulumi.output_type
class GetConnectionOptionAttributeEmailSignupVerificationResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool):
        """
        :param _builtins.bool active: Defines verification settings for signup attribute
        """
        pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Defines verification settings for signup attribute
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetConnectionOptionAttributeMapResult(dict):
    def __init__(__self__, *,
                 attributes: _builtins.str,
                 mapping_mode: _builtins.str,
                 userinfo_scope: _builtins.str):
        """
        :param _builtins.str attributes: This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        :param _builtins.str mapping_mode: Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        :param _builtins.str userinfo_scope: This property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "mapping_mode", mapping_mode)
        pulumi.set(__self__, "userinfo_scope", userinfo_scope)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> _builtins.str:
        """
        This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="mappingMode")
    def mapping_mode(self) -> _builtins.str:
        """
        Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        """
        return pulumi.get(self, "mapping_mode")

    @_builtins.property
    @pulumi.getter(name="userinfoScope")
    def userinfo_scope(self) -> _builtins.str:
        """
        This property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.
        """
        return pulumi.get(self, "userinfo_scope")


@pulumi.output_type
class GetConnectionOptionAttributePhoneNumberResult(dict):
    def __init__(__self__, *,
                 identifiers: Sequence['outputs.GetConnectionOptionAttributePhoneNumberIdentifierResult'],
                 profile_required: _builtins.bool,
                 signups: Sequence['outputs.GetConnectionOptionAttributePhoneNumberSignupResult']):
        """
        :param Sequence['GetConnectionOptionAttributePhoneNumberIdentifierArgs'] identifiers: Connection Options Phone Number Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['GetConnectionOptionAttributePhoneNumberSignupArgs'] signups: Defines signup settings for Phone Number attribute
        """
        pulumi.set(__self__, "identifiers", identifiers)
        pulumi.set(__self__, "profile_required", profile_required)
        pulumi.set(__self__, "signups", signups)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence['outputs.GetConnectionOptionAttributePhoneNumberIdentifierResult']:
        """
        Connection Options Phone Number Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> _builtins.bool:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Sequence['outputs.GetConnectionOptionAttributePhoneNumberSignupResult']:
        """
        Defines signup settings for Phone Number attribute
        """
        return pulumi.get(self, "signups")


@pulumi.output_type
class GetConnectionOptionAttributePhoneNumberIdentifierResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool):
        """
        :param _builtins.bool active: Defines whether Phone Number attribute is active as an identifier
        """
        pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Defines whether Phone Number attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetConnectionOptionAttributePhoneNumberSignupResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str,
                 verifications: Sequence['outputs.GetConnectionOptionAttributePhoneNumberSignupVerificationResult']):
        """
        :param _builtins.str status: Defines status of signup for Phone Number attribute
        :param Sequence['GetConnectionOptionAttributePhoneNumberSignupVerificationArgs'] verifications: Defines verification settings for Phone Number attribute
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "verifications", verifications)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Defines status of signup for Phone Number attribute
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def verifications(self) -> Sequence['outputs.GetConnectionOptionAttributePhoneNumberSignupVerificationResult']:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "verifications")


@pulumi.output_type
class GetConnectionOptionAttributePhoneNumberSignupVerificationResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool):
        """
        :param _builtins.bool active: Defines verification settings for Phone Number attribute
        """
        pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetConnectionOptionAttributeUsernameResult(dict):
    def __init__(__self__, *,
                 identifiers: Sequence['outputs.GetConnectionOptionAttributeUsernameIdentifierResult'],
                 profile_required: _builtins.bool,
                 signups: Sequence['outputs.GetConnectionOptionAttributeUsernameSignupResult'],
                 validations: Sequence['outputs.GetConnectionOptionAttributeUsernameValidationResult']):
        """
        :param Sequence['GetConnectionOptionAttributeUsernameIdentifierArgs'] identifiers: Connection options for User Name Attribute Identifier
        :param _builtins.bool profile_required: Defines whether Profile is required
        :param Sequence['GetConnectionOptionAttributeUsernameSignupArgs'] signups: Defines signup settings for User Name attribute
        :param Sequence['GetConnectionOptionAttributeUsernameValidationArgs'] validations: Defines validation settings for User Name attribute
        """
        pulumi.set(__self__, "identifiers", identifiers)
        pulumi.set(__self__, "profile_required", profile_required)
        pulumi.set(__self__, "signups", signups)
        pulumi.set(__self__, "validations", validations)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence['outputs.GetConnectionOptionAttributeUsernameIdentifierResult']:
        """
        Connection options for User Name Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @_builtins.property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> _builtins.bool:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @_builtins.property
    @pulumi.getter
    def signups(self) -> Sequence['outputs.GetConnectionOptionAttributeUsernameSignupResult']:
        """
        Defines signup settings for User Name attribute
        """
        return pulumi.get(self, "signups")

    @_builtins.property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.GetConnectionOptionAttributeUsernameValidationResult']:
        """
        Defines validation settings for User Name attribute
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class GetConnectionOptionAttributeUsernameIdentifierResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool):
        """
        :param _builtins.bool active: Defines whether UserName attribute is active as an identifier
        """
        pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Defines whether UserName attribute is active as an identifier
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetConnectionOptionAttributeUsernameSignupResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: Defines whether User Name attribute is active as an identifier
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Defines whether User Name attribute is active as an identifier
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetConnectionOptionAttributeUsernameValidationResult(dict):
    def __init__(__self__, *,
                 allowed_types: Sequence['outputs.GetConnectionOptionAttributeUsernameValidationAllowedTypeResult'],
                 max_length: _builtins.int,
                 min_length: _builtins.int):
        """
        :param Sequence['GetConnectionOptionAttributeUsernameValidationAllowedTypeArgs'] allowed_types: Defines allowed types for for UserName attribute
        :param _builtins.int max_length: Defines Max Length for User Name attribute
        :param _builtins.int min_length: Defines Min Length for User Name attribute
        """
        pulumi.set(__self__, "allowed_types", allowed_types)
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="allowedTypes")
    def allowed_types(self) -> Sequence['outputs.GetConnectionOptionAttributeUsernameValidationAllowedTypeResult']:
        """
        Defines allowed types for for UserName attribute
        """
        return pulumi.get(self, "allowed_types")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> _builtins.int:
        """
        Defines Max Length for User Name attribute
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> _builtins.int:
        """
        Defines Min Length for User Name attribute
        """
        return pulumi.get(self, "min_length")


@pulumi.output_type
class GetConnectionOptionAttributeUsernameValidationAllowedTypeResult(dict):
    def __init__(__self__, *,
                 email: _builtins.bool,
                 phone_number: _builtins.bool):
        """
        :param _builtins.bool email: One of the allowed types for UserName signup attribute
        :param _builtins.bool phone_number: One of the allowed types for UserName signup attribute
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.bool:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> _builtins.bool:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetConnectionOptionAuthenticationMethodResult(dict):
    def __init__(__self__, *,
                 passkeys: Sequence['outputs.GetConnectionOptionAuthenticationMethodPasskeyResult'],
                 passwords: Sequence['outputs.GetConnectionOptionAuthenticationMethodPasswordResult']):
        """
        :param Sequence['GetConnectionOptionAuthenticationMethodPasskeyArgs'] passkeys: Configures passkey authentication
        :param Sequence['GetConnectionOptionAuthenticationMethodPasswordArgs'] passwords: Configures password authentication
        """
        pulumi.set(__self__, "passkeys", passkeys)
        pulumi.set(__self__, "passwords", passwords)

    @_builtins.property
    @pulumi.getter
    def passkeys(self) -> Sequence['outputs.GetConnectionOptionAuthenticationMethodPasskeyResult']:
        """
        Configures passkey authentication
        """
        return pulumi.get(self, "passkeys")

    @_builtins.property
    @pulumi.getter
    def passwords(self) -> Sequence['outputs.GetConnectionOptionAuthenticationMethodPasswordResult']:
        """
        Configures password authentication
        """
        return pulumi.get(self, "passwords")


@pulumi.output_type
class GetConnectionOptionAuthenticationMethodPasskeyResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enables passkey authentication
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables passkey authentication
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetConnectionOptionAuthenticationMethodPasswordResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enables password authentication
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables password authentication
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetConnectionOptionConnectionSettingResult(dict):
    def __init__(__self__, *,
                 pkce: _builtins.str):
        """
        :param _builtins.str pkce: PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        pulumi.set(__self__, "pkce", pkce)

    @_builtins.property
    @pulumi.getter
    def pkce(self) -> _builtins.str:
        """
        PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        return pulumi.get(self, "pkce")


@pulumi.output_type
class GetConnectionOptionCustomHeaderResult(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetConnectionOptionDecryptionKeyResult(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class GetConnectionOptionGatewayAuthenticationResult(dict):
    def __init__(__self__, *,
                 audience: _builtins.str,
                 method: _builtins.str,
                 secret: _builtins.str,
                 secret_base64_encoded: _builtins.bool,
                 subject: _builtins.str):
        """
        :param _builtins.str audience: Audience claim for the HS256 token sent to `gateway_url`.
        :param _builtins.str method: Authentication method (default is `bearer` token).
        :param _builtins.str secret: Secret used to sign the HS256 token sent to `gateway_url`.
        :param _builtins.bool secret_base64_encoded: Specifies whether or not the secret is Base64-encoded.
        :param _builtins.str subject: Subject claim for the HS256 token sent to `gateway_url`.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "secret_base64_encoded", secret_base64_encoded)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        Audience claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Authentication method (default is `bearer` token).
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret used to sign the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretBase64Encoded")
    def secret_base64_encoded(self) -> _builtins.bool:
        """
        Specifies whether or not the secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_base64_encoded")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetConnectionOptionIdpInitiatedResult(dict):
    def __init__(__self__, *,
                 client_authorize_query: _builtins.str,
                 client_id: _builtins.str,
                 client_protocol: _builtins.str,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "client_authorize_query", client_authorize_query)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_protocol", client_protocol)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="clientAuthorizeQuery")
    def client_authorize_query(self) -> _builtins.str:
        return pulumi.get(self, "client_authorize_query")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> _builtins.str:
        return pulumi.get(self, "client_protocol")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetConnectionOptionMfaResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 return_enroll_settings: _builtins.bool):
        """
        :param _builtins.bool active: Indicates whether multifactor authentication is enabled for this connection.
        :param _builtins.bool return_enroll_settings: Indicates whether multifactor authentication enrollment settings will be returned.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "return_enroll_settings", return_enroll_settings)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates whether multifactor authentication is enabled for this connection.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="returnEnrollSettings")
    def return_enroll_settings(self) -> _builtins.bool:
        """
        Indicates whether multifactor authentication enrollment settings will be returned.
        """
        return pulumi.get(self, "return_enroll_settings")


@pulumi.output_type
class GetConnectionOptionPasskeyOptionResult(dict):
    def __init__(__self__, *,
                 challenge_ui: _builtins.str,
                 local_enrollment_enabled: _builtins.bool,
                 progressive_enrollment_enabled: _builtins.bool):
        """
        :param _builtins.str challenge_ui: Controls the UI used to challenge the user for their passkey
        :param _builtins.bool local_enrollment_enabled: Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection
        :param _builtins.bool progressive_enrollment_enabled: Enables or disables progressive enrollment of passkeys for the connection
        """
        pulumi.set(__self__, "challenge_ui", challenge_ui)
        pulumi.set(__self__, "local_enrollment_enabled", local_enrollment_enabled)
        pulumi.set(__self__, "progressive_enrollment_enabled", progressive_enrollment_enabled)

    @_builtins.property
    @pulumi.getter(name="challengeUi")
    def challenge_ui(self) -> _builtins.str:
        """
        Controls the UI used to challenge the user for their passkey
        """
        return pulumi.get(self, "challenge_ui")

    @_builtins.property
    @pulumi.getter(name="localEnrollmentEnabled")
    def local_enrollment_enabled(self) -> _builtins.bool:
        """
        Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection
        """
        return pulumi.get(self, "local_enrollment_enabled")

    @_builtins.property
    @pulumi.getter(name="progressiveEnrollmentEnabled")
    def progressive_enrollment_enabled(self) -> _builtins.bool:
        """
        Enables or disables progressive enrollment of passkeys for the connection
        """
        return pulumi.get(self, "progressive_enrollment_enabled")


@pulumi.output_type
class GetConnectionOptionPasswordComplexityOptionResult(dict):
    def __init__(__self__, *,
                 min_length: _builtins.int):
        """
        :param _builtins.int min_length: Minimum number of characters allowed in passwords.
        """
        pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> _builtins.int:
        """
        Minimum number of characters allowed in passwords.
        """
        return pulumi.get(self, "min_length")


@pulumi.output_type
class GetConnectionOptionPasswordDictionaryResult(dict):
    def __init__(__self__, *,
                 dictionaries: Sequence[_builtins.str],
                 enable: _builtins.bool):
        """
        :param Sequence[_builtins.str] dictionaries: Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        :param _builtins.bool enable: Indicates whether the password dictionary check is enabled for this connection.
        """
        pulumi.set(__self__, "dictionaries", dictionaries)
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def dictionaries(self) -> Sequence[_builtins.str]:
        """
        Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        """
        return pulumi.get(self, "dictionaries")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether the password dictionary check is enabled for this connection.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetConnectionOptionPasswordHistoryResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 size: _builtins.int):
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetConnectionOptionPasswordNoPersonalInfoResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetConnectionOptionSigningKeyResult(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class GetConnectionOptionTotpResult(dict):
    def __init__(__self__, *,
                 length: _builtins.int,
                 time_step: _builtins.int):
        """
        :param _builtins.int length: Length of the one-time password.
        :param _builtins.int time_step: Seconds between allowed generation of new passwords.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "time_step", time_step)

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        Length of the one-time password.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter(name="timeStep")
    def time_step(self) -> _builtins.int:
        """
        Seconds between allowed generation of new passwords.
        """
        return pulumi.get(self, "time_step")


@pulumi.output_type
class GetConnectionOptionValidationResult(dict):
    def __init__(__self__, *,
                 usernames: Sequence['outputs.GetConnectionOptionValidationUsernameResult']):
        """
        :param Sequence['GetConnectionOptionValidationUsernameArgs'] usernames: Specifies the `min` and `max` values of username length.
        """
        pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Sequence['outputs.GetConnectionOptionValidationUsernameResult']:
        """
        Specifies the `min` and `max` values of username length.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetConnectionOptionValidationUsernameResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetConnectionScimConfigurationDefaultMappingResult(dict):
    def __init__(__self__, *,
                 auth0: _builtins.str,
                 scim: _builtins.str):
        """
        :param _builtins.str auth0: The field location in the Auth0 schema.
        :param _builtins.str scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @_builtins.property
    @pulumi.getter
    def auth0(self) -> _builtins.str:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @_builtins.property
    @pulumi.getter
    def scim(self) -> _builtins.str:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")


@pulumi.output_type
class GetConnectionScimConfigurationMappingResult(dict):
    def __init__(__self__, *,
                 auth0: _builtins.str,
                 scim: _builtins.str):
        """
        :param _builtins.str auth0: The field location in the Auth0 schema.
        :param _builtins.str scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @_builtins.property
    @pulumi.getter
    def auth0(self) -> _builtins.str:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @_builtins.property
    @pulumi.getter
    def scim(self) -> _builtins.str:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")


@pulumi.output_type
class GetCustomDomainCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_authority: _builtins.str,
                 error_msg: _builtins.str,
                 renews_before: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str certificate_authority: Name of the certificate authority that issued the certificate.
        :param _builtins.str error_msg: Contains the error message if the provisioning process fails.
        :param _builtins.str renews_before: Specifies the date by which the certificate should be renewed.
        :param _builtins.str status: Indicates the current state of the certificate provisioning process.
        """
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "error_msg", error_msg)
        pulumi.set(__self__, "renews_before", renews_before)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> _builtins.str:
        """
        Name of the certificate authority that issued the certificate.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> _builtins.str:
        """
        Contains the error message if the provisioning process fails.
        """
        return pulumi.get(self, "error_msg")

    @_builtins.property
    @pulumi.getter(name="renewsBefore")
    def renews_before(self) -> _builtins.str:
        """
        Specifies the date by which the certificate should be renewed.
        """
        return pulumi.get(self, "renews_before")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the current state of the certificate provisioning process.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCustomDomainVerificationResult(dict):
    def __init__(__self__, *,
                 error_msg: _builtins.str,
                 last_verified_at: _builtins.str,
                 methods: Sequence[Any],
                 status: _builtins.str):
        """
        :param _builtins.str error_msg: Contains error message, if any, from the last DNS verification check.
        :param _builtins.str last_verified_at: Indicates the last time the domain was successfully verified.
        :param Sequence[Any] methods: Defines the list of domain verification methods used.
        :param _builtins.str status: Represents the current status of the domain verification process.
        """
        pulumi.set(__self__, "error_msg", error_msg)
        pulumi.set(__self__, "last_verified_at", last_verified_at)
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> _builtins.str:
        """
        Contains error message, if any, from the last DNS verification check.
        """
        return pulumi.get(self, "error_msg")

    @_builtins.property
    @pulumi.getter(name="lastVerifiedAt")
    def last_verified_at(self) -> _builtins.str:
        """
        Indicates the last time the domain was successfully verified.
        """
        return pulumi.get(self, "last_verified_at")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Sequence[Any]:
        """
        Defines the list of domain verification methods used.
        """
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Represents the current status of the domain verification process.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetFormLanguageResult(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 primary: _builtins.str):
        """
        :param _builtins.str default: Default language for the form.
        :param _builtins.str primary: Primary language for the form.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default language for the form.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.str:
        """
        Primary language for the form.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class GetFormMessageResult(dict):
    def __init__(__self__, *,
                 custom: _builtins.str,
                 errors: _builtins.str):
        """
        :param _builtins.str custom: Custom message for the form. (JSON encoded)
        :param _builtins.str errors: Error message for the form. (JSON encoded)
        """
        pulumi.set(__self__, "custom", custom)
        pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> _builtins.str:
        """
        Custom message for the form. (JSON encoded)
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> _builtins.str:
        """
        Error message for the form. (JSON encoded)
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class GetNetworkAclRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNetworkAclRuleActionResult'],
                 matches: Sequence['outputs.GetNetworkAclRuleMatchResult'],
                 not_matches: Sequence['outputs.GetNetworkAclRuleNotMatchResult'],
                 scope: _builtins.str):
        """
        :param Sequence['GetNetworkAclRuleActionArgs'] actions: The action configuration for the Network ACL Rule. Only one action type (block, allow, log, or redirect) should be specified.
        :param Sequence['GetNetworkAclRuleMatchArgs'] matches: The configuration for the Network ACL Rule
        :param Sequence['GetNetworkAclRuleNotMatchArgs'] not_matches: The configuration for the Network ACL Rule
        :param _builtins.str scope: The scope of the Network ACL Rule
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "not_matches", not_matches)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNetworkAclRuleActionResult']:
        """
        The action configuration for the Network ACL Rule. Only one action type (block, allow, log, or redirect) should be specified.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetNetworkAclRuleMatchResult']:
        """
        The configuration for the Network ACL Rule
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="notMatches")
    def not_matches(self) -> Sequence['outputs.GetNetworkAclRuleNotMatchResult']:
        """
        The configuration for the Network ACL Rule
        """
        return pulumi.get(self, "not_matches")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope of the Network ACL Rule
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetNetworkAclRuleActionResult(dict):
    def __init__(__self__, *,
                 allow: _builtins.bool,
                 block: _builtins.bool,
                 log: _builtins.bool,
                 redirect: _builtins.bool,
                 redirect_uri: _builtins.str):
        """
        :param _builtins.bool allow: If true, allows the request. When using allow action, no other properties should be set.
        :param _builtins.bool block: If true, blocks the request. When using block action, no other properties should be set.
        :param _builtins.bool log: If true, logs the request. When using log action, no other properties should be set.
        :param _builtins.bool redirect: If true, redirects the request. When using redirect action, redirect_uri must also be specified.
        :param _builtins.str redirect_uri: The URI to redirect to when redirect is true. Required when redirect is true. Must be between 1 and 2000 characters.
        """
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "block", block)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "redirect", redirect)
        pulumi.set(__self__, "redirect_uri", redirect_uri)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> _builtins.bool:
        """
        If true, allows the request. When using allow action, no other properties should be set.
        """
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> _builtins.bool:
        """
        If true, blocks the request. When using block action, no other properties should be set.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def log(self) -> _builtins.bool:
        """
        If true, logs the request. When using log action, no other properties should be set.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> _builtins.bool:
        """
        If true, redirects the request. When using redirect action, redirect_uri must also be specified.
        """
        return pulumi.get(self, "redirect")

    @_builtins.property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> _builtins.str:
        """
        The URI to redirect to when redirect is true. Required when redirect is true. Must be between 1 and 2000 characters.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class GetNetworkAclRuleMatchResult(dict):
    def __init__(__self__, *,
                 asns: Sequence[_builtins.int],
                 geo_country_codes: Sequence[_builtins.str],
                 geo_subdivision_codes: Sequence[_builtins.str],
                 ipv4_cidrs: Sequence[_builtins.str],
                 ipv6_cidrs: Sequence[_builtins.str],
                 ja3_fingerprints: Sequence[_builtins.str],
                 ja4_fingerprints: Sequence[_builtins.str],
                 user_agents: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.int] asns: ASNs. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_country_codes: Geo Country Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_subdivision_codes: Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ipv4_cidrs: IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ipv6_cidrs: IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ja3_fingerprints: JA3 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ja4_fingerprints: JA4 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] user_agents: User Agents. Must contain between 1 and 10 unique items.
        """
        pulumi.set(__self__, "asns", asns)
        pulumi.set(__self__, "geo_country_codes", geo_country_codes)
        pulumi.set(__self__, "geo_subdivision_codes", geo_subdivision_codes)
        pulumi.set(__self__, "ipv4_cidrs", ipv4_cidrs)
        pulumi.set(__self__, "ipv6_cidrs", ipv6_cidrs)
        pulumi.set(__self__, "ja3_fingerprints", ja3_fingerprints)
        pulumi.set(__self__, "ja4_fingerprints", ja4_fingerprints)
        pulumi.set(__self__, "user_agents", user_agents)

    @_builtins.property
    @pulumi.getter
    def asns(self) -> Sequence[_builtins.int]:
        """
        ASNs. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "asns")

    @_builtins.property
    @pulumi.getter(name="geoCountryCodes")
    def geo_country_codes(self) -> Sequence[_builtins.str]:
        """
        Geo Country Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_country_codes")

    @_builtins.property
    @pulumi.getter(name="geoSubdivisionCodes")
    def geo_subdivision_codes(self) -> Sequence[_builtins.str]:
        """
        Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_subdivision_codes")

    @_builtins.property
    @pulumi.getter(name="ipv4Cidrs")
    def ipv4_cidrs(self) -> Sequence[_builtins.str]:
        """
        IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv4_cidrs")

    @_builtins.property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Sequence[_builtins.str]:
        """
        IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidrs")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprints")
    def ja3_fingerprints(self) -> Sequence[_builtins.str]:
        """
        JA3 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja3_fingerprints")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprints")
    def ja4_fingerprints(self) -> Sequence[_builtins.str]:
        """
        JA4 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja4_fingerprints")

    @_builtins.property
    @pulumi.getter(name="userAgents")
    def user_agents(self) -> Sequence[_builtins.str]:
        """
        User Agents. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "user_agents")


@pulumi.output_type
class GetNetworkAclRuleNotMatchResult(dict):
    def __init__(__self__, *,
                 asns: Sequence[_builtins.int],
                 geo_country_codes: Sequence[_builtins.str],
                 geo_subdivision_codes: Sequence[_builtins.str],
                 ipv4_cidrs: Sequence[_builtins.str],
                 ipv6_cidrs: Sequence[_builtins.str],
                 ja3_fingerprints: Sequence[_builtins.str],
                 ja4_fingerprints: Sequence[_builtins.str],
                 user_agents: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.int] asns: ASNs. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_country_codes: Geo Country Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] geo_subdivision_codes: Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ipv4_cidrs: IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ipv6_cidrs: IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        :param Sequence[_builtins.str] ja3_fingerprints: JA3 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] ja4_fingerprints: JA4 Fingerprints. Must contain between 1 and 10 unique items.
        :param Sequence[_builtins.str] user_agents: User Agents. Must contain between 1 and 10 unique items.
        """
        pulumi.set(__self__, "asns", asns)
        pulumi.set(__self__, "geo_country_codes", geo_country_codes)
        pulumi.set(__self__, "geo_subdivision_codes", geo_subdivision_codes)
        pulumi.set(__self__, "ipv4_cidrs", ipv4_cidrs)
        pulumi.set(__self__, "ipv6_cidrs", ipv6_cidrs)
        pulumi.set(__self__, "ja3_fingerprints", ja3_fingerprints)
        pulumi.set(__self__, "ja4_fingerprints", ja4_fingerprints)
        pulumi.set(__self__, "user_agents", user_agents)

    @_builtins.property
    @pulumi.getter
    def asns(self) -> Sequence[_builtins.int]:
        """
        ASNs. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "asns")

    @_builtins.property
    @pulumi.getter(name="geoCountryCodes")
    def geo_country_codes(self) -> Sequence[_builtins.str]:
        """
        Geo Country Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_country_codes")

    @_builtins.property
    @pulumi.getter(name="geoSubdivisionCodes")
    def geo_subdivision_codes(self) -> Sequence[_builtins.str]:
        """
        Geo Subdivision Codes. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "geo_subdivision_codes")

    @_builtins.property
    @pulumi.getter(name="ipv4Cidrs")
    def ipv4_cidrs(self) -> Sequence[_builtins.str]:
        """
        IPv4 CIDRs. Must contain between 1 and 10 unique items. Can be IPv4 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv4_cidrs")

    @_builtins.property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Sequence[_builtins.str]:
        """
        IPv6 CIDRs. Must contain between 1 and 10 unique items. Can be IPv6 addresses or CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidrs")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprints")
    def ja3_fingerprints(self) -> Sequence[_builtins.str]:
        """
        JA3 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja3_fingerprints")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprints")
    def ja4_fingerprints(self) -> Sequence[_builtins.str]:
        """
        JA4 Fingerprints. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "ja4_fingerprints")

    @_builtins.property
    @pulumi.getter(name="userAgents")
    def user_agents(self) -> Sequence[_builtins.str]:
        """
        User Agents. Must contain between 1 and 10 unique items.
        """
        return pulumi.get(self, "user_agents")


@pulumi.output_type
class GetOrganizationBrandingResult(dict):
    def __init__(__self__, *,
                 colors: Mapping[str, _builtins.str],
                 logo_url: _builtins.str):
        """
        :param Mapping[str, _builtins.str] colors: Color scheme used to customize the login pages.
        :param _builtins.str logo_url: URL of logo to display on login page.
        """
        pulumi.set(__self__, "colors", colors)
        pulumi.set(__self__, "logo_url", logo_url)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Mapping[str, _builtins.str]:
        """
        Color scheme used to customize the login pages.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> _builtins.str:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")


@pulumi.output_type
class GetOrganizationConnectionResult(dict):
    def __init__(__self__, *,
                 assign_membership_on_login: _builtins.bool,
                 connection_id: _builtins.str,
                 is_signup_enabled: _builtins.bool,
                 show_as_button: _builtins.bool):
        """
        :param _builtins.bool assign_membership_on_login: When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        :param _builtins.str connection_id: The ID of the enabled connection on the organization.
        :param _builtins.bool is_signup_enabled: Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        :param _builtins.bool show_as_button: Determines whether a connection should be displayed on this organization’s login prompt. Only applicable for enterprise connections.
        """
        pulumi.set(__self__, "assign_membership_on_login", assign_membership_on_login)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "is_signup_enabled", is_signup_enabled)
        pulumi.set(__self__, "show_as_button", show_as_button)

    @_builtins.property
    @pulumi.getter(name="assignMembershipOnLogin")
    def assign_membership_on_login(self) -> _builtins.bool:
        """
        When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        """
        return pulumi.get(self, "assign_membership_on_login")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        The ID of the enabled connection on the organization.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="isSignupEnabled")
    def is_signup_enabled(self) -> _builtins.bool:
        """
        Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        """
        return pulumi.get(self, "is_signup_enabled")

    @_builtins.property
    @pulumi.getter(name="showAsButton")
    def show_as_button(self) -> _builtins.bool:
        """
        Determines whether a connection should be displayed on this organization’s login prompt. Only applicable for enterprise connections.
        """
        return pulumi.get(self, "show_as_button")


@pulumi.output_type
class GetOrganizationTokenQuotaResult(dict):
    def __init__(__self__, *,
                 client_credentials: Sequence['outputs.GetOrganizationTokenQuotaClientCredentialResult']):
        """
        :param Sequence['GetOrganizationTokenQuotaClientCredentialArgs'] client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Sequence['outputs.GetOrganizationTokenQuotaClientCredentialResult']:
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class GetOrganizationTokenQuotaClientCredentialResult(dict):
    def __init__(__self__, *,
                 enforce: _builtins.bool,
                 per_day: _builtins.int,
                 per_hour: _builtins.int):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        pulumi.set(__self__, "enforce", enforce)
        pulumi.set(__self__, "per_day", per_day)
        pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> _builtins.bool:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> _builtins.int:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> _builtins.int:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class GetPagesChangePasswordResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class GetPagesErrorResult(dict):
    def __init__(__self__, *,
                 html: _builtins.str,
                 show_log_link: _builtins.bool,
                 url: _builtins.str):
        """
        :param _builtins.str html: Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        :param _builtins.bool show_log_link: Indicates whether to show the link to logs as part of the default error page.
        :param _builtins.str url: URL to redirect to when an error occurs, instead of showing the default error page.
        """
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "show_log_link", show_log_link)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @_builtins.property
    @pulumi.getter(name="showLogLink")
    def show_log_link(self) -> _builtins.bool:
        """
        Indicates whether to show the link to logs as part of the default error page.
        """
        return pulumi.get(self, "show_log_link")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to redirect to when an error occurs, instead of showing the default error page.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetPagesGuardianMfaResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class GetPagesLoginResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 html: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        :param _builtins.str html: Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")


@pulumi.output_type
class GetPhoneProviderConfigurationResult(dict):
    def __init__(__self__, *,
                 default_from: _builtins.str,
                 delivery_methods: Sequence[_builtins.str],
                 mssid: _builtins.str,
                 sid: _builtins.str):
        """
        :param _builtins.str default_from: Default sender subject as "from" when no other value is specified.
        :param Sequence[_builtins.str] delivery_methods: Media set supported by a given provider to deliver a notification
        :param _builtins.str mssid: Twilio Messaging Service SID
        :param _builtins.str sid: Twilio Account SID.
        """
        pulumi.set(__self__, "default_from", default_from)
        pulumi.set(__self__, "delivery_methods", delivery_methods)
        pulumi.set(__self__, "mssid", mssid)
        pulumi.set(__self__, "sid", sid)

    @_builtins.property
    @pulumi.getter(name="defaultFrom")
    def default_from(self) -> _builtins.str:
        """
        Default sender subject as "from" when no other value is specified.
        """
        return pulumi.get(self, "default_from")

    @_builtins.property
    @pulumi.getter(name="deliveryMethods")
    def delivery_methods(self) -> Sequence[_builtins.str]:
        """
        Media set supported by a given provider to deliver a notification
        """
        return pulumi.get(self, "delivery_methods")

    @_builtins.property
    @pulumi.getter
    def mssid(self) -> _builtins.str:
        """
        Twilio Messaging Service SID
        """
        return pulumi.get(self, "mssid")

    @_builtins.property
    @pulumi.getter
    def sid(self) -> _builtins.str:
        """
        Twilio Account SID.
        """
        return pulumi.get(self, "sid")


@pulumi.output_type
class GetPhoneProviderCredentialResult(dict):
    def __init__(__self__, *,
                 auth_token: _builtins.str):
        """
        :param _builtins.str auth_token: The Auth Token for the phone provider.
        """
        pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        The Auth Token for the phone provider.
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class GetPromptScreenPartialsScreenPartialResult(dict):
    def __init__(__self__, *,
                 insertion_points: Sequence['outputs.GetPromptScreenPartialsScreenPartialInsertionPointResult'],
                 screen_name: _builtins.str):
        """
        :param _builtins.str screen_name: The name of the screen associated with the partials
        """
        pulumi.set(__self__, "insertion_points", insertion_points)
        pulumi.set(__self__, "screen_name", screen_name)

    @_builtins.property
    @pulumi.getter(name="insertionPoints")
    def insertion_points(self) -> Sequence['outputs.GetPromptScreenPartialsScreenPartialInsertionPointResult']:
        return pulumi.get(self, "insertion_points")

    @_builtins.property
    @pulumi.getter(name="screenName")
    def screen_name(self) -> _builtins.str:
        """
        The name of the screen associated with the partials
        """
        return pulumi.get(self, "screen_name")


@pulumi.output_type
class GetPromptScreenPartialsScreenPartialInsertionPointResult(dict):
    def __init__(__self__, *,
                 form_content: _builtins.str,
                 form_content_end: _builtins.str,
                 form_content_start: _builtins.str,
                 form_footer_end: _builtins.str,
                 form_footer_start: _builtins.str,
                 secondary_actions_end: _builtins.str,
                 secondary_actions_start: _builtins.str):
        """
        :param _builtins.str form_content: Content that goes inside the form
        :param _builtins.str form_content_end: Content that goes at the end of the form.
        :param _builtins.str form_content_start: Content that goes at the start of the form.
        :param _builtins.str form_footer_end: Footer content for the end of the footer.
        :param _builtins.str form_footer_start: Footer content for the start of the footer.
        :param _builtins.str secondary_actions_end: Actions that go at the end of secondary actions.
        :param _builtins.str secondary_actions_start: Actions that go at the start of secondary actions.
        """
        pulumi.set(__self__, "form_content", form_content)
        pulumi.set(__self__, "form_content_end", form_content_end)
        pulumi.set(__self__, "form_content_start", form_content_start)
        pulumi.set(__self__, "form_footer_end", form_footer_end)
        pulumi.set(__self__, "form_footer_start", form_footer_start)
        pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @_builtins.property
    @pulumi.getter(name="formContent")
    def form_content(self) -> _builtins.str:
        """
        Content that goes inside the form
        """
        return pulumi.get(self, "form_content")

    @_builtins.property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> _builtins.str:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @_builtins.property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> _builtins.str:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @_builtins.property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> _builtins.str:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @_builtins.property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> _builtins.str:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> _builtins.str:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @_builtins.property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> _builtins.str:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")


@pulumi.output_type
class GetPromptScreenRendererFilterResult(dict):
    def __init__(__self__, *,
                 clients: _builtins.str,
                 domains: _builtins.str,
                 match_type: _builtins.str,
                 organizations: _builtins.str):
        """
        :param _builtins.str clients: An array of clients (applications) identified by id or a metadata key/value pair. Entity Limit: 25.
        :param _builtins.str domains: An array of domains identified by id or a metadata key/value pair. Entity Limit: 25.
        :param _builtins.str match_type: Type of match to apply. Options: `includes_any`, `excludes_any`.
        :param _builtins.str organizations: An array of organizations identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "organizations", organizations)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> _builtins.str:
        """
        An array of clients (applications) identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> _builtins.str:
        """
        An array of domains identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Type of match to apply. Options: `includes_any`, `excludes_any`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> _builtins.str:
        """
        An array of organizations identified by id or a metadata key/value pair. Entity Limit: 25.
        """
        return pulumi.get(self, "organizations")


@pulumi.output_type
class GetResourceServerAuthorizationDetailResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 type: _builtins.str):
        """
        :param _builtins.bool disable: Disable authorization details.
        :param _builtins.str type: Type of authorization details.
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        Disable authorization details.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of authorization details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourceServerProofOfPossessionResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 mechanism: _builtins.str,
                 required: _builtins.bool):
        """
        :param _builtins.bool disable: Disable proof-of-possession.
        :param _builtins.str mechanism: Mechanism used for proof-of-possession. `mtls` or `dpop` is supported.
        :param _builtins.bool required: Indicates whether proof-of-possession is required with this resource server.
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "mechanism", mechanism)
        pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        Disable proof-of-possession.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> _builtins.str:
        """
        Mechanism used for proof-of-possession. `mtls` or `dpop` is supported.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        """
        Indicates whether proof-of-possession is required with this resource server.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class GetResourceServerScopeResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description of the permission (scope).
        :param _builtins.str name: Name of the permission (scope). Examples include `read:appointments` or `delete:appointments`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the permission (scope).
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission (scope). Examples include `read:appointments` or `delete:appointments`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourceServerTokenEncryptionResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 encryption_keys: Sequence['outputs.GetResourceServerTokenEncryptionEncryptionKeyResult'],
                 format: _builtins.str):
        """
        :param _builtins.bool disable: Disable token encryption.
        :param Sequence['GetResourceServerTokenEncryptionEncryptionKeyArgs'] encryption_keys: Authorization details for this resource server.
        :param _builtins.str format: Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "encryption_keys", encryption_keys)
        pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        Disable token encryption.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Sequence['outputs.GetResourceServerTokenEncryptionEncryptionKeyResult']:
        """
        Authorization details for this resource server.
        """
        return pulumi.get(self, "encryption_keys")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class GetResourceServerTokenEncryptionEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 kid: _builtins.str,
                 name: _builtins.str,
                 pem: _builtins.str):
        """
        :param _builtins.str algorithm: Algorithm used to encrypt the token.
        :param _builtins.str kid: Key ID.
        :param _builtins.str name: Name of the encryption key.
        :param _builtins.str pem: PEM-formatted public key. Must be JSON escaped.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pem", pem)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        Algorithm used to encrypt the token.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def kid(self) -> _builtins.str:
        """
        Key ID.
        """
        return pulumi.get(self, "kid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the encryption key.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pem(self) -> _builtins.str:
        """
        PEM-formatted public key. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")


@pulumi.output_type
class GetRolePermissionResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 resource_server_identifier: _builtins.str,
                 resource_server_name: _builtins.str):
        """
        :param _builtins.str description: Description of the permission.
        :param _builtins.str name: Name of the permission (scope) configured on the resource server (API).
        :param _builtins.str resource_server_identifier: Unique identifier for the resource server (API).
        :param _builtins.str resource_server_name: Name of resource server (API) that the permission is associated with.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        pulumi.set(__self__, "resource_server_name", resource_server_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission (scope) configured on the resource server (API).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> _builtins.str:
        """
        Unique identifier for the resource server (API).
        """
        return pulumi.get(self, "resource_server_identifier")

    @_builtins.property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> _builtins.str:
        """
        Name of resource server (API) that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")


@pulumi.output_type
class GetSelfServiceProfileBrandingResult(dict):
    def __init__(__self__, *,
                 colors: Sequence['outputs.GetSelfServiceProfileBrandingColorResult'],
                 logo_url: _builtins.str):
        """
        :param Sequence['GetSelfServiceProfileBrandingColorArgs'] colors: Configuration settings for colors for branding.
        :param _builtins.str logo_url: URL of logo to display on login page.
        """
        pulumi.set(__self__, "colors", colors)
        pulumi.set(__self__, "logo_url", logo_url)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Sequence['outputs.GetSelfServiceProfileBrandingColorResult']:
        """
        Configuration settings for colors for branding.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> _builtins.str:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")


@pulumi.output_type
class GetSelfServiceProfileBrandingColorResult(dict):
    def __init__(__self__, *,
                 primary: _builtins.str):
        """
        :param _builtins.str primary: Primary button background color in hexadecimal.
        """
        pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.str:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class GetSelfServiceProfileUserAttributeResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 is_optional: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str description: A human readable description of the attribute.
        :param _builtins.bool is_optional: Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        :param _builtins.str name: Attribute’s name on Auth0 side
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "is_optional", is_optional)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A human readable description of the attribute.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> _builtins.bool:
        """
        Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        """
        return pulumi.get(self, "is_optional")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Attribute’s name on Auth0 side
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSigningKeysSigningKeyResult(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 current: _builtins.bool,
                 fingerprint: _builtins.str,
                 kid: _builtins.str,
                 next: _builtins.bool,
                 pkcs7: _builtins.str,
                 previous: _builtins.bool,
                 revoked: _builtins.bool,
                 thumbprint: _builtins.str):
        """
        :param _builtins.str cert: The public certificate of the signing key.
        :param _builtins.bool current: True if the key is the the current key.
        :param _builtins.str fingerprint: The cert fingerprint.
        :param _builtins.str kid: The key ID of the signing key.
        :param _builtins.bool next: True if the key is the the next key.
        :param _builtins.str pkcs7: The public certificate of the signing key in PKCS7 format.
        :param _builtins.bool previous: True if the key is the the previous key.
        :param _builtins.bool revoked: True if the key is revoked.
        :param _builtins.str thumbprint: The cert thumbprint.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "current", current)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "pkcs7", pkcs7)
        pulumi.set(__self__, "previous", previous)
        pulumi.set(__self__, "revoked", revoked)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        """
        The public certificate of the signing key.
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def current(self) -> _builtins.bool:
        """
        True if the key is the the current key.
        """
        return pulumi.get(self, "current")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The cert fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter
    def kid(self) -> _builtins.str:
        """
        The key ID of the signing key.
        """
        return pulumi.get(self, "kid")

    @_builtins.property
    @pulumi.getter
    def next(self) -> _builtins.bool:
        """
        True if the key is the the next key.
        """
        return pulumi.get(self, "next")

    @_builtins.property
    @pulumi.getter
    def pkcs7(self) -> _builtins.str:
        """
        The public certificate of the signing key in PKCS7 format.
        """
        return pulumi.get(self, "pkcs7")

    @_builtins.property
    @pulumi.getter
    def previous(self) -> _builtins.bool:
        """
        True if the key is the the previous key.
        """
        return pulumi.get(self, "previous")

    @_builtins.property
    @pulumi.getter
    def revoked(self) -> _builtins.bool:
        """
        True if the key is revoked.
        """
        return pulumi.get(self, "revoked")

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> _builtins.str:
        """
        The cert thumbprint.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class GetTenantDefaultTokenQuotaResult(dict):
    def __init__(__self__, *,
                 clients: Sequence['outputs.GetTenantDefaultTokenQuotaClientResult'],
                 organizations: Sequence['outputs.GetTenantDefaultTokenQuotaOrganizationResult']):
        """
        :param Sequence['GetTenantDefaultTokenQuotaClientArgs'] clients: The token quota configuration.
        :param Sequence['GetTenantDefaultTokenQuotaOrganizationArgs'] organizations: The token quota configuration.
        """
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "organizations", organizations)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Sequence['outputs.GetTenantDefaultTokenQuotaClientResult']:
        """
        The token quota configuration.
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Sequence['outputs.GetTenantDefaultTokenQuotaOrganizationResult']:
        """
        The token quota configuration.
        """
        return pulumi.get(self, "organizations")


@pulumi.output_type
class GetTenantDefaultTokenQuotaClientResult(dict):
    def __init__(__self__, *,
                 client_credentials: Sequence['outputs.GetTenantDefaultTokenQuotaClientClientCredentialResult']):
        """
        :param Sequence['GetTenantDefaultTokenQuotaClientClientCredentialArgs'] client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Sequence['outputs.GetTenantDefaultTokenQuotaClientClientCredentialResult']:
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class GetTenantDefaultTokenQuotaClientClientCredentialResult(dict):
    def __init__(__self__, *,
                 enforce: _builtins.bool,
                 per_day: _builtins.int,
                 per_hour: _builtins.int):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        pulumi.set(__self__, "enforce", enforce)
        pulumi.set(__self__, "per_day", per_day)
        pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> _builtins.bool:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> _builtins.int:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> _builtins.int:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class GetTenantDefaultTokenQuotaOrganizationResult(dict):
    def __init__(__self__, *,
                 client_credentials: Sequence['outputs.GetTenantDefaultTokenQuotaOrganizationClientCredentialResult']):
        """
        :param Sequence['GetTenantDefaultTokenQuotaOrganizationClientCredentialArgs'] client_credentials: The token quota configuration for client credentials.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Sequence['outputs.GetTenantDefaultTokenQuotaOrganizationClientCredentialResult']:
        """
        The token quota configuration for client credentials.
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class GetTenantDefaultTokenQuotaOrganizationClientCredentialResult(dict):
    def __init__(__self__, *,
                 enforce: _builtins.bool,
                 per_day: _builtins.int,
                 per_hour: _builtins.int):
        """
        :param _builtins.bool enforce: If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        :param _builtins.int per_day: Maximum number of issued tokens per day
        :param _builtins.int per_hour: Maximum number of issued tokens per hour
        """
        pulumi.set(__self__, "enforce", enforce)
        pulumi.set(__self__, "per_day", per_day)
        pulumi.set(__self__, "per_hour", per_hour)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> _builtins.bool:
        """
        If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs.
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="perDay")
    def per_day(self) -> _builtins.int:
        """
        Maximum number of issued tokens per day
        """
        return pulumi.get(self, "per_day")

    @_builtins.property
    @pulumi.getter(name="perHour")
    def per_hour(self) -> _builtins.int:
        """
        Maximum number of issued tokens per hour
        """
        return pulumi.get(self, "per_hour")


@pulumi.output_type
class GetTenantErrorPageResult(dict):
    def __init__(__self__, *,
                 html: _builtins.str,
                 show_log_link: _builtins.bool,
                 url: _builtins.str):
        """
        :param _builtins.str html: Custom Error HTML (Liquid syntax is supported)
        :param _builtins.bool show_log_link: Whether to show the link to log as part of the default error page (true, default) or not to show the link (false).
        :param _builtins.str url: URL to redirect to when an error occurs instead of showing the default error page
        """
        pulumi.set(__self__, "html", html)
        pulumi.set(__self__, "show_log_link", show_log_link)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def html(self) -> _builtins.str:
        """
        Custom Error HTML (Liquid syntax is supported)
        """
        return pulumi.get(self, "html")

    @_builtins.property
    @pulumi.getter(name="showLogLink")
    def show_log_link(self) -> _builtins.bool:
        """
        Whether to show the link to log as part of the default error page (true, default) or not to show the link (false).
        """
        return pulumi.get(self, "show_log_link")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to redirect to when an error occurs instead of showing the default error page
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetTenantFlagResult(dict):
    def __init__(__self__, *,
                 allow_legacy_delegation_grant_types: _builtins.bool,
                 allow_legacy_ro_grant_types: _builtins.bool,
                 allow_legacy_tokeninfo_endpoint: _builtins.bool,
                 dashboard_insights_view: _builtins.bool,
                 dashboard_log_streams_next: _builtins.bool,
                 disable_clickjack_protection_headers: _builtins.bool,
                 disable_fields_map_fix: _builtins.bool,
                 disable_management_api_sms_obfuscation: _builtins.bool,
                 enable_adfs_waad_email_verification: _builtins.bool,
                 enable_apis_section: _builtins.bool,
                 enable_client_connections: _builtins.bool,
                 enable_custom_domain_in_emails: _builtins.bool,
                 enable_dynamic_client_registration: _builtins.bool,
                 enable_idtoken_api2: _builtins.bool,
                 enable_legacy_logs_search_v2: _builtins.bool,
                 enable_legacy_profile: _builtins.bool,
                 enable_pipeline2: _builtins.bool,
                 enable_public_signup_user_exists_error: _builtins.bool,
                 enable_sso: _builtins.bool,
                 mfa_show_factor_list_on_enrollment: _builtins.bool,
                 no_disclose_enterprise_connections: _builtins.bool,
                 remove_alg_from_jwks: _builtins.bool,
                 require_pushed_authorization_requests: _builtins.bool,
                 revoke_refresh_token_grant: _builtins.bool,
                 use_scope_descriptions_for_consent: _builtins.bool):
        """
        :param _builtins.bool allow_legacy_delegation_grant_types: Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        :param _builtins.bool allow_legacy_ro_grant_types: Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        :param _builtins.bool allow_legacy_tokeninfo_endpoint: If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        :param _builtins.bool dashboard_insights_view: Enables new insights activity page view.
        :param _builtins.bool dashboard_log_streams_next: Enables beta access to log streaming changes.
        :param _builtins.bool disable_clickjack_protection_headers: Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        :param _builtins.bool disable_fields_map_fix: Disables SAML fields map fix for bad mappings with repeated attributes.
        :param _builtins.bool disable_management_api_sms_obfuscation: If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        :param _builtins.bool enable_adfs_waad_email_verification: If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        :param _builtins.bool enable_apis_section: Indicates whether the APIs section is enabled for the tenant.
        :param _builtins.bool enable_client_connections: Indicates whether all current connections should be enabled when a new client is created.
        :param _builtins.bool enable_custom_domain_in_emails: Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        :param _builtins.bool enable_dynamic_client_registration: Indicates whether the tenant allows dynamic client registration.
        :param _builtins.bool enable_idtoken_api2: Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        :param _builtins.bool enable_legacy_logs_search_v2: Indicates whether to use the older v2 legacy logs search.
        :param _builtins.bool enable_legacy_profile: Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        :param _builtins.bool enable_pipeline2: Indicates whether advanced API Authorization scenarios are enabled.
        :param _builtins.bool enable_public_signup_user_exists_error: Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        :param _builtins.bool enable_sso: Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        :param _builtins.bool mfa_show_factor_list_on_enrollment: Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        :param _builtins.bool no_disclose_enterprise_connections: Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        :param _builtins.bool remove_alg_from_jwks: Remove `alg` from jwks(JSON Web Key Sets).
        :param _builtins.bool require_pushed_authorization_requests: This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        :param _builtins.bool revoke_refresh_token_grant: Delete underlying grant when a refresh token is revoked via the Authentication API.
        :param _builtins.bool use_scope_descriptions_for_consent: Indicates whether to use scope descriptions for consent.
        """
        pulumi.set(__self__, "allow_legacy_delegation_grant_types", allow_legacy_delegation_grant_types)
        pulumi.set(__self__, "allow_legacy_ro_grant_types", allow_legacy_ro_grant_types)
        pulumi.set(__self__, "allow_legacy_tokeninfo_endpoint", allow_legacy_tokeninfo_endpoint)
        pulumi.set(__self__, "dashboard_insights_view", dashboard_insights_view)
        pulumi.set(__self__, "dashboard_log_streams_next", dashboard_log_streams_next)
        pulumi.set(__self__, "disable_clickjack_protection_headers", disable_clickjack_protection_headers)
        pulumi.set(__self__, "disable_fields_map_fix", disable_fields_map_fix)
        pulumi.set(__self__, "disable_management_api_sms_obfuscation", disable_management_api_sms_obfuscation)
        pulumi.set(__self__, "enable_adfs_waad_email_verification", enable_adfs_waad_email_verification)
        pulumi.set(__self__, "enable_apis_section", enable_apis_section)
        pulumi.set(__self__, "enable_client_connections", enable_client_connections)
        pulumi.set(__self__, "enable_custom_domain_in_emails", enable_custom_domain_in_emails)
        pulumi.set(__self__, "enable_dynamic_client_registration", enable_dynamic_client_registration)
        pulumi.set(__self__, "enable_idtoken_api2", enable_idtoken_api2)
        pulumi.set(__self__, "enable_legacy_logs_search_v2", enable_legacy_logs_search_v2)
        pulumi.set(__self__, "enable_legacy_profile", enable_legacy_profile)
        pulumi.set(__self__, "enable_pipeline2", enable_pipeline2)
        pulumi.set(__self__, "enable_public_signup_user_exists_error", enable_public_signup_user_exists_error)
        pulumi.set(__self__, "enable_sso", enable_sso)
        pulumi.set(__self__, "mfa_show_factor_list_on_enrollment", mfa_show_factor_list_on_enrollment)
        pulumi.set(__self__, "no_disclose_enterprise_connections", no_disclose_enterprise_connections)
        pulumi.set(__self__, "remove_alg_from_jwks", remove_alg_from_jwks)
        pulumi.set(__self__, "require_pushed_authorization_requests", require_pushed_authorization_requests)
        pulumi.set(__self__, "revoke_refresh_token_grant", revoke_refresh_token_grant)
        pulumi.set(__self__, "use_scope_descriptions_for_consent", use_scope_descriptions_for_consent)

    @_builtins.property
    @pulumi.getter(name="allowLegacyDelegationGrantTypes")
    def allow_legacy_delegation_grant_types(self) -> _builtins.bool:
        """
        Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_delegation_grant_types")

    @_builtins.property
    @pulumi.getter(name="allowLegacyRoGrantTypes")
    def allow_legacy_ro_grant_types(self) -> _builtins.bool:
        """
        Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_ro_grant_types")

    @_builtins.property
    @pulumi.getter(name="allowLegacyTokeninfoEndpoint")
    def allow_legacy_tokeninfo_endpoint(self) -> _builtins.bool:
        """
        If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        """
        return pulumi.get(self, "allow_legacy_tokeninfo_endpoint")

    @_builtins.property
    @pulumi.getter(name="dashboardInsightsView")
    def dashboard_insights_view(self) -> _builtins.bool:
        """
        Enables new insights activity page view.
        """
        return pulumi.get(self, "dashboard_insights_view")

    @_builtins.property
    @pulumi.getter(name="dashboardLogStreamsNext")
    def dashboard_log_streams_next(self) -> _builtins.bool:
        """
        Enables beta access to log streaming changes.
        """
        return pulumi.get(self, "dashboard_log_streams_next")

    @_builtins.property
    @pulumi.getter(name="disableClickjackProtectionHeaders")
    def disable_clickjack_protection_headers(self) -> _builtins.bool:
        """
        Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        """
        return pulumi.get(self, "disable_clickjack_protection_headers")

    @_builtins.property
    @pulumi.getter(name="disableFieldsMapFix")
    def disable_fields_map_fix(self) -> _builtins.bool:
        """
        Disables SAML fields map fix for bad mappings with repeated attributes.
        """
        return pulumi.get(self, "disable_fields_map_fix")

    @_builtins.property
    @pulumi.getter(name="disableManagementApiSmsObfuscation")
    def disable_management_api_sms_obfuscation(self) -> _builtins.bool:
        """
        If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        """
        return pulumi.get(self, "disable_management_api_sms_obfuscation")

    @_builtins.property
    @pulumi.getter(name="enableAdfsWaadEmailVerification")
    def enable_adfs_waad_email_verification(self) -> _builtins.bool:
        """
        If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        """
        return pulumi.get(self, "enable_adfs_waad_email_verification")

    @_builtins.property
    @pulumi.getter(name="enableApisSection")
    def enable_apis_section(self) -> _builtins.bool:
        """
        Indicates whether the APIs section is enabled for the tenant.
        """
        return pulumi.get(self, "enable_apis_section")

    @_builtins.property
    @pulumi.getter(name="enableClientConnections")
    def enable_client_connections(self) -> _builtins.bool:
        """
        Indicates whether all current connections should be enabled when a new client is created.
        """
        return pulumi.get(self, "enable_client_connections")

    @_builtins.property
    @pulumi.getter(name="enableCustomDomainInEmails")
    def enable_custom_domain_in_emails(self) -> _builtins.bool:
        """
        Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        """
        return pulumi.get(self, "enable_custom_domain_in_emails")

    @_builtins.property
    @pulumi.getter(name="enableDynamicClientRegistration")
    def enable_dynamic_client_registration(self) -> _builtins.bool:
        """
        Indicates whether the tenant allows dynamic client registration.
        """
        return pulumi.get(self, "enable_dynamic_client_registration")

    @_builtins.property
    @pulumi.getter(name="enableIdtokenApi2")
    def enable_idtoken_api2(self) -> _builtins.bool:
        """
        Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        """
        return pulumi.get(self, "enable_idtoken_api2")

    @_builtins.property
    @pulumi.getter(name="enableLegacyLogsSearchV2")
    def enable_legacy_logs_search_v2(self) -> _builtins.bool:
        """
        Indicates whether to use the older v2 legacy logs search.
        """
        return pulumi.get(self, "enable_legacy_logs_search_v2")

    @_builtins.property
    @pulumi.getter(name="enableLegacyProfile")
    def enable_legacy_profile(self) -> _builtins.bool:
        """
        Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        """
        return pulumi.get(self, "enable_legacy_profile")

    @_builtins.property
    @pulumi.getter(name="enablePipeline2")
    def enable_pipeline2(self) -> _builtins.bool:
        """
        Indicates whether advanced API Authorization scenarios are enabled.
        """
        return pulumi.get(self, "enable_pipeline2")

    @_builtins.property
    @pulumi.getter(name="enablePublicSignupUserExistsError")
    def enable_public_signup_user_exists_error(self) -> _builtins.bool:
        """
        Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        """
        return pulumi.get(self, "enable_public_signup_user_exists_error")

    @_builtins.property
    @pulumi.getter(name="enableSso")
    def enable_sso(self) -> _builtins.bool:
        """
        Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        """
        return pulumi.get(self, "enable_sso")

    @_builtins.property
    @pulumi.getter(name="mfaShowFactorListOnEnrollment")
    def mfa_show_factor_list_on_enrollment(self) -> _builtins.bool:
        """
        Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        """
        return pulumi.get(self, "mfa_show_factor_list_on_enrollment")

    @_builtins.property
    @pulumi.getter(name="noDiscloseEnterpriseConnections")
    def no_disclose_enterprise_connections(self) -> _builtins.bool:
        """
        Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        """
        return pulumi.get(self, "no_disclose_enterprise_connections")

    @_builtins.property
    @pulumi.getter(name="removeAlgFromJwks")
    def remove_alg_from_jwks(self) -> _builtins.bool:
        """
        Remove `alg` from jwks(JSON Web Key Sets).
        """
        return pulumi.get(self, "remove_alg_from_jwks")

    @_builtins.property
    @pulumi.getter(name="requirePushedAuthorizationRequests")
    def require_pushed_authorization_requests(self) -> _builtins.bool:
        """
        This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        """
        return pulumi.get(self, "require_pushed_authorization_requests")

    @_builtins.property
    @pulumi.getter(name="revokeRefreshTokenGrant")
    def revoke_refresh_token_grant(self) -> _builtins.bool:
        """
        Delete underlying grant when a refresh token is revoked via the Authentication API.
        """
        return pulumi.get(self, "revoke_refresh_token_grant")

    @_builtins.property
    @pulumi.getter(name="useScopeDescriptionsForConsent")
    def use_scope_descriptions_for_consent(self) -> _builtins.bool:
        """
        Indicates whether to use scope descriptions for consent.
        """
        return pulumi.get(self, "use_scope_descriptions_for_consent")


@pulumi.output_type
class GetTenantMtlResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 enable_endpoint_aliases: _builtins.bool):
        """
        :param _builtins.bool disable: Disable mTLS settings.
        :param _builtins.bool enable_endpoint_aliases: Enable mTLS endpoint aliases.
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "enable_endpoint_aliases", enable_endpoint_aliases)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        Disable mTLS settings.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="enableEndpointAliases")
    def enable_endpoint_aliases(self) -> _builtins.bool:
        """
        Enable mTLS endpoint aliases.
        """
        return pulumi.get(self, "enable_endpoint_aliases")


@pulumi.output_type
class GetTenantOidcLogoutResult(dict):
    def __init__(__self__, *,
                 rp_logout_end_session_endpoint_discovery: _builtins.bool):
        """
        :param _builtins.bool rp_logout_end_session_endpoint_discovery: Enable the end_session_endpoint URL in the .well-known discovery configuration.
        """
        pulumi.set(__self__, "rp_logout_end_session_endpoint_discovery", rp_logout_end_session_endpoint_discovery)

    @_builtins.property
    @pulumi.getter(name="rpLogoutEndSessionEndpointDiscovery")
    def rp_logout_end_session_endpoint_discovery(self) -> _builtins.bool:
        """
        Enable the end_session_endpoint URL in the .well-known discovery configuration.
        """
        return pulumi.get(self, "rp_logout_end_session_endpoint_discovery")


@pulumi.output_type
class GetTenantSessionResult(dict):
    def __init__(__self__, *,
                 oidc_logout_prompt_enabled: _builtins.bool):
        """
        :param _builtins.bool oidc_logout_prompt_enabled: When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        pulumi.set(__self__, "oidc_logout_prompt_enabled", oidc_logout_prompt_enabled)

    @_builtins.property
    @pulumi.getter(name="oidcLogoutPromptEnabled")
    def oidc_logout_prompt_enabled(self) -> _builtins.bool:
        """
        When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        return pulumi.get(self, "oidc_logout_prompt_enabled")


@pulumi.output_type
class GetTenantSessionCookyResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetUserPermissionResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 resource_server_identifier: _builtins.str,
                 resource_server_name: _builtins.str):
        """
        :param _builtins.str description: Description of the permission.
        :param _builtins.str name: Name of the permission.
        :param _builtins.str resource_server_identifier: Resource server identifier associated with the permission.
        :param _builtins.str resource_server_name: Name of resource server that the permission is associated with.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        pulumi.set(__self__, "resource_server_name", resource_server_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> _builtins.str:
        """
        Resource server identifier associated with the permission.
        """
        return pulumi.get(self, "resource_server_identifier")

    @_builtins.property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> _builtins.str:
        """
        Name of resource server that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")


