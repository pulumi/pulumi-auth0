# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ActionDependencyArgs',
    'ActionDependencyArgsDict',
    'ActionSecretArgs',
    'ActionSecretArgsDict',
    'ActionSupportedTriggersArgs',
    'ActionSupportedTriggersArgsDict',
    'AttackProtectionBreachedPasswordDetectionArgs',
    'AttackProtectionBreachedPasswordDetectionArgsDict',
    'AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs',
    'AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgsDict',
    'AttackProtectionBruteForceProtectionArgs',
    'AttackProtectionBruteForceProtectionArgsDict',
    'AttackProtectionSuspiciousIpThrottlingArgs',
    'AttackProtectionSuspiciousIpThrottlingArgsDict',
    'AttackProtectionSuspiciousIpThrottlingPreLoginArgs',
    'AttackProtectionSuspiciousIpThrottlingPreLoginArgsDict',
    'AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs',
    'AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgsDict',
    'BrandingColorsArgs',
    'BrandingColorsArgsDict',
    'BrandingFontArgs',
    'BrandingFontArgsDict',
    'BrandingThemeBordersArgs',
    'BrandingThemeBordersArgsDict',
    'BrandingThemeColorsArgs',
    'BrandingThemeColorsArgsDict',
    'BrandingThemeFontsArgs',
    'BrandingThemeFontsArgsDict',
    'BrandingThemeFontsBodyTextArgs',
    'BrandingThemeFontsBodyTextArgsDict',
    'BrandingThemeFontsButtonsTextArgs',
    'BrandingThemeFontsButtonsTextArgsDict',
    'BrandingThemeFontsInputLabelsArgs',
    'BrandingThemeFontsInputLabelsArgsDict',
    'BrandingThemeFontsLinksArgs',
    'BrandingThemeFontsLinksArgsDict',
    'BrandingThemeFontsSubtitleArgs',
    'BrandingThemeFontsSubtitleArgsDict',
    'BrandingThemeFontsTitleArgs',
    'BrandingThemeFontsTitleArgsDict',
    'BrandingThemePageBackgroundArgs',
    'BrandingThemePageBackgroundArgsDict',
    'BrandingThemeWidgetArgs',
    'BrandingThemeWidgetArgsDict',
    'BrandingUniversalLoginArgs',
    'BrandingUniversalLoginArgsDict',
    'ClientAddonsArgs',
    'ClientAddonsArgsDict',
    'ClientAddonsAwsArgs',
    'ClientAddonsAwsArgsDict',
    'ClientAddonsAzureBlobArgs',
    'ClientAddonsAzureBlobArgsDict',
    'ClientAddonsAzureSbArgs',
    'ClientAddonsAzureSbArgsDict',
    'ClientAddonsBoxArgs',
    'ClientAddonsBoxArgsDict',
    'ClientAddonsCloudbeesArgs',
    'ClientAddonsCloudbeesArgsDict',
    'ClientAddonsConcurArgs',
    'ClientAddonsConcurArgsDict',
    'ClientAddonsDropboxArgs',
    'ClientAddonsDropboxArgsDict',
    'ClientAddonsEchosignArgs',
    'ClientAddonsEchosignArgsDict',
    'ClientAddonsEgnyteArgs',
    'ClientAddonsEgnyteArgsDict',
    'ClientAddonsFirebaseArgs',
    'ClientAddonsFirebaseArgsDict',
    'ClientAddonsLayerArgs',
    'ClientAddonsLayerArgsDict',
    'ClientAddonsMscrmArgs',
    'ClientAddonsMscrmArgsDict',
    'ClientAddonsNewrelicArgs',
    'ClientAddonsNewrelicArgsDict',
    'ClientAddonsOffice365Args',
    'ClientAddonsOffice365ArgsDict',
    'ClientAddonsRmsArgs',
    'ClientAddonsRmsArgsDict',
    'ClientAddonsSalesforceArgs',
    'ClientAddonsSalesforceArgsDict',
    'ClientAddonsSalesforceApiArgs',
    'ClientAddonsSalesforceApiArgsDict',
    'ClientAddonsSalesforceSandboxApiArgs',
    'ClientAddonsSalesforceSandboxApiArgsDict',
    'ClientAddonsSamlpArgs',
    'ClientAddonsSamlpArgsDict',
    'ClientAddonsSamlpLogoutArgs',
    'ClientAddonsSamlpLogoutArgsDict',
    'ClientAddonsSapApiArgs',
    'ClientAddonsSapApiArgsDict',
    'ClientAddonsSentryArgs',
    'ClientAddonsSentryArgsDict',
    'ClientAddonsSharepointArgs',
    'ClientAddonsSharepointArgsDict',
    'ClientAddonsSlackArgs',
    'ClientAddonsSlackArgsDict',
    'ClientAddonsSpringcmArgs',
    'ClientAddonsSpringcmArgsDict',
    'ClientAddonsSsoIntegrationArgs',
    'ClientAddonsSsoIntegrationArgsDict',
    'ClientAddonsWamsArgs',
    'ClientAddonsWamsArgsDict',
    'ClientAddonsWsfedArgs',
    'ClientAddonsWsfedArgsDict',
    'ClientAddonsZendeskArgs',
    'ClientAddonsZendeskArgsDict',
    'ClientAddonsZoomArgs',
    'ClientAddonsZoomArgsDict',
    'ClientCredentialsPrivateKeyJwtArgs',
    'ClientCredentialsPrivateKeyJwtArgsDict',
    'ClientCredentialsPrivateKeyJwtCredentialArgs',
    'ClientCredentialsPrivateKeyJwtCredentialArgsDict',
    'ClientCredentialsSelfSignedTlsClientAuthArgs',
    'ClientCredentialsSelfSignedTlsClientAuthArgsDict',
    'ClientCredentialsSelfSignedTlsClientAuthCredentialArgs',
    'ClientCredentialsSelfSignedTlsClientAuthCredentialArgsDict',
    'ClientCredentialsSignedRequestObjectArgs',
    'ClientCredentialsSignedRequestObjectArgsDict',
    'ClientCredentialsSignedRequestObjectCredentialArgs',
    'ClientCredentialsSignedRequestObjectCredentialArgsDict',
    'ClientCredentialsTlsClientAuthArgs',
    'ClientCredentialsTlsClientAuthArgsDict',
    'ClientCredentialsTlsClientAuthCredentialArgs',
    'ClientCredentialsTlsClientAuthCredentialArgsDict',
    'ClientDefaultOrganizationArgs',
    'ClientDefaultOrganizationArgsDict',
    'ClientJwtConfigurationArgs',
    'ClientJwtConfigurationArgsDict',
    'ClientMobileArgs',
    'ClientMobileArgsDict',
    'ClientMobileAndroidArgs',
    'ClientMobileAndroidArgsDict',
    'ClientMobileIosArgs',
    'ClientMobileIosArgsDict',
    'ClientNativeSocialLoginArgs',
    'ClientNativeSocialLoginArgsDict',
    'ClientNativeSocialLoginAppleArgs',
    'ClientNativeSocialLoginAppleArgsDict',
    'ClientNativeSocialLoginFacebookArgs',
    'ClientNativeSocialLoginFacebookArgsDict',
    'ClientRefreshTokenArgs',
    'ClientRefreshTokenArgsDict',
    'ConnectionOptionsArgs',
    'ConnectionOptionsArgsDict',
    'ConnectionOptionsAttributeArgs',
    'ConnectionOptionsAttributeArgsDict',
    'ConnectionOptionsAttributeEmailArgs',
    'ConnectionOptionsAttributeEmailArgsDict',
    'ConnectionOptionsAttributeEmailIdentifierArgs',
    'ConnectionOptionsAttributeEmailIdentifierArgsDict',
    'ConnectionOptionsAttributeEmailSignupArgs',
    'ConnectionOptionsAttributeEmailSignupArgsDict',
    'ConnectionOptionsAttributeEmailSignupVerificationArgs',
    'ConnectionOptionsAttributeEmailSignupVerificationArgsDict',
    'ConnectionOptionsAttributeMapArgs',
    'ConnectionOptionsAttributeMapArgsDict',
    'ConnectionOptionsAttributePhoneNumberArgs',
    'ConnectionOptionsAttributePhoneNumberArgsDict',
    'ConnectionOptionsAttributePhoneNumberIdentifierArgs',
    'ConnectionOptionsAttributePhoneNumberIdentifierArgsDict',
    'ConnectionOptionsAttributePhoneNumberSignupArgs',
    'ConnectionOptionsAttributePhoneNumberSignupArgsDict',
    'ConnectionOptionsAttributePhoneNumberSignupVerificationArgs',
    'ConnectionOptionsAttributePhoneNumberSignupVerificationArgsDict',
    'ConnectionOptionsAttributeUsernameArgs',
    'ConnectionOptionsAttributeUsernameArgsDict',
    'ConnectionOptionsAttributeUsernameIdentifierArgs',
    'ConnectionOptionsAttributeUsernameIdentifierArgsDict',
    'ConnectionOptionsAttributeUsernameSignupArgs',
    'ConnectionOptionsAttributeUsernameSignupArgsDict',
    'ConnectionOptionsAttributeUsernameValidationArgs',
    'ConnectionOptionsAttributeUsernameValidationArgsDict',
    'ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs',
    'ConnectionOptionsAttributeUsernameValidationAllowedTypeArgsDict',
    'ConnectionOptionsConnectionSettingsArgs',
    'ConnectionOptionsConnectionSettingsArgsDict',
    'ConnectionOptionsDecryptionKeyArgs',
    'ConnectionOptionsDecryptionKeyArgsDict',
    'ConnectionOptionsGatewayAuthenticationArgs',
    'ConnectionOptionsGatewayAuthenticationArgsDict',
    'ConnectionOptionsIdpInitiatedArgs',
    'ConnectionOptionsIdpInitiatedArgsDict',
    'ConnectionOptionsMfaArgs',
    'ConnectionOptionsMfaArgsDict',
    'ConnectionOptionsPasswordComplexityOptionsArgs',
    'ConnectionOptionsPasswordComplexityOptionsArgsDict',
    'ConnectionOptionsPasswordDictionaryArgs',
    'ConnectionOptionsPasswordDictionaryArgsDict',
    'ConnectionOptionsPasswordHistoryArgs',
    'ConnectionOptionsPasswordHistoryArgsDict',
    'ConnectionOptionsPasswordNoPersonalInfoArgs',
    'ConnectionOptionsPasswordNoPersonalInfoArgsDict',
    'ConnectionOptionsSigningKeyArgs',
    'ConnectionOptionsSigningKeyArgsDict',
    'ConnectionOptionsTotpArgs',
    'ConnectionOptionsTotpArgsDict',
    'ConnectionOptionsValidationArgs',
    'ConnectionOptionsValidationArgsDict',
    'ConnectionOptionsValidationUsernameArgs',
    'ConnectionOptionsValidationUsernameArgsDict',
    'ConnectionScimConfigurationMappingArgs',
    'ConnectionScimConfigurationMappingArgsDict',
    'CustomDomainVerificationArgs',
    'CustomDomainVerificationArgsDict',
    'EmailProviderCredentialsArgs',
    'EmailProviderCredentialsArgsDict',
    'EmailProviderSettingsArgs',
    'EmailProviderSettingsArgsDict',
    'EmailProviderSettingsHeadersArgs',
    'EmailProviderSettingsHeadersArgsDict',
    'EmailProviderSettingsMessageArgs',
    'EmailProviderSettingsMessageArgsDict',
    'EncryptionKeyManagerCustomerProvidedRootKeyArgs',
    'EncryptionKeyManagerCustomerProvidedRootKeyArgsDict',
    'EncryptionKeyManagerEncryptionKeyArgs',
    'EncryptionKeyManagerEncryptionKeyArgsDict',
    'FormLanguageArgs',
    'FormLanguageArgsDict',
    'FormMessageArgs',
    'FormMessageArgsDict',
    'GuardianDuoArgs',
    'GuardianDuoArgsDict',
    'GuardianPhoneArgs',
    'GuardianPhoneArgsDict',
    'GuardianPhoneOptionsArgs',
    'GuardianPhoneOptionsArgsDict',
    'GuardianPushArgs',
    'GuardianPushArgsDict',
    'GuardianPushAmazonSnsArgs',
    'GuardianPushAmazonSnsArgsDict',
    'GuardianPushCustomAppArgs',
    'GuardianPushCustomAppArgsDict',
    'GuardianPushDirectApnsArgs',
    'GuardianPushDirectApnsArgsDict',
    'GuardianPushDirectFcmArgs',
    'GuardianPushDirectFcmArgsDict',
    'GuardianWebauthnPlatformArgs',
    'GuardianWebauthnPlatformArgsDict',
    'GuardianWebauthnRoamingArgs',
    'GuardianWebauthnRoamingArgsDict',
    'LogStreamSinkArgs',
    'LogStreamSinkArgsDict',
    'OrganizationBrandingArgs',
    'OrganizationBrandingArgsDict',
    'OrganizationConnectionsEnabledConnectionArgs',
    'OrganizationConnectionsEnabledConnectionArgsDict',
    'PagesChangePasswordArgs',
    'PagesChangePasswordArgsDict',
    'PagesErrorArgs',
    'PagesErrorArgsDict',
    'PagesGuardianMfaArgs',
    'PagesGuardianMfaArgsDict',
    'PagesLoginArgs',
    'PagesLoginArgsDict',
    'PromptScreenPartialInsertionPointsArgs',
    'PromptScreenPartialInsertionPointsArgsDict',
    'PromptScreenPartialsScreenPartialArgs',
    'PromptScreenPartialsScreenPartialArgsDict',
    'PromptScreenPartialsScreenPartialInsertionPointsArgs',
    'PromptScreenPartialsScreenPartialInsertionPointsArgsDict',
    'ResourceServerAuthorizationDetailArgs',
    'ResourceServerAuthorizationDetailArgsDict',
    'ResourceServerProofOfPossessionArgs',
    'ResourceServerProofOfPossessionArgsDict',
    'ResourceServerScopesScopeArgs',
    'ResourceServerScopesScopeArgsDict',
    'ResourceServerTokenEncryptionArgs',
    'ResourceServerTokenEncryptionArgsDict',
    'ResourceServerTokenEncryptionEncryptionKeyArgs',
    'ResourceServerTokenEncryptionEncryptionKeyArgsDict',
    'RolePermissionsPermissionArgs',
    'RolePermissionsPermissionArgsDict',
    'SelfServiceProfileBrandingArgs',
    'SelfServiceProfileBrandingArgsDict',
    'SelfServiceProfileBrandingColorsArgs',
    'SelfServiceProfileBrandingColorsArgsDict',
    'SelfServiceProfileUserAttributeArgs',
    'SelfServiceProfileUserAttributeArgsDict',
    'TenantFlagsArgs',
    'TenantFlagsArgsDict',
    'TenantMtlsArgs',
    'TenantMtlsArgsDict',
    'TenantSessionCookieArgs',
    'TenantSessionCookieArgsDict',
    'TenantSessionsArgs',
    'TenantSessionsArgsDict',
    'TriggerActionsActionArgs',
    'TriggerActionsActionArgsDict',
    'UserPermissionsPermissionArgs',
    'UserPermissionsPermissionArgsDict',
    'GetConnectionScimConfigurationDefaultMappingArgs',
    'GetConnectionScimConfigurationDefaultMappingArgsDict',
    'GetConnectionScimConfigurationMappingArgs',
    'GetConnectionScimConfigurationMappingArgsDict',
    'GetPromptScreenPartialsScreenPartialArgs',
    'GetPromptScreenPartialsScreenPartialArgsDict',
    'GetPromptScreenPartialsScreenPartialInsertionPointArgs',
    'GetPromptScreenPartialsScreenPartialInsertionPointArgsDict',
]

MYPY = False

if not MYPY:
    class ActionDependencyArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Dependency name, e.g. `lodash`.
        """
        version: pulumi.Input[str]
        """
        Dependency version, e.g. `latest` or `4.17.21`.
        """
elif False:
    ActionDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionDependencyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Dependency name, e.g. `lodash`.
        :param pulumi.Input[str] version: Dependency version, e.g. `latest` or `4.17.21`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Dependency name, e.g. `lodash`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Dependency version, e.g. `latest` or `4.17.21`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ActionSecretArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Secret name.
        """
        value: pulumi.Input[str]
        """
        Secret value.
        """
elif False:
    ActionSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Secret name.
        :param pulumi.Input[str] value: Secret value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Secret name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Secret value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ActionSupportedTriggersArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The trigger ID.
        """
        version: pulumi.Input[str]
        """
        The trigger version. This regulates which `runtime` versions are supported.
        """
elif False:
    ActionSupportedTriggersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionSupportedTriggersArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The trigger ID.
        :param pulumi.Input[str] version: The trigger version. This regulates which `runtime` versions are supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The trigger ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The trigger version. This regulates which `runtime` versions are supported.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AttackProtectionBreachedPasswordDetectionArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether breached password detection is active.
        """
        admin_notification_frequencies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        """
        pre_user_registration: NotRequired[pulumi.Input['AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgsDict']]
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        shields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
elif False:
    AttackProtectionBreachedPasswordDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionBreachedPasswordDetectionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 admin_notification_frequencies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 pre_user_registration: Optional[pulumi.Input['AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs']] = None,
                 shields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether breached password detection is active.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] admin_notification_frequencies: When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        :param pulumi.Input[str] method: The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        :param pulumi.Input['AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs'] pre_user_registration: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shields: Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        pulumi.set(__self__, "enabled", enabled)
        if admin_notification_frequencies is not None:
            pulumi.set(__self__, "admin_notification_frequencies", admin_notification_frequencies)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if pre_user_registration is not None:
            pulumi.set(__self__, "pre_user_registration", pre_user_registration)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether breached password detection is active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="adminNotificationFrequencies")
    def admin_notification_frequencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        When `admin_notification` is enabled within the `shields` property, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
        """
        return pulumi.get(self, "admin_notification_frequencies")

    @admin_notification_frequencies.setter
    def admin_notification_frequencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "admin_notification_frequencies", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="preUserRegistration")
    def pre_user_registration(self) -> Optional[pulumi.Input['AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs']]:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registration")

    @pre_user_registration.setter
    def pre_user_registration(self, value: Optional[pulumi.Input['AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs']]):
        pulumi.set(self, "pre_user_registration", value)

    @property
    @pulumi.getter
    def shields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action to take when a breached password is detected. Options include: `block` (block compromised user accounts), `user_notification` (send an email to user when we detect that they are using compromised credentials) and `admin_notification` (send an email with a summary of the number of accounts logging in with compromised credentials).
        """
        return pulumi.get(self, "shields")

    @shields.setter
    def shields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shields", value)


if not MYPY:
    class AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgsDict(TypedDict):
        shields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
elif False:
    AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionBreachedPasswordDetectionPreUserRegistrationArgs:
    def __init__(__self__, *,
                 shields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shields: Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @property
    @pulumi.getter
    def shields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action to take when a breached password is detected during a signup. Possible values: `block` (block compromised credentials for new accounts), `admin_notification` (send an email notification with a summary of compromised credentials in new accounts).
        """
        return pulumi.get(self, "shields")

    @shields.setter
    def shields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shields", value)


if not MYPY:
    class AttackProtectionBruteForceProtectionArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether brute force attack protections are active.
        """
        allowlists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        """
        shields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
elif False:
    AttackProtectionBruteForceProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionBruteForceProtectionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 allowlists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_attempts: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 shields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether brute force attack protections are active.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param pulumi.Input[int] max_attempts: Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        :param pulumi.Input[str] mode: Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shields: Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowlists is not None:
            pulumi.set(__self__, "allowlists", allowlists)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether brute force attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def allowlists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @allowlists.setter
    def allowlists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowlists", value)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of consecutive failed login attempts from a single user before blocking is triggered. Only available on public tenants.
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether the IP address is used when counting failed attempts. Possible values: `count_per_identifier_and_ip` (lockout an account from a given IP Address) or `count_per_identifier` (lockout an account regardless of IP Address).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def shields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action to take when a brute force protection threshold is violated. Possible values: `block` (block login attempts for a flagged user account), `user_notification` (send an email to user when their account has been blocked).
        """
        return pulumi.get(self, "shields")

    @shields.setter
    def shields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shields", value)


if not MYPY:
    class AttackProtectionSuspiciousIpThrottlingArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether suspicious IP throttling attack protections are active.
        """
        allowlists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        pre_login: NotRequired[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreLoginArgsDict']]
        """
        Configuration options that apply before every login attempt. Only available on public tenants.
        """
        pre_user_registration: NotRequired[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgsDict']]
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        shields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
elif False:
    AttackProtectionSuspiciousIpThrottlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionSuspiciousIpThrottlingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 allowlists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pre_login: Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreLoginArgs']] = None,
                 pre_user_registration: Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs']] = None,
                 shields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether suspicious IP throttling attack protections are active.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowlists: List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        :param pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreLoginArgs'] pre_login: Configuration options that apply before every login attempt. Only available on public tenants.
        :param pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs'] pre_user_registration: Configuration options that apply before every user registration attempt. Only available on public tenants.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shields: Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowlists is not None:
            pulumi.set(__self__, "allowlists", allowlists)
        if pre_login is not None:
            pulumi.set(__self__, "pre_login", pre_login)
        if pre_user_registration is not None:
            pulumi.set(__self__, "pre_user_registration", pre_user_registration)
        if shields is not None:
            pulumi.set(__self__, "shields", shields)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether suspicious IP throttling attack protections are active.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def allowlists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trusted IP addresses that will not have attack protection enforced against them. This field allows you to specify multiple IP addresses, or ranges. You can use IPv4 or IPv6 addresses and CIDR notation.
        """
        return pulumi.get(self, "allowlists")

    @allowlists.setter
    def allowlists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowlists", value)

    @property
    @pulumi.getter(name="preLogin")
    def pre_login(self) -> Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreLoginArgs']]:
        """
        Configuration options that apply before every login attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_login")

    @pre_login.setter
    def pre_login(self, value: Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreLoginArgs']]):
        pulumi.set(self, "pre_login", value)

    @property
    @pulumi.getter(name="preUserRegistration")
    def pre_user_registration(self) -> Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs']]:
        """
        Configuration options that apply before every user registration attempt. Only available on public tenants.
        """
        return pulumi.get(self, "pre_user_registration")

    @pre_user_registration.setter
    def pre_user_registration(self, value: Optional[pulumi.Input['AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs']]):
        pulumi.set(self, "pre_user_registration", value)

    @property
    @pulumi.getter
    def shields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Action to take when a suspicious IP throttling threshold is violated. Possible values: `block` (throttle traffic from an IP address when there is a high number of login attempts targeting too many different accounts), `admin_notification` (send an email notification when traffic is throttled on one or more IP addresses due to high-velocity traffic).
        """
        return pulumi.get(self, "shields")

    @shields.setter
    def shields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shields", value)


if not MYPY:
    class AttackProtectionSuspiciousIpThrottlingPreLoginArgsDict(TypedDict):
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of failed login attempts allowed from a single IP address.
        """
        rate: NotRequired[pulumi.Input[int]]
        """
        Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
elif False:
    AttackProtectionSuspiciousIpThrottlingPreLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionSuspiciousIpThrottlingPreLoginArgs:
    def __init__(__self__, *,
                 max_attempts: Optional[pulumi.Input[int]] = None,
                 rate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_attempts: The maximum number of failed login attempts allowed from a single IP address.
        :param pulumi.Input[int] rate: Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of failed login attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[int]]:
        """
        Interval of time, given in milliseconds at which new login tokens will become available after they have been used by an IP address. Each login attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate", value)


if not MYPY:
    class AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgsDict(TypedDict):
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of sign up attempts allowed from a single IP address.
        """
        rate: NotRequired[pulumi.Input[int]]
        """
        Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
elif False:
    AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttackProtectionSuspiciousIpThrottlingPreUserRegistrationArgs:
    def __init__(__self__, *,
                 max_attempts: Optional[pulumi.Input[int]] = None,
                 rate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_attempts: The maximum number of sign up attempts allowed from a single IP address.
        :param pulumi.Input[int] rate: Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of sign up attempts allowed from a single IP address.
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[int]]:
        """
        Interval of time, given in milliseconds at which new sign up tokens will become available after they have been used by an IP address. Each sign up attempt will be added on the defined throttling rate.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate", value)


if not MYPY:
    class BrandingColorsArgsDict(TypedDict):
        page_background: NotRequired[pulumi.Input[str]]
        """
        Background color of login pages in hexadecimal.
        """
        primary: NotRequired[pulumi.Input[str]]
        """
        Primary button background color in hexadecimal.
        """
elif False:
    BrandingColorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingColorsArgs:
    def __init__(__self__, *,
                 page_background: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] page_background: Background color of login pages in hexadecimal.
        :param pulumi.Input[str] primary: Primary button background color in hexadecimal.
        """
        if page_background is not None:
            pulumi.set(__self__, "page_background", page_background)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="pageBackground")
    def page_background(self) -> Optional[pulumi.Input[str]]:
        """
        Background color of login pages in hexadecimal.
        """
        return pulumi.get(self, "page_background")

    @page_background.setter
    def page_background(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_background", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[str]]:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary", value)


if not MYPY:
    class BrandingFontArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        URL for the custom font.
        """
elif False:
    BrandingFontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingFontArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: URL for the custom font.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for the custom font.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class BrandingThemeBordersArgsDict(TypedDict):
        button_border_radius: NotRequired[pulumi.Input[float]]
        """
        Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        """
        button_border_weight: NotRequired[pulumi.Input[float]]
        """
        Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        """
        buttons_style: NotRequired[pulumi.Input[str]]
        """
        Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        input_border_radius: NotRequired[pulumi.Input[float]]
        """
        Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        """
        input_border_weight: NotRequired[pulumi.Input[float]]
        """
        Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        """
        inputs_style: NotRequired[pulumi.Input[str]]
        """
        Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        show_widget_shadow: NotRequired[pulumi.Input[bool]]
        """
        Show widget shadow. Defaults to `true`.
        """
        widget_border_weight: NotRequired[pulumi.Input[float]]
        """
        Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        """
        widget_corner_radius: NotRequired[pulumi.Input[float]]
        """
        Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
elif False:
    BrandingThemeBordersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeBordersArgs:
    def __init__(__self__, *,
                 button_border_radius: Optional[pulumi.Input[float]] = None,
                 button_border_weight: Optional[pulumi.Input[float]] = None,
                 buttons_style: Optional[pulumi.Input[str]] = None,
                 input_border_radius: Optional[pulumi.Input[float]] = None,
                 input_border_weight: Optional[pulumi.Input[float]] = None,
                 inputs_style: Optional[pulumi.Input[str]] = None,
                 show_widget_shadow: Optional[pulumi.Input[bool]] = None,
                 widget_border_weight: Optional[pulumi.Input[float]] = None,
                 widget_corner_radius: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] button_border_radius: Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        :param pulumi.Input[float] button_border_weight: Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        :param pulumi.Input[str] buttons_style: Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param pulumi.Input[float] input_border_radius: Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        :param pulumi.Input[float] input_border_weight: Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        :param pulumi.Input[str] inputs_style: Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        :param pulumi.Input[bool] show_widget_shadow: Show widget shadow. Defaults to `true`.
        :param pulumi.Input[float] widget_border_weight: Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        :param pulumi.Input[float] widget_corner_radius: Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        if button_border_radius is not None:
            pulumi.set(__self__, "button_border_radius", button_border_radius)
        if button_border_weight is not None:
            pulumi.set(__self__, "button_border_weight", button_border_weight)
        if buttons_style is not None:
            pulumi.set(__self__, "buttons_style", buttons_style)
        if input_border_radius is not None:
            pulumi.set(__self__, "input_border_radius", input_border_radius)
        if input_border_weight is not None:
            pulumi.set(__self__, "input_border_weight", input_border_weight)
        if inputs_style is not None:
            pulumi.set(__self__, "inputs_style", inputs_style)
        if show_widget_shadow is not None:
            pulumi.set(__self__, "show_widget_shadow", show_widget_shadow)
        if widget_border_weight is not None:
            pulumi.set(__self__, "widget_border_weight", widget_border_weight)
        if widget_corner_radius is not None:
            pulumi.set(__self__, "widget_corner_radius", widget_corner_radius)

    @property
    @pulumi.getter(name="buttonBorderRadius")
    def button_border_radius(self) -> Optional[pulumi.Input[float]]:
        """
        Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "button_border_radius")

    @button_border_radius.setter
    def button_border_radius(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "button_border_radius", value)

    @property
    @pulumi.getter(name="buttonBorderWeight")
    def button_border_weight(self) -> Optional[pulumi.Input[float]]:
        """
        Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
        """
        return pulumi.get(self, "button_border_weight")

    @button_border_weight.setter
    def button_border_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "button_border_weight", value)

    @property
    @pulumi.getter(name="buttonsStyle")
    def buttons_style(self) -> Optional[pulumi.Input[str]]:
        """
        Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "buttons_style")

    @buttons_style.setter
    def buttons_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buttons_style", value)

    @property
    @pulumi.getter(name="inputBorderRadius")
    def input_border_radius(self) -> Optional[pulumi.Input[float]]:
        """
        Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
        """
        return pulumi.get(self, "input_border_radius")

    @input_border_radius.setter
    def input_border_radius(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "input_border_radius", value)

    @property
    @pulumi.getter(name="inputBorderWeight")
    def input_border_weight(self) -> Optional[pulumi.Input[float]]:
        """
        Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
        """
        return pulumi.get(self, "input_border_weight")

    @input_border_weight.setter
    def input_border_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "input_border_weight", value)

    @property
    @pulumi.getter(name="inputsStyle")
    def inputs_style(self) -> Optional[pulumi.Input[str]]:
        """
        Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
        """
        return pulumi.get(self, "inputs_style")

    @inputs_style.setter
    def inputs_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inputs_style", value)

    @property
    @pulumi.getter(name="showWidgetShadow")
    def show_widget_shadow(self) -> Optional[pulumi.Input[bool]]:
        """
        Show widget shadow. Defaults to `true`.
        """
        return pulumi.get(self, "show_widget_shadow")

    @show_widget_shadow.setter
    def show_widget_shadow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_widget_shadow", value)

    @property
    @pulumi.getter(name="widgetBorderWeight")
    def widget_border_weight(self) -> Optional[pulumi.Input[float]]:
        """
        Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
        """
        return pulumi.get(self, "widget_border_weight")

    @widget_border_weight.setter
    def widget_border_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "widget_border_weight", value)

    @property
    @pulumi.getter(name="widgetCornerRadius")
    def widget_corner_radius(self) -> Optional[pulumi.Input[float]]:
        """
        Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
        """
        return pulumi.get(self, "widget_corner_radius")

    @widget_corner_radius.setter
    def widget_corner_radius(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "widget_corner_radius", value)


if not MYPY:
    class BrandingThemeColorsArgsDict(TypedDict):
        base_focus_color: NotRequired[pulumi.Input[str]]
        """
        Base focus color. Defaults to `#635dff`.
        """
        base_hover_color: NotRequired[pulumi.Input[str]]
        """
        Base hover color. Defaults to `#000000`.
        """
        body_text: NotRequired[pulumi.Input[str]]
        """
        Body text. Defaults to `#1e212a`.
        """
        error: NotRequired[pulumi.Input[str]]
        """
        Error. Defaults to `#d03c38`.
        """
        header: NotRequired[pulumi.Input[str]]
        """
        Header. Defaults to `#1e212a`.
        """
        icons: NotRequired[pulumi.Input[str]]
        """
        Icons. Defaults to `#65676e`.
        """
        input_background: NotRequired[pulumi.Input[str]]
        """
        Input background. Defaults to `#ffffff`.
        """
        input_border: NotRequired[pulumi.Input[str]]
        """
        Input border. Defaults to `#c9cace`.
        """
        input_filled_text: NotRequired[pulumi.Input[str]]
        """
        Input filled text. Defaults to `#000000`.
        """
        input_labels_placeholders: NotRequired[pulumi.Input[str]]
        """
        Input labels & placeholders. Defaults to `#65676e`.
        """
        links_focused_components: NotRequired[pulumi.Input[str]]
        """
        Links & focused components. Defaults to `#635dff`.
        """
        primary_button: NotRequired[pulumi.Input[str]]
        """
        Primary button. Defaults to `#635dff`.
        """
        primary_button_label: NotRequired[pulumi.Input[str]]
        """
        Primary button label. Defaults to `#ffffff`.
        """
        secondary_button_border: NotRequired[pulumi.Input[str]]
        """
        Secondary button border. Defaults to `#c9cace`.
        """
        secondary_button_label: NotRequired[pulumi.Input[str]]
        """
        Secondary button label. Defaults to `#1e212a`.
        """
        success: NotRequired[pulumi.Input[str]]
        """
        Success. Defaults to `#13a688`.
        """
        widget_background: NotRequired[pulumi.Input[str]]
        """
        Widget background. Defaults to `#ffffff`.
        """
        widget_border: NotRequired[pulumi.Input[str]]
        """
        Widget border. Defaults to `#c9cace`.
        """
elif False:
    BrandingThemeColorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeColorsArgs:
    def __init__(__self__, *,
                 base_focus_color: Optional[pulumi.Input[str]] = None,
                 base_hover_color: Optional[pulumi.Input[str]] = None,
                 body_text: Optional[pulumi.Input[str]] = None,
                 error: Optional[pulumi.Input[str]] = None,
                 header: Optional[pulumi.Input[str]] = None,
                 icons: Optional[pulumi.Input[str]] = None,
                 input_background: Optional[pulumi.Input[str]] = None,
                 input_border: Optional[pulumi.Input[str]] = None,
                 input_filled_text: Optional[pulumi.Input[str]] = None,
                 input_labels_placeholders: Optional[pulumi.Input[str]] = None,
                 links_focused_components: Optional[pulumi.Input[str]] = None,
                 primary_button: Optional[pulumi.Input[str]] = None,
                 primary_button_label: Optional[pulumi.Input[str]] = None,
                 secondary_button_border: Optional[pulumi.Input[str]] = None,
                 secondary_button_label: Optional[pulumi.Input[str]] = None,
                 success: Optional[pulumi.Input[str]] = None,
                 widget_background: Optional[pulumi.Input[str]] = None,
                 widget_border: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_focus_color: Base focus color. Defaults to `#635dff`.
        :param pulumi.Input[str] base_hover_color: Base hover color. Defaults to `#000000`.
        :param pulumi.Input[str] body_text: Body text. Defaults to `#1e212a`.
        :param pulumi.Input[str] error: Error. Defaults to `#d03c38`.
        :param pulumi.Input[str] header: Header. Defaults to `#1e212a`.
        :param pulumi.Input[str] icons: Icons. Defaults to `#65676e`.
        :param pulumi.Input[str] input_background: Input background. Defaults to `#ffffff`.
        :param pulumi.Input[str] input_border: Input border. Defaults to `#c9cace`.
        :param pulumi.Input[str] input_filled_text: Input filled text. Defaults to `#000000`.
        :param pulumi.Input[str] input_labels_placeholders: Input labels & placeholders. Defaults to `#65676e`.
        :param pulumi.Input[str] links_focused_components: Links & focused components. Defaults to `#635dff`.
        :param pulumi.Input[str] primary_button: Primary button. Defaults to `#635dff`.
        :param pulumi.Input[str] primary_button_label: Primary button label. Defaults to `#ffffff`.
        :param pulumi.Input[str] secondary_button_border: Secondary button border. Defaults to `#c9cace`.
        :param pulumi.Input[str] secondary_button_label: Secondary button label. Defaults to `#1e212a`.
        :param pulumi.Input[str] success: Success. Defaults to `#13a688`.
        :param pulumi.Input[str] widget_background: Widget background. Defaults to `#ffffff`.
        :param pulumi.Input[str] widget_border: Widget border. Defaults to `#c9cace`.
        """
        if base_focus_color is not None:
            pulumi.set(__self__, "base_focus_color", base_focus_color)
        if base_hover_color is not None:
            pulumi.set(__self__, "base_hover_color", base_hover_color)
        if body_text is not None:
            pulumi.set(__self__, "body_text", body_text)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if icons is not None:
            pulumi.set(__self__, "icons", icons)
        if input_background is not None:
            pulumi.set(__self__, "input_background", input_background)
        if input_border is not None:
            pulumi.set(__self__, "input_border", input_border)
        if input_filled_text is not None:
            pulumi.set(__self__, "input_filled_text", input_filled_text)
        if input_labels_placeholders is not None:
            pulumi.set(__self__, "input_labels_placeholders", input_labels_placeholders)
        if links_focused_components is not None:
            pulumi.set(__self__, "links_focused_components", links_focused_components)
        if primary_button is not None:
            pulumi.set(__self__, "primary_button", primary_button)
        if primary_button_label is not None:
            pulumi.set(__self__, "primary_button_label", primary_button_label)
        if secondary_button_border is not None:
            pulumi.set(__self__, "secondary_button_border", secondary_button_border)
        if secondary_button_label is not None:
            pulumi.set(__self__, "secondary_button_label", secondary_button_label)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if widget_background is not None:
            pulumi.set(__self__, "widget_background", widget_background)
        if widget_border is not None:
            pulumi.set(__self__, "widget_border", widget_border)

    @property
    @pulumi.getter(name="baseFocusColor")
    def base_focus_color(self) -> Optional[pulumi.Input[str]]:
        """
        Base focus color. Defaults to `#635dff`.
        """
        return pulumi.get(self, "base_focus_color")

    @base_focus_color.setter
    def base_focus_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_focus_color", value)

    @property
    @pulumi.getter(name="baseHoverColor")
    def base_hover_color(self) -> Optional[pulumi.Input[str]]:
        """
        Base hover color. Defaults to `#000000`.
        """
        return pulumi.get(self, "base_hover_color")

    @base_hover_color.setter
    def base_hover_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_hover_color", value)

    @property
    @pulumi.getter(name="bodyText")
    def body_text(self) -> Optional[pulumi.Input[str]]:
        """
        Body text. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "body_text")

    @body_text.setter
    def body_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_text", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[str]]:
        """
        Error. Defaults to `#d03c38`.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[str]]:
        """
        Header. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def icons(self) -> Optional[pulumi.Input[str]]:
        """
        Icons. Defaults to `#65676e`.
        """
        return pulumi.get(self, "icons")

    @icons.setter
    def icons(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icons", value)

    @property
    @pulumi.getter(name="inputBackground")
    def input_background(self) -> Optional[pulumi.Input[str]]:
        """
        Input background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "input_background")

    @input_background.setter
    def input_background(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_background", value)

    @property
    @pulumi.getter(name="inputBorder")
    def input_border(self) -> Optional[pulumi.Input[str]]:
        """
        Input border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "input_border")

    @input_border.setter
    def input_border(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_border", value)

    @property
    @pulumi.getter(name="inputFilledText")
    def input_filled_text(self) -> Optional[pulumi.Input[str]]:
        """
        Input filled text. Defaults to `#000000`.
        """
        return pulumi.get(self, "input_filled_text")

    @input_filled_text.setter
    def input_filled_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_filled_text", value)

    @property
    @pulumi.getter(name="inputLabelsPlaceholders")
    def input_labels_placeholders(self) -> Optional[pulumi.Input[str]]:
        """
        Input labels & placeholders. Defaults to `#65676e`.
        """
        return pulumi.get(self, "input_labels_placeholders")

    @input_labels_placeholders.setter
    def input_labels_placeholders(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_labels_placeholders", value)

    @property
    @pulumi.getter(name="linksFocusedComponents")
    def links_focused_components(self) -> Optional[pulumi.Input[str]]:
        """
        Links & focused components. Defaults to `#635dff`.
        """
        return pulumi.get(self, "links_focused_components")

    @links_focused_components.setter
    def links_focused_components(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "links_focused_components", value)

    @property
    @pulumi.getter(name="primaryButton")
    def primary_button(self) -> Optional[pulumi.Input[str]]:
        """
        Primary button. Defaults to `#635dff`.
        """
        return pulumi.get(self, "primary_button")

    @primary_button.setter
    def primary_button(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_button", value)

    @property
    @pulumi.getter(name="primaryButtonLabel")
    def primary_button_label(self) -> Optional[pulumi.Input[str]]:
        """
        Primary button label. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "primary_button_label")

    @primary_button_label.setter
    def primary_button_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_button_label", value)

    @property
    @pulumi.getter(name="secondaryButtonBorder")
    def secondary_button_border(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary button border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "secondary_button_border")

    @secondary_button_border.setter
    def secondary_button_border(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_button_border", value)

    @property
    @pulumi.getter(name="secondaryButtonLabel")
    def secondary_button_label(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary button label. Defaults to `#1e212a`.
        """
        return pulumi.get(self, "secondary_button_label")

    @secondary_button_label.setter
    def secondary_button_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_button_label", value)

    @property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[str]]:
        """
        Success. Defaults to `#13a688`.
        """
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success", value)

    @property
    @pulumi.getter(name="widgetBackground")
    def widget_background(self) -> Optional[pulumi.Input[str]]:
        """
        Widget background. Defaults to `#ffffff`.
        """
        return pulumi.get(self, "widget_background")

    @widget_background.setter
    def widget_background(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "widget_background", value)

    @property
    @pulumi.getter(name="widgetBorder")
    def widget_border(self) -> Optional[pulumi.Input[str]]:
        """
        Widget border. Defaults to `#c9cace`.
        """
        return pulumi.get(self, "widget_border")

    @widget_border.setter
    def widget_border(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "widget_border", value)


if not MYPY:
    class BrandingThemeFontsArgsDict(TypedDict):
        body_text: pulumi.Input['BrandingThemeFontsBodyTextArgsDict']
        """
        Body text.
        """
        buttons_text: pulumi.Input['BrandingThemeFontsButtonsTextArgsDict']
        """
        Buttons text.
        """
        input_labels: pulumi.Input['BrandingThemeFontsInputLabelsArgsDict']
        """
        Input labels.
        """
        links: pulumi.Input['BrandingThemeFontsLinksArgsDict']
        """
        Links.
        """
        subtitle: pulumi.Input['BrandingThemeFontsSubtitleArgsDict']
        """
        Subtitle.
        """
        title: pulumi.Input['BrandingThemeFontsTitleArgsDict']
        """
        Title.
        """
        font_url: NotRequired[pulumi.Input[str]]
        """
        Font URL. Defaults to an empty string.
        """
        links_style: NotRequired[pulumi.Input[str]]
        """
        Links style. Defaults to `normal`.
        """
        reference_text_size: NotRequired[pulumi.Input[float]]
        """
        Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
elif False:
    BrandingThemeFontsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsArgs:
    def __init__(__self__, *,
                 body_text: pulumi.Input['BrandingThemeFontsBodyTextArgs'],
                 buttons_text: pulumi.Input['BrandingThemeFontsButtonsTextArgs'],
                 input_labels: pulumi.Input['BrandingThemeFontsInputLabelsArgs'],
                 links: pulumi.Input['BrandingThemeFontsLinksArgs'],
                 subtitle: pulumi.Input['BrandingThemeFontsSubtitleArgs'],
                 title: pulumi.Input['BrandingThemeFontsTitleArgs'],
                 font_url: Optional[pulumi.Input[str]] = None,
                 links_style: Optional[pulumi.Input[str]] = None,
                 reference_text_size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['BrandingThemeFontsBodyTextArgs'] body_text: Body text.
        :param pulumi.Input['BrandingThemeFontsButtonsTextArgs'] buttons_text: Buttons text.
        :param pulumi.Input['BrandingThemeFontsInputLabelsArgs'] input_labels: Input labels.
        :param pulumi.Input['BrandingThemeFontsLinksArgs'] links: Links.
        :param pulumi.Input['BrandingThemeFontsSubtitleArgs'] subtitle: Subtitle.
        :param pulumi.Input['BrandingThemeFontsTitleArgs'] title: Title.
        :param pulumi.Input[str] font_url: Font URL. Defaults to an empty string.
        :param pulumi.Input[str] links_style: Links style. Defaults to `normal`.
        :param pulumi.Input[float] reference_text_size: Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
        pulumi.set(__self__, "body_text", body_text)
        pulumi.set(__self__, "buttons_text", buttons_text)
        pulumi.set(__self__, "input_labels", input_labels)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "subtitle", subtitle)
        pulumi.set(__self__, "title", title)
        if font_url is not None:
            pulumi.set(__self__, "font_url", font_url)
        if links_style is not None:
            pulumi.set(__self__, "links_style", links_style)
        if reference_text_size is not None:
            pulumi.set(__self__, "reference_text_size", reference_text_size)

    @property
    @pulumi.getter(name="bodyText")
    def body_text(self) -> pulumi.Input['BrandingThemeFontsBodyTextArgs']:
        """
        Body text.
        """
        return pulumi.get(self, "body_text")

    @body_text.setter
    def body_text(self, value: pulumi.Input['BrandingThemeFontsBodyTextArgs']):
        pulumi.set(self, "body_text", value)

    @property
    @pulumi.getter(name="buttonsText")
    def buttons_text(self) -> pulumi.Input['BrandingThemeFontsButtonsTextArgs']:
        """
        Buttons text.
        """
        return pulumi.get(self, "buttons_text")

    @buttons_text.setter
    def buttons_text(self, value: pulumi.Input['BrandingThemeFontsButtonsTextArgs']):
        pulumi.set(self, "buttons_text", value)

    @property
    @pulumi.getter(name="inputLabels")
    def input_labels(self) -> pulumi.Input['BrandingThemeFontsInputLabelsArgs']:
        """
        Input labels.
        """
        return pulumi.get(self, "input_labels")

    @input_labels.setter
    def input_labels(self, value: pulumi.Input['BrandingThemeFontsInputLabelsArgs']):
        pulumi.set(self, "input_labels", value)

    @property
    @pulumi.getter
    def links(self) -> pulumi.Input['BrandingThemeFontsLinksArgs']:
        """
        Links.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: pulumi.Input['BrandingThemeFontsLinksArgs']):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def subtitle(self) -> pulumi.Input['BrandingThemeFontsSubtitleArgs']:
        """
        Subtitle.
        """
        return pulumi.get(self, "subtitle")

    @subtitle.setter
    def subtitle(self, value: pulumi.Input['BrandingThemeFontsSubtitleArgs']):
        pulumi.set(self, "subtitle", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input['BrandingThemeFontsTitleArgs']:
        """
        Title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input['BrandingThemeFontsTitleArgs']):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="fontUrl")
    def font_url(self) -> Optional[pulumi.Input[str]]:
        """
        Font URL. Defaults to an empty string.
        """
        return pulumi.get(self, "font_url")

    @font_url.setter
    def font_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_url", value)

    @property
    @pulumi.getter(name="linksStyle")
    def links_style(self) -> Optional[pulumi.Input[str]]:
        """
        Links style. Defaults to `normal`.
        """
        return pulumi.get(self, "links_style")

    @links_style.setter
    def links_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "links_style", value)

    @property
    @pulumi.getter(name="referenceTextSize")
    def reference_text_size(self) -> Optional[pulumi.Input[float]]:
        """
        Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
        """
        return pulumi.get(self, "reference_text_size")

    @reference_text_size.setter
    def reference_text_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "reference_text_size", value)


if not MYPY:
    class BrandingThemeFontsBodyTextArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Body text bold. Defaults to `false`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
elif False:
    BrandingThemeFontsBodyTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsBodyTextArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Body text bold. Defaults to `false`.
        :param pulumi.Input[float] size: Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Body text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Body text size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemeFontsButtonsTextArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Buttons text bold. Defaults to `false`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
elif False:
    BrandingThemeFontsButtonsTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsButtonsTextArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Buttons text bold. Defaults to `false`.
        :param pulumi.Input[float] size: Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Buttons text bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Buttons text size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemeFontsInputLabelsArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Input labels bold. Defaults to `false`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
elif False:
    BrandingThemeFontsInputLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsInputLabelsArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Input labels bold. Defaults to `false`.
        :param pulumi.Input[float] size: Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Input labels bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Input labels size. Value needs to be between `0` and `150`. Defaults to `100.0`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemeFontsLinksArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Links bold. Defaults to `true`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
elif False:
    BrandingThemeFontsLinksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsLinksArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Links bold. Defaults to `true`.
        :param pulumi.Input[float] size: Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Links bold. Defaults to `true`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Links size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemeFontsSubtitleArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Subtitle bold. Defaults to `false`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
elif False:
    BrandingThemeFontsSubtitleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsSubtitleArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Subtitle bold. Defaults to `false`.
        :param pulumi.Input[float] size: Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Subtitle bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Subtitle size. Value needs to be between `0` and `150`. Defaults to `87.5`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemeFontsTitleArgsDict(TypedDict):
        bold: NotRequired[pulumi.Input[bool]]
        """
        Title bold. Defaults to `false`.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
elif False:
    BrandingThemeFontsTitleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeFontsTitleArgs:
    def __init__(__self__, *,
                 bold: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] bold: Title bold. Defaults to `false`.
        :param pulumi.Input[float] size: Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Title bold. Defaults to `false`.
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Title size. Value needs to be between `75` and `150`. Defaults to `150.0`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BrandingThemePageBackgroundArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        Background color. Defaults to `#000000`.
        """
        background_image_url: NotRequired[pulumi.Input[str]]
        """
        Background image url. Defaults to an empty string.
        """
        page_layout: NotRequired[pulumi.Input[str]]
        """
        Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
elif False:
    BrandingThemePageBackgroundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemePageBackgroundArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 background_image_url: Optional[pulumi.Input[str]] = None,
                 page_layout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: Background color. Defaults to `#000000`.
        :param pulumi.Input[str] background_image_url: Background image url. Defaults to an empty string.
        :param pulumi.Input[str] page_layout: Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if background_image_url is not None:
            pulumi.set(__self__, "background_image_url", background_image_url)
        if page_layout is not None:
            pulumi.set(__self__, "page_layout", page_layout)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Background color. Defaults to `#000000`.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="backgroundImageUrl")
    def background_image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Background image url. Defaults to an empty string.
        """
        return pulumi.get(self, "background_image_url")

    @background_image_url.setter
    def background_image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_image_url", value)

    @property
    @pulumi.getter(name="pageLayout")
    def page_layout(self) -> Optional[pulumi.Input[str]]:
        """
        Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "page_layout")

    @page_layout.setter
    def page_layout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_layout", value)


if not MYPY:
    class BrandingThemeWidgetArgsDict(TypedDict):
        header_text_alignment: NotRequired[pulumi.Input[str]]
        """
        Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        logo_height: NotRequired[pulumi.Input[float]]
        """
        Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        """
        logo_position: NotRequired[pulumi.Input[str]]
        """
        Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        """
        logo_url: NotRequired[pulumi.Input[str]]
        """
        Logo url. Defaults to an empty string.
        """
        social_buttons_layout: NotRequired[pulumi.Input[str]]
        """
        Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
elif False:
    BrandingThemeWidgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingThemeWidgetArgs:
    def __init__(__self__, *,
                 header_text_alignment: Optional[pulumi.Input[str]] = None,
                 logo_height: Optional[pulumi.Input[float]] = None,
                 logo_position: Optional[pulumi.Input[str]] = None,
                 logo_url: Optional[pulumi.Input[str]] = None,
                 social_buttons_layout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_text_alignment: Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        :param pulumi.Input[float] logo_height: Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        :param pulumi.Input[str] logo_position: Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        :param pulumi.Input[str] logo_url: Logo url. Defaults to an empty string.
        :param pulumi.Input[str] social_buttons_layout: Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        if header_text_alignment is not None:
            pulumi.set(__self__, "header_text_alignment", header_text_alignment)
        if logo_height is not None:
            pulumi.set(__self__, "logo_height", logo_height)
        if logo_position is not None:
            pulumi.set(__self__, "logo_position", logo_position)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)
        if social_buttons_layout is not None:
            pulumi.set(__self__, "social_buttons_layout", social_buttons_layout)

    @property
    @pulumi.getter(name="headerTextAlignment")
    def header_text_alignment(self) -> Optional[pulumi.Input[str]]:
        """
        Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
        """
        return pulumi.get(self, "header_text_alignment")

    @header_text_alignment.setter
    def header_text_alignment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text_alignment", value)

    @property
    @pulumi.getter(name="logoHeight")
    def logo_height(self) -> Optional[pulumi.Input[float]]:
        """
        Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
        """
        return pulumi.get(self, "logo_height")

    @logo_height.setter
    def logo_height(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "logo_height", value)

    @property
    @pulumi.getter(name="logoPosition")
    def logo_position(self) -> Optional[pulumi.Input[str]]:
        """
        Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
        """
        return pulumi.get(self, "logo_position")

    @logo_position.setter
    def logo_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_position", value)

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[pulumi.Input[str]]:
        """
        Logo url. Defaults to an empty string.
        """
        return pulumi.get(self, "logo_url")

    @logo_url.setter
    def logo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_url", value)

    @property
    @pulumi.getter(name="socialButtonsLayout")
    def social_buttons_layout(self) -> Optional[pulumi.Input[str]]:
        """
        Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
        """
        return pulumi.get(self, "social_buttons_layout")

    @social_buttons_layout.setter
    def social_buttons_layout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "social_buttons_layout", value)


if not MYPY:
    class BrandingUniversalLoginArgsDict(TypedDict):
        body: pulumi.Input[str]
        """
        The html template for the New Universal Login Experience.
        """
elif False:
    BrandingUniversalLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrandingUniversalLoginArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[str]):
        """
        :param pulumi.Input[str] body: The html template for the New Universal Login Experience.
        """
        pulumi.set(__self__, "body", body)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[str]:
        """
        The html template for the New Universal Login Experience.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[str]):
        pulumi.set(self, "body", value)


if not MYPY:
    class ClientAddonsArgsDict(TypedDict):
        aws: NotRequired[pulumi.Input['ClientAddonsAwsArgsDict']]
        """
        AWS Addon configuration.
        """
        azure_blob: NotRequired[pulumi.Input['ClientAddonsAzureBlobArgsDict']]
        """
        Azure Blob Storage Addon configuration.
        """
        azure_sb: NotRequired[pulumi.Input['ClientAddonsAzureSbArgsDict']]
        """
        Azure Storage Bus Addon configuration.
        """
        box: NotRequired[pulumi.Input['ClientAddonsBoxArgsDict']]
        """
        Box SSO indicator (no configuration settings needed for Box SSO).
        """
        cloudbees: NotRequired[pulumi.Input['ClientAddonsCloudbeesArgsDict']]
        """
        CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        """
        concur: NotRequired[pulumi.Input['ClientAddonsConcurArgsDict']]
        """
        Concur SSO indicator (no configuration settings needed for Concur SSO).
        """
        dropbox: NotRequired[pulumi.Input['ClientAddonsDropboxArgsDict']]
        """
        Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        """
        echosign: NotRequired[pulumi.Input['ClientAddonsEchosignArgsDict']]
        """
        Adobe EchoSign SSO configuration.
        """
        egnyte: NotRequired[pulumi.Input['ClientAddonsEgnyteArgsDict']]
        """
        Egnyte SSO configuration.
        """
        firebase: NotRequired[pulumi.Input['ClientAddonsFirebaseArgsDict']]
        """
        Google Firebase addon configuration.
        """
        layer: NotRequired[pulumi.Input['ClientAddonsLayerArgsDict']]
        """
        Layer addon configuration.
        """
        mscrm: NotRequired[pulumi.Input['ClientAddonsMscrmArgsDict']]
        """
        Microsoft Dynamics CRM SSO configuration.
        """
        newrelic: NotRequired[pulumi.Input['ClientAddonsNewrelicArgsDict']]
        """
        New Relic SSO configuration.
        """
        office365: NotRequired[pulumi.Input['ClientAddonsOffice365ArgsDict']]
        """
        Microsoft Office 365 SSO configuration.
        """
        rms: NotRequired[pulumi.Input['ClientAddonsRmsArgsDict']]
        """
        Active Directory Rights Management Service SSO configuration.
        """
        salesforce: NotRequired[pulumi.Input['ClientAddonsSalesforceArgsDict']]
        """
        Salesforce SSO configuration.
        """
        salesforce_api: NotRequired[pulumi.Input['ClientAddonsSalesforceApiArgsDict']]
        """
        Salesforce API addon configuration.
        """
        salesforce_sandbox_api: NotRequired[pulumi.Input['ClientAddonsSalesforceSandboxApiArgsDict']]
        """
        Salesforce Sandbox addon configuration.
        """
        samlp: NotRequired[pulumi.Input['ClientAddonsSamlpArgsDict']]
        """
        Configuration settings for a SAML add-on.
        """
        sap_api: NotRequired[pulumi.Input['ClientAddonsSapApiArgsDict']]
        """
        SAP API addon configuration.
        """
        sentry: NotRequired[pulumi.Input['ClientAddonsSentryArgsDict']]
        """
        Sentry SSO configuration.
        """
        sharepoint: NotRequired[pulumi.Input['ClientAddonsSharepointArgsDict']]
        """
        SharePoint SSO configuration.
        """
        slack: NotRequired[pulumi.Input['ClientAddonsSlackArgsDict']]
        """
        Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        """
        springcm: NotRequired[pulumi.Input['ClientAddonsSpringcmArgsDict']]
        """
        SpringCM SSO configuration.
        """
        sso_integration: NotRequired[pulumi.Input['ClientAddonsSsoIntegrationArgsDict']]
        """
        Generic SSO configuration.
        """
        wams: NotRequired[pulumi.Input['ClientAddonsWamsArgsDict']]
        """
        Windows Azure Mobile Services addon configuration.
        """
        wsfed: NotRequired[pulumi.Input['ClientAddonsWsfedArgsDict']]
        """
        WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        """
        zendesk: NotRequired[pulumi.Input['ClientAddonsZendeskArgsDict']]
        """
        Zendesk SSO configuration.
        """
        zoom: NotRequired[pulumi.Input['ClientAddonsZoomArgsDict']]
        """
        Zoom SSO configuration.
        """
elif False:
    ClientAddonsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsArgs:
    def __init__(__self__, *,
                 aws: Optional[pulumi.Input['ClientAddonsAwsArgs']] = None,
                 azure_blob: Optional[pulumi.Input['ClientAddonsAzureBlobArgs']] = None,
                 azure_sb: Optional[pulumi.Input['ClientAddonsAzureSbArgs']] = None,
                 box: Optional[pulumi.Input['ClientAddonsBoxArgs']] = None,
                 cloudbees: Optional[pulumi.Input['ClientAddonsCloudbeesArgs']] = None,
                 concur: Optional[pulumi.Input['ClientAddonsConcurArgs']] = None,
                 dropbox: Optional[pulumi.Input['ClientAddonsDropboxArgs']] = None,
                 echosign: Optional[pulumi.Input['ClientAddonsEchosignArgs']] = None,
                 egnyte: Optional[pulumi.Input['ClientAddonsEgnyteArgs']] = None,
                 firebase: Optional[pulumi.Input['ClientAddonsFirebaseArgs']] = None,
                 layer: Optional[pulumi.Input['ClientAddonsLayerArgs']] = None,
                 mscrm: Optional[pulumi.Input['ClientAddonsMscrmArgs']] = None,
                 newrelic: Optional[pulumi.Input['ClientAddonsNewrelicArgs']] = None,
                 office365: Optional[pulumi.Input['ClientAddonsOffice365Args']] = None,
                 rms: Optional[pulumi.Input['ClientAddonsRmsArgs']] = None,
                 salesforce: Optional[pulumi.Input['ClientAddonsSalesforceArgs']] = None,
                 salesforce_api: Optional[pulumi.Input['ClientAddonsSalesforceApiArgs']] = None,
                 salesforce_sandbox_api: Optional[pulumi.Input['ClientAddonsSalesforceSandboxApiArgs']] = None,
                 samlp: Optional[pulumi.Input['ClientAddonsSamlpArgs']] = None,
                 sap_api: Optional[pulumi.Input['ClientAddonsSapApiArgs']] = None,
                 sentry: Optional[pulumi.Input['ClientAddonsSentryArgs']] = None,
                 sharepoint: Optional[pulumi.Input['ClientAddonsSharepointArgs']] = None,
                 slack: Optional[pulumi.Input['ClientAddonsSlackArgs']] = None,
                 springcm: Optional[pulumi.Input['ClientAddonsSpringcmArgs']] = None,
                 sso_integration: Optional[pulumi.Input['ClientAddonsSsoIntegrationArgs']] = None,
                 wams: Optional[pulumi.Input['ClientAddonsWamsArgs']] = None,
                 wsfed: Optional[pulumi.Input['ClientAddonsWsfedArgs']] = None,
                 zendesk: Optional[pulumi.Input['ClientAddonsZendeskArgs']] = None,
                 zoom: Optional[pulumi.Input['ClientAddonsZoomArgs']] = None):
        """
        :param pulumi.Input['ClientAddonsAwsArgs'] aws: AWS Addon configuration.
        :param pulumi.Input['ClientAddonsAzureBlobArgs'] azure_blob: Azure Blob Storage Addon configuration.
        :param pulumi.Input['ClientAddonsAzureSbArgs'] azure_sb: Azure Storage Bus Addon configuration.
        :param pulumi.Input['ClientAddonsBoxArgs'] box: Box SSO indicator (no configuration settings needed for Box SSO).
        :param pulumi.Input['ClientAddonsCloudbeesArgs'] cloudbees: CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        :param pulumi.Input['ClientAddonsConcurArgs'] concur: Concur SSO indicator (no configuration settings needed for Concur SSO).
        :param pulumi.Input['ClientAddonsDropboxArgs'] dropbox: Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        :param pulumi.Input['ClientAddonsEchosignArgs'] echosign: Adobe EchoSign SSO configuration.
        :param pulumi.Input['ClientAddonsEgnyteArgs'] egnyte: Egnyte SSO configuration.
        :param pulumi.Input['ClientAddonsFirebaseArgs'] firebase: Google Firebase addon configuration.
        :param pulumi.Input['ClientAddonsLayerArgs'] layer: Layer addon configuration.
        :param pulumi.Input['ClientAddonsMscrmArgs'] mscrm: Microsoft Dynamics CRM SSO configuration.
        :param pulumi.Input['ClientAddonsNewrelicArgs'] newrelic: New Relic SSO configuration.
        :param pulumi.Input['ClientAddonsOffice365Args'] office365: Microsoft Office 365 SSO configuration.
        :param pulumi.Input['ClientAddonsRmsArgs'] rms: Active Directory Rights Management Service SSO configuration.
        :param pulumi.Input['ClientAddonsSalesforceArgs'] salesforce: Salesforce SSO configuration.
        :param pulumi.Input['ClientAddonsSalesforceApiArgs'] salesforce_api: Salesforce API addon configuration.
        :param pulumi.Input['ClientAddonsSalesforceSandboxApiArgs'] salesforce_sandbox_api: Salesforce Sandbox addon configuration.
        :param pulumi.Input['ClientAddonsSamlpArgs'] samlp: Configuration settings for a SAML add-on.
        :param pulumi.Input['ClientAddonsSapApiArgs'] sap_api: SAP API addon configuration.
        :param pulumi.Input['ClientAddonsSentryArgs'] sentry: Sentry SSO configuration.
        :param pulumi.Input['ClientAddonsSharepointArgs'] sharepoint: SharePoint SSO configuration.
        :param pulumi.Input['ClientAddonsSlackArgs'] slack: Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        :param pulumi.Input['ClientAddonsSpringcmArgs'] springcm: SpringCM SSO configuration.
        :param pulumi.Input['ClientAddonsSsoIntegrationArgs'] sso_integration: Generic SSO configuration.
        :param pulumi.Input['ClientAddonsWamsArgs'] wams: Windows Azure Mobile Services addon configuration.
        :param pulumi.Input['ClientAddonsWsfedArgs'] wsfed: WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        :param pulumi.Input['ClientAddonsZendeskArgs'] zendesk: Zendesk SSO configuration.
        :param pulumi.Input['ClientAddonsZoomArgs'] zoom: Zoom SSO configuration.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if azure_blob is not None:
            pulumi.set(__self__, "azure_blob", azure_blob)
        if azure_sb is not None:
            pulumi.set(__self__, "azure_sb", azure_sb)
        if box is not None:
            pulumi.set(__self__, "box", box)
        if cloudbees is not None:
            pulumi.set(__self__, "cloudbees", cloudbees)
        if concur is not None:
            pulumi.set(__self__, "concur", concur)
        if dropbox is not None:
            pulumi.set(__self__, "dropbox", dropbox)
        if echosign is not None:
            pulumi.set(__self__, "echosign", echosign)
        if egnyte is not None:
            pulumi.set(__self__, "egnyte", egnyte)
        if firebase is not None:
            pulumi.set(__self__, "firebase", firebase)
        if layer is not None:
            pulumi.set(__self__, "layer", layer)
        if mscrm is not None:
            pulumi.set(__self__, "mscrm", mscrm)
        if newrelic is not None:
            pulumi.set(__self__, "newrelic", newrelic)
        if office365 is not None:
            pulumi.set(__self__, "office365", office365)
        if rms is not None:
            pulumi.set(__self__, "rms", rms)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if salesforce_api is not None:
            pulumi.set(__self__, "salesforce_api", salesforce_api)
        if salesforce_sandbox_api is not None:
            pulumi.set(__self__, "salesforce_sandbox_api", salesforce_sandbox_api)
        if samlp is not None:
            pulumi.set(__self__, "samlp", samlp)
        if sap_api is not None:
            pulumi.set(__self__, "sap_api", sap_api)
        if sentry is not None:
            pulumi.set(__self__, "sentry", sentry)
        if sharepoint is not None:
            pulumi.set(__self__, "sharepoint", sharepoint)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)
        if springcm is not None:
            pulumi.set(__self__, "springcm", springcm)
        if sso_integration is not None:
            pulumi.set(__self__, "sso_integration", sso_integration)
        if wams is not None:
            pulumi.set(__self__, "wams", wams)
        if wsfed is not None:
            pulumi.set(__self__, "wsfed", wsfed)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)
        if zoom is not None:
            pulumi.set(__self__, "zoom", zoom)

    @property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['ClientAddonsAwsArgs']]:
        """
        AWS Addon configuration.
        """
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['ClientAddonsAwsArgs']]):
        pulumi.set(self, "aws", value)

    @property
    @pulumi.getter(name="azureBlob")
    def azure_blob(self) -> Optional[pulumi.Input['ClientAddonsAzureBlobArgs']]:
        """
        Azure Blob Storage Addon configuration.
        """
        return pulumi.get(self, "azure_blob")

    @azure_blob.setter
    def azure_blob(self, value: Optional[pulumi.Input['ClientAddonsAzureBlobArgs']]):
        pulumi.set(self, "azure_blob", value)

    @property
    @pulumi.getter(name="azureSb")
    def azure_sb(self) -> Optional[pulumi.Input['ClientAddonsAzureSbArgs']]:
        """
        Azure Storage Bus Addon configuration.
        """
        return pulumi.get(self, "azure_sb")

    @azure_sb.setter
    def azure_sb(self, value: Optional[pulumi.Input['ClientAddonsAzureSbArgs']]):
        pulumi.set(self, "azure_sb", value)

    @property
    @pulumi.getter
    def box(self) -> Optional[pulumi.Input['ClientAddonsBoxArgs']]:
        """
        Box SSO indicator (no configuration settings needed for Box SSO).
        """
        return pulumi.get(self, "box")

    @box.setter
    def box(self, value: Optional[pulumi.Input['ClientAddonsBoxArgs']]):
        pulumi.set(self, "box", value)

    @property
    @pulumi.getter
    def cloudbees(self) -> Optional[pulumi.Input['ClientAddonsCloudbeesArgs']]:
        """
        CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
        """
        return pulumi.get(self, "cloudbees")

    @cloudbees.setter
    def cloudbees(self, value: Optional[pulumi.Input['ClientAddonsCloudbeesArgs']]):
        pulumi.set(self, "cloudbees", value)

    @property
    @pulumi.getter
    def concur(self) -> Optional[pulumi.Input['ClientAddonsConcurArgs']]:
        """
        Concur SSO indicator (no configuration settings needed for Concur SSO).
        """
        return pulumi.get(self, "concur")

    @concur.setter
    def concur(self, value: Optional[pulumi.Input['ClientAddonsConcurArgs']]):
        pulumi.set(self, "concur", value)

    @property
    @pulumi.getter
    def dropbox(self) -> Optional[pulumi.Input['ClientAddonsDropboxArgs']]:
        """
        Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
        """
        return pulumi.get(self, "dropbox")

    @dropbox.setter
    def dropbox(self, value: Optional[pulumi.Input['ClientAddonsDropboxArgs']]):
        pulumi.set(self, "dropbox", value)

    @property
    @pulumi.getter
    def echosign(self) -> Optional[pulumi.Input['ClientAddonsEchosignArgs']]:
        """
        Adobe EchoSign SSO configuration.
        """
        return pulumi.get(self, "echosign")

    @echosign.setter
    def echosign(self, value: Optional[pulumi.Input['ClientAddonsEchosignArgs']]):
        pulumi.set(self, "echosign", value)

    @property
    @pulumi.getter
    def egnyte(self) -> Optional[pulumi.Input['ClientAddonsEgnyteArgs']]:
        """
        Egnyte SSO configuration.
        """
        return pulumi.get(self, "egnyte")

    @egnyte.setter
    def egnyte(self, value: Optional[pulumi.Input['ClientAddonsEgnyteArgs']]):
        pulumi.set(self, "egnyte", value)

    @property
    @pulumi.getter
    def firebase(self) -> Optional[pulumi.Input['ClientAddonsFirebaseArgs']]:
        """
        Google Firebase addon configuration.
        """
        return pulumi.get(self, "firebase")

    @firebase.setter
    def firebase(self, value: Optional[pulumi.Input['ClientAddonsFirebaseArgs']]):
        pulumi.set(self, "firebase", value)

    @property
    @pulumi.getter
    def layer(self) -> Optional[pulumi.Input['ClientAddonsLayerArgs']]:
        """
        Layer addon configuration.
        """
        return pulumi.get(self, "layer")

    @layer.setter
    def layer(self, value: Optional[pulumi.Input['ClientAddonsLayerArgs']]):
        pulumi.set(self, "layer", value)

    @property
    @pulumi.getter
    def mscrm(self) -> Optional[pulumi.Input['ClientAddonsMscrmArgs']]:
        """
        Microsoft Dynamics CRM SSO configuration.
        """
        return pulumi.get(self, "mscrm")

    @mscrm.setter
    def mscrm(self, value: Optional[pulumi.Input['ClientAddonsMscrmArgs']]):
        pulumi.set(self, "mscrm", value)

    @property
    @pulumi.getter
    def newrelic(self) -> Optional[pulumi.Input['ClientAddonsNewrelicArgs']]:
        """
        New Relic SSO configuration.
        """
        return pulumi.get(self, "newrelic")

    @newrelic.setter
    def newrelic(self, value: Optional[pulumi.Input['ClientAddonsNewrelicArgs']]):
        pulumi.set(self, "newrelic", value)

    @property
    @pulumi.getter
    def office365(self) -> Optional[pulumi.Input['ClientAddonsOffice365Args']]:
        """
        Microsoft Office 365 SSO configuration.
        """
        return pulumi.get(self, "office365")

    @office365.setter
    def office365(self, value: Optional[pulumi.Input['ClientAddonsOffice365Args']]):
        pulumi.set(self, "office365", value)

    @property
    @pulumi.getter
    def rms(self) -> Optional[pulumi.Input['ClientAddonsRmsArgs']]:
        """
        Active Directory Rights Management Service SSO configuration.
        """
        return pulumi.get(self, "rms")

    @rms.setter
    def rms(self, value: Optional[pulumi.Input['ClientAddonsRmsArgs']]):
        pulumi.set(self, "rms", value)

    @property
    @pulumi.getter
    def salesforce(self) -> Optional[pulumi.Input['ClientAddonsSalesforceArgs']]:
        """
        Salesforce SSO configuration.
        """
        return pulumi.get(self, "salesforce")

    @salesforce.setter
    def salesforce(self, value: Optional[pulumi.Input['ClientAddonsSalesforceArgs']]):
        pulumi.set(self, "salesforce", value)

    @property
    @pulumi.getter(name="salesforceApi")
    def salesforce_api(self) -> Optional[pulumi.Input['ClientAddonsSalesforceApiArgs']]:
        """
        Salesforce API addon configuration.
        """
        return pulumi.get(self, "salesforce_api")

    @salesforce_api.setter
    def salesforce_api(self, value: Optional[pulumi.Input['ClientAddonsSalesforceApiArgs']]):
        pulumi.set(self, "salesforce_api", value)

    @property
    @pulumi.getter(name="salesforceSandboxApi")
    def salesforce_sandbox_api(self) -> Optional[pulumi.Input['ClientAddonsSalesforceSandboxApiArgs']]:
        """
        Salesforce Sandbox addon configuration.
        """
        return pulumi.get(self, "salesforce_sandbox_api")

    @salesforce_sandbox_api.setter
    def salesforce_sandbox_api(self, value: Optional[pulumi.Input['ClientAddonsSalesforceSandboxApiArgs']]):
        pulumi.set(self, "salesforce_sandbox_api", value)

    @property
    @pulumi.getter
    def samlp(self) -> Optional[pulumi.Input['ClientAddonsSamlpArgs']]:
        """
        Configuration settings for a SAML add-on.
        """
        return pulumi.get(self, "samlp")

    @samlp.setter
    def samlp(self, value: Optional[pulumi.Input['ClientAddonsSamlpArgs']]):
        pulumi.set(self, "samlp", value)

    @property
    @pulumi.getter(name="sapApi")
    def sap_api(self) -> Optional[pulumi.Input['ClientAddonsSapApiArgs']]:
        """
        SAP API addon configuration.
        """
        return pulumi.get(self, "sap_api")

    @sap_api.setter
    def sap_api(self, value: Optional[pulumi.Input['ClientAddonsSapApiArgs']]):
        pulumi.set(self, "sap_api", value)

    @property
    @pulumi.getter
    def sentry(self) -> Optional[pulumi.Input['ClientAddonsSentryArgs']]:
        """
        Sentry SSO configuration.
        """
        return pulumi.get(self, "sentry")

    @sentry.setter
    def sentry(self, value: Optional[pulumi.Input['ClientAddonsSentryArgs']]):
        pulumi.set(self, "sentry", value)

    @property
    @pulumi.getter
    def sharepoint(self) -> Optional[pulumi.Input['ClientAddonsSharepointArgs']]:
        """
        SharePoint SSO configuration.
        """
        return pulumi.get(self, "sharepoint")

    @sharepoint.setter
    def sharepoint(self, value: Optional[pulumi.Input['ClientAddonsSharepointArgs']]):
        pulumi.set(self, "sharepoint", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['ClientAddonsSlackArgs']]:
        """
        Slack team or workspace name usually first segment in your Slack URL, for example `https://acme-org.slack.com` would be `acme-org`.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['ClientAddonsSlackArgs']]):
        pulumi.set(self, "slack", value)

    @property
    @pulumi.getter
    def springcm(self) -> Optional[pulumi.Input['ClientAddonsSpringcmArgs']]:
        """
        SpringCM SSO configuration.
        """
        return pulumi.get(self, "springcm")

    @springcm.setter
    def springcm(self, value: Optional[pulumi.Input['ClientAddonsSpringcmArgs']]):
        pulumi.set(self, "springcm", value)

    @property
    @pulumi.getter(name="ssoIntegration")
    def sso_integration(self) -> Optional[pulumi.Input['ClientAddonsSsoIntegrationArgs']]:
        """
        Generic SSO configuration.
        """
        return pulumi.get(self, "sso_integration")

    @sso_integration.setter
    def sso_integration(self, value: Optional[pulumi.Input['ClientAddonsSsoIntegrationArgs']]):
        pulumi.set(self, "sso_integration", value)

    @property
    @pulumi.getter
    def wams(self) -> Optional[pulumi.Input['ClientAddonsWamsArgs']]:
        """
        Windows Azure Mobile Services addon configuration.
        """
        return pulumi.get(self, "wams")

    @wams.setter
    def wams(self, value: Optional[pulumi.Input['ClientAddonsWamsArgs']]):
        pulumi.set(self, "wams", value)

    @property
    @pulumi.getter
    def wsfed(self) -> Optional[pulumi.Input['ClientAddonsWsfedArgs']]:
        """
        WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
        """
        return pulumi.get(self, "wsfed")

    @wsfed.setter
    def wsfed(self, value: Optional[pulumi.Input['ClientAddonsWsfedArgs']]):
        pulumi.set(self, "wsfed", value)

    @property
    @pulumi.getter
    def zendesk(self) -> Optional[pulumi.Input['ClientAddonsZendeskArgs']]:
        """
        Zendesk SSO configuration.
        """
        return pulumi.get(self, "zendesk")

    @zendesk.setter
    def zendesk(self, value: Optional[pulumi.Input['ClientAddonsZendeskArgs']]):
        pulumi.set(self, "zendesk", value)

    @property
    @pulumi.getter
    def zoom(self) -> Optional[pulumi.Input['ClientAddonsZoomArgs']]:
        """
        Zoom SSO configuration.
        """
        return pulumi.get(self, "zoom")

    @zoom.setter
    def zoom(self, value: Optional[pulumi.Input['ClientAddonsZoomArgs']]):
        pulumi.set(self, "zoom", value)


if not MYPY:
    class ClientAddonsAwsArgsDict(TypedDict):
        lifetime_in_seconds: NotRequired[pulumi.Input[int]]
        """
        AWS token lifetime in seconds.
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
elif False:
    ClientAddonsAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsAwsArgs:
    def __init__(__self__, *,
                 lifetime_in_seconds: Optional[pulumi.Input[int]] = None,
                 principal: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] lifetime_in_seconds: AWS token lifetime in seconds.
        :param pulumi.Input[str] principal: AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        :param pulumi.Input[str] role: AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        AWS token lifetime in seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @lifetime_in_seconds.setter
    def lifetime_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_in_seconds", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        AWS principal ARN, for example `arn:aws:iam::010616021751:saml-provider/idpname`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        AWS role ARN, for example `arn:aws:iam::010616021751:role/foo`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ClientAddonsAzureBlobArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[str]]
        """
        Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        """
        blob_delete: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the issued token has permission to delete the blob.
        """
        blob_name: NotRequired[pulumi.Input[str]]
        """
        Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        """
        blob_read: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        """
        blob_write: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        container_delete: NotRequired[pulumi.Input[bool]]
        """
        Indicates if issued token has permission to delete any blob in the container.
        """
        container_list: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the issued token has permission to list blobs in the container.
        """
        container_name: NotRequired[pulumi.Input[str]]
        """
        Container to request a token for, such as `my-container`.
        """
        container_read: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        """
        container_write: NotRequired[pulumi.Input[bool]]
        """
        Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        expiration: NotRequired[pulumi.Input[int]]
        """
        Expiration in minutes for the generated token (default of 5 minutes).
        """
        signed_identifier: NotRequired[pulumi.Input[str]]
        """
        Shared access policy identifier defined in your storage account resource.
        """
        storage_access_key: NotRequired[pulumi.Input[str]]
        """
        Access key associated with this storage account.
        """
elif False:
    ClientAddonsAzureBlobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsAzureBlobArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[str]] = None,
                 blob_delete: Optional[pulumi.Input[bool]] = None,
                 blob_name: Optional[pulumi.Input[str]] = None,
                 blob_read: Optional[pulumi.Input[bool]] = None,
                 blob_write: Optional[pulumi.Input[bool]] = None,
                 container_delete: Optional[pulumi.Input[bool]] = None,
                 container_list: Optional[pulumi.Input[bool]] = None,
                 container_name: Optional[pulumi.Input[str]] = None,
                 container_read: Optional[pulumi.Input[bool]] = None,
                 container_write: Optional[pulumi.Input[bool]] = None,
                 expiration: Optional[pulumi.Input[int]] = None,
                 signed_identifier: Optional[pulumi.Input[str]] = None,
                 storage_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_name: Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        :param pulumi.Input[bool] blob_delete: Indicates if the issued token has permission to delete the blob.
        :param pulumi.Input[str] blob_name: Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        :param pulumi.Input[bool] blob_read: Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        :param pulumi.Input[bool] blob_write: Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param pulumi.Input[bool] container_delete: Indicates if issued token has permission to delete any blob in the container.
        :param pulumi.Input[bool] container_list: Indicates if the issued token has permission to list blobs in the container.
        :param pulumi.Input[str] container_name: Container to request a token for, such as `my-container`.
        :param pulumi.Input[bool] container_read: Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        :param pulumi.Input[bool] container_write: Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        :param pulumi.Input[int] expiration: Expiration in minutes for the generated token (default of 5 minutes).
        :param pulumi.Input[str] signed_identifier: Shared access policy identifier defined in your storage account resource.
        :param pulumi.Input[str] storage_access_key: Access key associated with this storage account.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if blob_delete is not None:
            pulumi.set(__self__, "blob_delete", blob_delete)
        if blob_name is not None:
            pulumi.set(__self__, "blob_name", blob_name)
        if blob_read is not None:
            pulumi.set(__self__, "blob_read", blob_read)
        if blob_write is not None:
            pulumi.set(__self__, "blob_write", blob_write)
        if container_delete is not None:
            pulumi.set(__self__, "container_delete", container_delete)
        if container_list is not None:
            pulumi.set(__self__, "container_list", container_list)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_read is not None:
            pulumi.set(__self__, "container_read", container_read)
        if container_write is not None:
            pulumi.set(__self__, "container_write", container_write)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if signed_identifier is not None:
            pulumi.set(__self__, "signed_identifier", signed_identifier)
        if storage_access_key is not None:
            pulumi.set(__self__, "storage_access_key", storage_access_key)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[str]]:
        """
        Your Azure storage account name. Usually first segment in your Azure storage URL, for example `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="blobDelete")
    def blob_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the issued token has permission to delete the blob.
        """
        return pulumi.get(self, "blob_delete")

    @blob_delete.setter
    def blob_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blob_delete", value)

    @property
    @pulumi.getter(name="blobName")
    def blob_name(self) -> Optional[pulumi.Input[str]]:
        """
        Entity to request a token for, such as `my-blob`. If blank the computed SAS will apply to the entire storage container.
        """
        return pulumi.get(self, "blob_name")

    @blob_name.setter
    def blob_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_name", value)

    @property
    @pulumi.getter(name="blobRead")
    def blob_read(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
        """
        return pulumi.get(self, "blob_read")

    @blob_read.setter
    def blob_read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blob_read", value)

    @property
    @pulumi.getter(name="blobWrite")
    def blob_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "blob_write")

    @blob_write.setter
    def blob_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blob_write", value)

    @property
    @pulumi.getter(name="containerDelete")
    def container_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if issued token has permission to delete any blob in the container.
        """
        return pulumi.get(self, "container_delete")

    @container_delete.setter
    def container_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_delete", value)

    @property
    @pulumi.getter(name="containerList")
    def container_list(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the issued token has permission to list blobs in the container.
        """
        return pulumi.get(self, "container_list")

    @container_list.setter
    def container_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_list", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container to request a token for, such as `my-container`.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter(name="containerRead")
    def container_read(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation.
        """
        return pulumi.get(self, "container_read")

    @container_read.setter
    def container_read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_read", value)

    @property
    @pulumi.getter(name="containerWrite")
    def container_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
        """
        return pulumi.get(self, "container_write")

    @container_write.setter
    def container_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_write", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[int]]:
        """
        Expiration in minutes for the generated token (default of 5 minutes).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter(name="signedIdentifier")
    def signed_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Shared access policy identifier defined in your storage account resource.
        """
        return pulumi.get(self, "signed_identifier")

    @signed_identifier.setter
    def signed_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signed_identifier", value)

    @property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Access key associated with this storage account.
        """
        return pulumi.get(self, "storage_access_key")

    @storage_access_key.setter
    def storage_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_access_key", value)


if not MYPY:
    class ClientAddonsAzureSbArgsDict(TypedDict):
        entity_path: NotRequired[pulumi.Input[str]]
        """
        Entity you want to request a token for, such as `my-queue`.
        """
        expiration: NotRequired[pulumi.Input[int]]
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        """
        sas_key: NotRequired[pulumi.Input[str]]
        """
        Primary Key associated with your shared access policy.
        """
        sas_key_name: NotRequired[pulumi.Input[str]]
        """
        Your shared access policy name defined in your Service Bus entity.
        """
elif False:
    ClientAddonsAzureSbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsAzureSbArgs:
    def __init__(__self__, *,
                 entity_path: Optional[pulumi.Input[str]] = None,
                 expiration: Optional[pulumi.Input[int]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 sas_key: Optional[pulumi.Input[str]] = None,
                 sas_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity_path: Entity you want to request a token for, such as `my-queue`.
        :param pulumi.Input[int] expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param pulumi.Input[str] namespace: Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        :param pulumi.Input[str] sas_key: Primary Key associated with your shared access policy.
        :param pulumi.Input[str] sas_key_name: Your shared access policy name defined in your Service Bus entity.
        """
        if entity_path is not None:
            pulumi.set(__self__, "entity_path", entity_path)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sas_key is not None:
            pulumi.set(__self__, "sas_key", sas_key)
        if sas_key_name is not None:
            pulumi.set(__self__, "sas_key_name", sas_key_name)

    @property
    @pulumi.getter(name="entityPath")
    def entity_path(self) -> Optional[pulumi.Input[str]]:
        """
        Entity you want to request a token for, such as `my-queue`.
        """
        return pulumi.get(self, "entity_path")

    @entity_path.setter
    def entity_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_path", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[int]]:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (for example `https://acme-org.servicebus.windows.net` would be `acme-org`).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="sasKey")
    def sas_key(self) -> Optional[pulumi.Input[str]]:
        """
        Primary Key associated with your shared access policy.
        """
        return pulumi.get(self, "sas_key")

    @sas_key.setter
    def sas_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_key", value)

    @property
    @pulumi.getter(name="sasKeyName")
    def sas_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        Your shared access policy name defined in your Service Bus entity.
        """
        return pulumi.get(self, "sas_key_name")

    @sas_key_name.setter
    def sas_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_key_name", value)


if not MYPY:
    class ClientAddonsBoxArgsDict(TypedDict):
        pass
elif False:
    ClientAddonsBoxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsBoxArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ClientAddonsCloudbeesArgsDict(TypedDict):
        pass
elif False:
    ClientAddonsCloudbeesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsCloudbeesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ClientAddonsConcurArgsDict(TypedDict):
        pass
elif False:
    ClientAddonsConcurArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsConcurArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ClientAddonsDropboxArgsDict(TypedDict):
        pass
elif False:
    ClientAddonsDropboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsDropboxArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ClientAddonsEchosignArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[str]]
        """
        Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
elif False:
    ClientAddonsEchosignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsEchosignArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Your custom domain found in your EchoSign URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ClientAddonsEgnyteArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[str]]
        """
        Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
elif False:
    ClientAddonsEgnyteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsEgnyteArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Your custom domain found in your Egnyte URL, for example `https://acme-org.echosign.com` would be `acme-org`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ClientAddonsFirebaseArgsDict(TypedDict):
        client_email: NotRequired[pulumi.Input[str]]
        """
        ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        """
        lifetime_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Private Key for signing the token (SDK v3+ tokens only).
        """
        private_key_id: NotRequired[pulumi.Input[str]]
        """
        Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Google Firebase Secret. (SDK v2 only).
        """
elif False:
    ClientAddonsFirebaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsFirebaseArgs:
    def __init__(__self__, *,
                 client_email: Optional[pulumi.Input[str]] = None,
                 lifetime_in_seconds: Optional[pulumi.Input[int]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_email: ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        :param pulumi.Input[int] lifetime_in_seconds: Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        :param pulumi.Input[str] private_key: Private Key for signing the token (SDK v3+ tokens only).
        :param pulumi.Input[str] private_key_id: Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        :param pulumi.Input[str] secret: Google Firebase Secret. (SDK v2 only).
        """
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @lifetime_in_seconds.setter
    def lifetime_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_in_seconds", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private Key for signing the token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional ID of the private key to obtain the `kid` header claim from the issued token (SDK v3+ tokens only).
        """
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Google Firebase Secret. (SDK v2 only).
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ClientAddonsLayerArgsDict(TypedDict):
        key_id: pulumi.Input[str]
        """
        Authentication Key identifier used to sign the Layer token.
        """
        private_key: pulumi.Input[str]
        """
        Private key for signing the Layer token.
        """
        provider_id: pulumi.Input[str]
        """
        Provider ID of your Layer account.
        """
        expiration: NotRequired[pulumi.Input[int]]
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
elif False:
    ClientAddonsLayerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsLayerArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 provider_id: pulumi.Input[str],
                 expiration: Optional[pulumi.Input[int]] = None,
                 principal: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_id: Authentication Key identifier used to sign the Layer token.
        :param pulumi.Input[str] private_key: Private key for signing the Layer token.
        :param pulumi.Input[str] provider_id: Provider ID of your Layer account.
        :param pulumi.Input[int] expiration: Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        :param pulumi.Input[str] principal: Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "provider_id", provider_id)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        Authentication Key identifier used to sign the Layer token.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key for signing the Layer token.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[str]:
        """
        Provider ID of your Layer account.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[int]]:
        """
        Optional expiration in minutes for the generated token. Defaults to 5 minutes.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property used as the unique user ID in Layer. If not specified `user_id` is used.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class ClientAddonsMscrmArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        Microsoft Dynamics CRM application URL.
        """
elif False:
    ClientAddonsMscrmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsMscrmArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Microsoft Dynamics CRM application URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Microsoft Dynamics CRM application URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClientAddonsNewrelicArgsDict(TypedDict):
        account: NotRequired[pulumi.Input[str]]
        """
        Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
elif False:
    ClientAddonsNewrelicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsNewrelicArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account: Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)

    @property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[str]]:
        """
        Your New Relic Account ID found in your New Relic URL after the `/accounts/` path, for example `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account", value)


if not MYPY:
    class ClientAddonsOffice365ArgsDict(TypedDict):
        connection: NotRequired[pulumi.Input[str]]
        """
        Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Your Office 365 domain name, for example `acme-org.com`.
        """
elif False:
    ClientAddonsOffice365ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsOffice365Args:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection: Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        :param pulumi.Input[str] domain: Your Office 365 domain name, for example `acme-org.com`.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Auth0 database connection for testing an already-configured Office 365 tenant.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Your Office 365 domain name, for example `acme-org.com`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ClientAddonsRmsArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
elif False:
    ClientAddonsRmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsRmsArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClientAddonsSalesforceArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        """
        Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
elif False:
    ClientAddonsSalesforceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSalesforceArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity_id: Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Arbitrary logical URL that identifies the Saleforce resource, for example `https://acme-org.com`.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)


if not MYPY:
    class ClientAddonsSalesforceApiArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        community_name: NotRequired[pulumi.Input[str]]
        """
        Community name.
        """
        community_url_section: NotRequired[pulumi.Input[str]]
        """
        Community URL section.
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
elif False:
    ClientAddonsSalesforceApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSalesforceApiArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 community_name: Optional[pulumi.Input[str]] = None,
                 community_url_section: Optional[pulumi.Input[str]] = None,
                 principal: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param pulumi.Input[str] community_name: Community name.
        :param pulumi.Input[str] community_url_section: Community URL section.
        :param pulumi.Input[str] principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if community_url_section is not None:
            pulumi.set(__self__, "community_url_section", community_url_section)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[pulumi.Input[str]]:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @community_name.setter
    def community_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_name", value)

    @property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> Optional[pulumi.Input[str]]:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @community_url_section.setter
    def community_url_section(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_url_section", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class ClientAddonsSalesforceSandboxApiArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        community_name: NotRequired[pulumi.Input[str]]
        """
        Community name.
        """
        community_url_section: NotRequired[pulumi.Input[str]]
        """
        Community URL section.
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
elif False:
    ClientAddonsSalesforceSandboxApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSalesforceSandboxApiArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 community_name: Optional[pulumi.Input[str]] = None,
                 community_url_section: Optional[pulumi.Input[str]] = None,
                 principal: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Consumer Key assigned by Salesforce to the Connected App.
        :param pulumi.Input[str] community_name: Community name.
        :param pulumi.Input[str] community_url_section: Community URL section.
        :param pulumi.Input[str] principal: Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if community_url_section is not None:
            pulumi.set(__self__, "community_url_section", community_url_section)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Consumer Key assigned by Salesforce to the Connected App.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[pulumi.Input[str]]:
        """
        Community name.
        """
        return pulumi.get(self, "community_name")

    @community_name.setter
    def community_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_name", value)

    @property
    @pulumi.getter(name="communityUrlSection")
    def community_url_section(self) -> Optional[pulumi.Input[str]]:
        """
        Community URL section.
        """
        return pulumi.get(self, "community_url_section")

    @community_url_section.setter
    def community_url_section(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_url_section", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property in the user object that maps to a Salesforce username, for example `email`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class ClientAddonsSamlpArgsDict(TypedDict):
        audience: NotRequired[pulumi.Input[str]]
        """
        Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        """
        authn_context_class_ref: NotRequired[pulumi.Input[str]]
        """
        Class reference of the authentication context.
        """
        binding: NotRequired[pulumi.Input[str]]
        """
        Protocol binding used for SAML logout responses.
        """
        create_upn_claim: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether a UPN claim should be created. Defaults to `true`.
        """
        destination: NotRequired[pulumi.Input[str]]
        """
        Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        """
        digest_algorithm: NotRequired[pulumi.Input[str]]
        """
        Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        """
        include_attribute_name_format: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer of the SAML Assertion.
        """
        lifetime_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Number of seconds during which the token is valid. Defaults to `3600` seconds.
        """
        logout: NotRequired[pulumi.Input['ClientAddonsSamlpLogoutArgsDict']]
        """
        Configuration settings for logout.
        """
        map_identities: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        """
        map_unknown_claims_as_is: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        """
        mappings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        """
        name_identifier_format: NotRequired[pulumi.Input[str]]
        """
        Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        name_identifier_probes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        """
        passthrough_claims_with_no_mapping: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        """
        recipient: NotRequired[pulumi.Input[str]]
        """
        Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        """
        sign_response: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        """
        signature_algorithm: NotRequired[pulumi.Input[str]]
        """
        Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        """
        signing_cert: NotRequired[pulumi.Input[str]]
        """
        Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        """
        typed_attributes: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
elif False:
    ClientAddonsSamlpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSamlpArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[str]] = None,
                 authn_context_class_ref: Optional[pulumi.Input[str]] = None,
                 binding: Optional[pulumi.Input[str]] = None,
                 create_upn_claim: Optional[pulumi.Input[bool]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 digest_algorithm: Optional[pulumi.Input[str]] = None,
                 include_attribute_name_format: Optional[pulumi.Input[bool]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 lifetime_in_seconds: Optional[pulumi.Input[int]] = None,
                 logout: Optional[pulumi.Input['ClientAddonsSamlpLogoutArgs']] = None,
                 map_identities: Optional[pulumi.Input[bool]] = None,
                 map_unknown_claims_as_is: Optional[pulumi.Input[bool]] = None,
                 mappings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name_identifier_format: Optional[pulumi.Input[str]] = None,
                 name_identifier_probes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 passthrough_claims_with_no_mapping: Optional[pulumi.Input[bool]] = None,
                 recipient: Optional[pulumi.Input[str]] = None,
                 sign_response: Optional[pulumi.Input[bool]] = None,
                 signature_algorithm: Optional[pulumi.Input[str]] = None,
                 signing_cert: Optional[pulumi.Input[str]] = None,
                 typed_attributes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] audience: Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        :param pulumi.Input[str] authn_context_class_ref: Class reference of the authentication context.
        :param pulumi.Input[str] binding: Protocol binding used for SAML logout responses.
        :param pulumi.Input[bool] create_upn_claim: Indicates whether a UPN claim should be created. Defaults to `true`.
        :param pulumi.Input[str] destination: Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        :param pulumi.Input[str] digest_algorithm: Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        :param pulumi.Input[bool] include_attribute_name_format: Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        :param pulumi.Input[str] issuer: Issuer of the SAML Assertion.
        :param pulumi.Input[int] lifetime_in_seconds: Number of seconds during which the token is valid. Defaults to `3600` seconds.
        :param pulumi.Input['ClientAddonsSamlpLogoutArgs'] logout: Configuration settings for logout.
        :param pulumi.Input[bool] map_identities: Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        :param pulumi.Input[bool] map_unknown_claims_as_is: Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] mappings: Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        :param pulumi.Input[str] name_identifier_format: Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] name_identifier_probes: Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        :param pulumi.Input[bool] passthrough_claims_with_no_mapping: Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        :param pulumi.Input[str] recipient: Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        :param pulumi.Input[bool] sign_response: Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        :param pulumi.Input[str] signature_algorithm: Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        :param pulumi.Input[str] signing_cert: Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        :param pulumi.Input[bool] typed_attributes: Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if authn_context_class_ref is not None:
            pulumi.set(__self__, "authn_context_class_ref", authn_context_class_ref)
        if binding is not None:
            pulumi.set(__self__, "binding", binding)
        if create_upn_claim is not None:
            pulumi.set(__self__, "create_upn_claim", create_upn_claim)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if digest_algorithm is not None:
            pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        if include_attribute_name_format is not None:
            pulumi.set(__self__, "include_attribute_name_format", include_attribute_name_format)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if logout is not None:
            pulumi.set(__self__, "logout", logout)
        if map_identities is not None:
            pulumi.set(__self__, "map_identities", map_identities)
        if map_unknown_claims_as_is is not None:
            pulumi.set(__self__, "map_unknown_claims_as_is", map_unknown_claims_as_is)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if name_identifier_format is not None:
            pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        if name_identifier_probes is not None:
            pulumi.set(__self__, "name_identifier_probes", name_identifier_probes)
        if passthrough_claims_with_no_mapping is not None:
            pulumi.set(__self__, "passthrough_claims_with_no_mapping", passthrough_claims_with_no_mapping)
        if recipient is not None:
            pulumi.set(__self__, "recipient", recipient)
        if sign_response is not None:
            pulumi.set(__self__, "sign_response", sign_response)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if signing_cert is not None:
            pulumi.set(__self__, "signing_cert", signing_cert)
        if typed_attributes is not None:
            pulumi.set(__self__, "typed_attributes", typed_attributes)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="authnContextClassRef")
    def authn_context_class_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Class reference of the authentication context.
        """
        return pulumi.get(self, "authn_context_class_ref")

    @authn_context_class_ref.setter
    def authn_context_class_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authn_context_class_ref", value)

    @property
    @pulumi.getter
    def binding(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol binding used for SAML logout responses.
        """
        return pulumi.get(self, "binding")

    @binding.setter
    def binding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binding", value)

    @property
    @pulumi.getter(name="createUpnClaim")
    def create_upn_claim(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a UPN claim should be created. Defaults to `true`.
        """
        return pulumi.get(self, "create_upn_claim")

    @create_upn_claim.setter
    def create_upn_claim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_upn_claim", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
        """
        return pulumi.get(self, "digest_algorithm")

    @digest_algorithm.setter
    def digest_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest_algorithm", value)

    @property
    @pulumi.getter(name="includeAttributeNameFormat")
    def include_attribute_name_format(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
        """
        return pulumi.get(self, "include_attribute_name_format")

    @include_attribute_name_format.setter
    def include_attribute_name_format(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_attribute_name_format", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds during which the token is valid. Defaults to `3600` seconds.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @lifetime_in_seconds.setter
    def lifetime_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_in_seconds", value)

    @property
    @pulumi.getter
    def logout(self) -> Optional[pulumi.Input['ClientAddonsSamlpLogoutArgs']]:
        """
        Configuration settings for logout.
        """
        return pulumi.get(self, "logout")

    @logout.setter
    def logout(self, value: Optional[pulumi.Input['ClientAddonsSamlpLogoutArgs']]):
        pulumi.set(self, "logout", value)

    @property
    @pulumi.getter(name="mapIdentities")
    def map_identities(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
        """
        return pulumi.get(self, "map_identities")

    @map_identities.setter
    def map_identities(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "map_identities", value)

    @property
    @pulumi.getter(name="mapUnknownClaimsAsIs")
    def map_unknown_claims_as_is(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
        """
        return pulumi.get(self, "map_unknown_claims_as_is")

    @map_unknown_claims_as_is.setter
    def map_unknown_claims_as_is(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "map_unknown_claims_as_is", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "mappings", value)

    @property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> Optional[pulumi.Input[str]]:
        """
        Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @name_identifier_format.setter
    def name_identifier_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_identifier_format", value)

    @property
    @pulumi.getter(name="nameIdentifierProbes")
    def name_identifier_probes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
        """
        return pulumi.get(self, "name_identifier_probes")

    @name_identifier_probes.setter
    def name_identifier_probes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "name_identifier_probes", value)

    @property
    @pulumi.getter(name="passthroughClaimsWithNoMapping")
    def passthrough_claims_with_no_mapping(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
        """
        return pulumi.get(self, "passthrough_claims_with_no_mapping")

    @passthrough_claims_with_no_mapping.setter
    def passthrough_claims_with_no_mapping(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passthrough_claims_with_no_mapping", value)

    @property
    @pulumi.getter
    def recipient(self) -> Optional[pulumi.Input[str]]:
        """
        Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient", value)

    @property
    @pulumi.getter(name="signResponse")
    def sign_response(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
        """
        return pulumi.get(self, "sign_response")

    @sign_response.setter
    def sign_response(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_response", value)

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signature_algorithm", value)

    @property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\\nMIGf...bpP/t3\\n+JGNGIRMj1hF1rnb6QIDAQAB\\n-----END PUBLIC KEY-----\\n`.
        """
        return pulumi.get(self, "signing_cert")

    @signing_cert.setter
    def signing_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_cert", value)

    @property
    @pulumi.getter(name="typedAttributes")
    def typed_attributes(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
        """
        return pulumi.get(self, "typed_attributes")

    @typed_attributes.setter
    def typed_attributes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "typed_attributes", value)


if not MYPY:
    class ClientAddonsSamlpLogoutArgsDict(TypedDict):
        callback: NotRequired[pulumi.Input[str]]
        """
        The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        """
        slo_enabled: NotRequired[pulumi.Input[bool]]
        """
        Controls whether Auth0 should notify service providers of session termination.
        """
elif False:
    ClientAddonsSamlpLogoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSamlpLogoutArgs:
    def __init__(__self__, *,
                 callback: Optional[pulumi.Input[str]] = None,
                 slo_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] callback: The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        :param pulumi.Input[bool] slo_enabled: Controls whether Auth0 should notify service providers of session termination.
        """
        if callback is not None:
            pulumi.set(__self__, "callback", callback)
        if slo_enabled is not None:
            pulumi.set(__self__, "slo_enabled", slo_enabled)

    @property
    @pulumi.getter
    def callback(self) -> Optional[pulumi.Input[str]]:
        """
        The service provider (client application)'s Single Logout Service URL, where Auth0 will send logout requests and responses.
        """
        return pulumi.get(self, "callback")

    @callback.setter
    def callback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "callback", value)

    @property
    @pulumi.getter(name="sloEnabled")
    def slo_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether Auth0 should notify service providers of session termination.
        """
        return pulumi.get(self, "slo_enabled")

    @slo_enabled.setter
    def slo_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "slo_enabled", value)


if not MYPY:
    class ClientAddonsSapApiArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute`client*id`must be set and equal the`client*id` form parameter of the access token request.
        """
        name_identifier_format: NotRequired[pulumi.Input[str]]
        """
        NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        Requested scope for SAP APIs.
        """
        service_password: NotRequired[pulumi.Input[str]]
        """
        Service account password to use to authenticate API calls to the token endpoint.
        """
        token_endpoint_url: NotRequired[pulumi.Input[str]]
        """
        The OAuth2 token endpoint URL of your SAP OData server.
        """
        username_attribute: NotRequired[pulumi.Input[str]]
        """
        Name of the property in the user object that maps to a SAP username, for example `email`.
        """
elif False:
    ClientAddonsSapApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSapApiArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 name_identifier_format: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 service_password: Optional[pulumi.Input[str]] = None,
                 token_endpoint_url: Optional[pulumi.Input[str]] = None,
                 username_attribute: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute`client*id`must be set and equal the`client*id` form parameter of the access token request.
        :param pulumi.Input[str] name_identifier_format: NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        :param pulumi.Input[str] scope: Requested scope for SAP APIs.
        :param pulumi.Input[str] service_password: Service account password to use to authenticate API calls to the token endpoint.
        :param pulumi.Input[str] token_endpoint_url: The OAuth2 token endpoint URL of your SAP OData server.
        :param pulumi.Input[str] username_attribute: Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name_identifier_format is not None:
            pulumi.set(__self__, "name_identifier_format", name_identifier_format)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if service_password is not None:
            pulumi.set(__self__, "service_password", service_password)
        if token_endpoint_url is not None:
            pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        if username_attribute is not None:
            pulumi.set(__self__, "username_attribute", username_attribute)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        If activated in the OAuth 2.0 client configuration (transaction `SOAUTH2) the SAML attribute`client*id`must be set and equal the`client*id` form parameter of the access token request.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="nameIdentifierFormat")
    def name_identifier_format(self) -> Optional[pulumi.Input[str]]:
        """
        NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
        """
        return pulumi.get(self, "name_identifier_format")

    @name_identifier_format.setter
    def name_identifier_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_identifier_format", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        Requested scope for SAP APIs.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="servicePassword")
    def service_password(self) -> Optional[pulumi.Input[str]]:
        """
        Service account password to use to authenticate API calls to the token endpoint.
        """
        return pulumi.get(self, "service_password")

    @service_password.setter
    def service_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_password", value)

    @property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth2 token endpoint URL of your SAP OData server.
        """
        return pulumi.get(self, "token_endpoint_url")

    @token_endpoint_url.setter
    def token_endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_url", value)

    @property
    @pulumi.getter(name="usernameAttribute")
    def username_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property in the user object that maps to a SAP username, for example `email`.
        """
        return pulumi.get(self, "username_attribute")

    @username_attribute.setter
    def username_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_attribute", value)


if not MYPY:
    class ClientAddonsSentryArgsDict(TypedDict):
        base_url: NotRequired[pulumi.Input[str]]
        """
        URL prefix only if running Sentry Community Edition, otherwise leave empty.
        """
        org_slug: NotRequired[pulumi.Input[str]]
        """
        Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
elif False:
    ClientAddonsSentryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSentryArgs:
    def __init__(__self__, *,
                 base_url: Optional[pulumi.Input[str]] = None,
                 org_slug: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: URL prefix only if running Sentry Community Edition, otherwise leave empty.
        :param pulumi.Input[str] org_slug: Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if org_slug is not None:
            pulumi.set(__self__, "org_slug", org_slug)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL prefix only if running Sentry Community Edition, otherwise leave empty.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="orgSlug")
    def org_slug(self) -> Optional[pulumi.Input[str]]:
        """
        Generated slug for your Sentry organization. Found in your Sentry URL, for example `https://sentry.acme.com/acme-org/` would be `acme-org`.
        """
        return pulumi.get(self, "org_slug")

    @org_slug.setter
    def org_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_slug", value)


if not MYPY:
    class ClientAddonsSharepointArgsDict(TypedDict):
        external_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External SharePoint application URLs if exposed to the Internet.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        Internal SharePoint application URL.
        """
elif False:
    ClientAddonsSharepointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSharepointArgs:
    def __init__(__self__, *,
                 external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_urls: External SharePoint application URLs if exposed to the Internet.
        :param pulumi.Input[str] url: Internal SharePoint application URL.
        """
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External SharePoint application URLs if exposed to the Internet.
        """
        return pulumi.get(self, "external_urls")

    @external_urls.setter
    def external_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_urls", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Internal SharePoint application URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClientAddonsSlackArgsDict(TypedDict):
        team: NotRequired[pulumi.Input[str]]
        """
        Slack team name.
        """
elif False:
    ClientAddonsSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSlackArgs:
    def __init__(__self__, *,
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] team: Slack team name.
        """
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        Slack team name.
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ClientAddonsSpringcmArgsDict(TypedDict):
        acs_url: NotRequired[pulumi.Input[str]]
        """
        SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
elif False:
    ClientAddonsSpringcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSpringcmArgs:
    def __init__(__self__, *,
                 acs_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] acs_url: SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        if acs_url is not None:
            pulumi.set(__self__, "acs_url", acs_url)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> Optional[pulumi.Input[str]]:
        """
        SpringCM ACS URL, for example `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acs_url", value)


if not MYPY:
    class ClientAddonsSsoIntegrationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        SSO integration name.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        SSO integration version installed.
        """
elif False:
    ClientAddonsSsoIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsSsoIntegrationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: SSO integration name.
        :param pulumi.Input[str] version: SSO integration version installed.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        SSO integration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        SSO integration version installed.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClientAddonsWamsArgsDict(TypedDict):
        master_key: NotRequired[pulumi.Input[str]]
        """
        Your master key for Windows Azure Mobile Services.
        """
elif False:
    ClientAddonsWamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsWamsArgs:
    def __init__(__self__, *,
                 master_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] master_key: Your master key for Windows Azure Mobile Services.
        """
        if master_key is not None:
            pulumi.set(__self__, "master_key", master_key)

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your master key for Windows Azure Mobile Services.
        """
        return pulumi.get(self, "master_key")

    @master_key.setter
    def master_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_key", value)


if not MYPY:
    class ClientAddonsWsfedArgsDict(TypedDict):
        pass
elif False:
    ClientAddonsWsfedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsWsfedArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ClientAddonsZendeskArgsDict(TypedDict):
        account_name: NotRequired[pulumi.Input[str]]
        """
        Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
elif False:
    ClientAddonsZendeskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsZendeskArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_name: Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[str]]:
        """
        Zendesk account name. Usually the first segment in your Zendesk URL, for example `https://acme-org.zendesk.com` would be `acme-org`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_name", value)


if not MYPY:
    class ClientAddonsZoomArgsDict(TypedDict):
        account: NotRequired[pulumi.Input[str]]
        """
        Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
elif False:
    ClientAddonsZoomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientAddonsZoomArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account: Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)

    @property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[str]]:
        """
        Zoom account name. Usually the first segment of your Zoom URL, for example `https://acme-org.zoom.us` would be `acme-org`.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account", value)


if not MYPY:
    class ClientCredentialsPrivateKeyJwtArgsDict(TypedDict):
        credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsPrivateKeyJwtCredentialArgsDict']]]
        """
        Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
        """
elif False:
    ClientCredentialsPrivateKeyJwtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsPrivateKeyJwtArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsPrivateKeyJwtCredentialArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientCredentialsPrivateKeyJwtCredentialArgs']]] credentials: Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
        """
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[Sequence[pulumi.Input['ClientCredentialsPrivateKeyJwtCredentialArgs']]]:
        """
        Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsPrivateKeyJwtCredentialArgs']]]):
        pulumi.set(self, "credentials", value)


if not MYPY:
    class ClientCredentialsPrivateKeyJwtCredentialArgsDict(TypedDict):
        credential_type: pulumi.Input[str]
        """
        Credential type. Supported types: `public_key`.
        """
        pem: pulumi.Input[str]
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        algorithm: NotRequired[pulumi.Input[str]]
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was created.
        """
        expires_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the client credential.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The key identifier of the credential, generated on creation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Friendly name for a credential.
        """
        parse_expiry_from_cert: NotRequired[pulumi.Input[bool]]
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was updated.
        """
elif False:
    ClientCredentialsPrivateKeyJwtCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsPrivateKeyJwtCredentialArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[str],
                 pem: pulumi.Input[str],
                 algorithm: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parse_expiry_from_cert: Optional[pulumi.Input[bool]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_type: Credential type. Supported types: `public_key`.
        :param pulumi.Input[str] pem: PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        :param pulumi.Input[str] algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the credential was created.
        :param pulumi.Input[str] expires_at: The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        :param pulumi.Input[str] id: The ID of the client credential.
        :param pulumi.Input[str] key_id: The key identifier of the credential, generated on creation.
        :param pulumi.Input[str] name: Friendly name for a credential.
        :param pulumi.Input[bool] parse_expiry_from_cert: Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "pem", pem)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parse_expiry_from_cert is not None:
            pulumi.set(__self__, "parse_expiry_from_cert", parse_expiry_from_cert)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[str]:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter
    def pem(self) -> pulumi.Input[str]:
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem", value)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parseExpiryFromCert")
    def parse_expiry_from_cert(self) -> Optional[pulumi.Input[bool]]:
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        return pulumi.get(self, "parse_expiry_from_cert")

    @parse_expiry_from_cert.setter
    def parse_expiry_from_cert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parse_expiry_from_cert", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ClientCredentialsSelfSignedTlsClientAuthArgsDict(TypedDict):
        credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSelfSignedTlsClientAuthCredentialArgsDict']]]
        """
        Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
elif False:
    ClientCredentialsSelfSignedTlsClientAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsSelfSignedTlsClientAuthArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSelfSignedTlsClientAuthCredentialArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSelfSignedTlsClientAuthCredentialArgs']]] credentials: Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSelfSignedTlsClientAuthCredentialArgs']]]:
        """
        Credentials that will be enabled on the client for mTLS authentication utilizing self-signed certificates.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSelfSignedTlsClientAuthCredentialArgs']]]):
        pulumi.set(self, "credentials", value)


if not MYPY:
    class ClientCredentialsSelfSignedTlsClientAuthCredentialArgsDict(TypedDict):
        pem: pulumi.Input[str]
        """
        PEM-formatted X509 certificate. Must be JSON escaped.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was created.
        """
        credential_type: NotRequired[pulumi.Input[str]]
        """
        Credential type. Supported types: `x509_cert`.
        """
        expires_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date representing the expiration of the credential.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the client credential.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Friendly name for a credential.
        """
        thumbprint_sha256: NotRequired[pulumi.Input[str]]
        """
        The X509 certificate's SHA256 thumbprint.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was updated.
        """
elif False:
    ClientCredentialsSelfSignedTlsClientAuthCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsSelfSignedTlsClientAuthCredentialArgs:
    def __init__(__self__, *,
                 pem: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 credential_type: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 thumbprint_sha256: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pem: PEM-formatted X509 certificate. Must be JSON escaped.
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the credential was created.
        :param pulumi.Input[str] credential_type: Credential type. Supported types: `x509_cert`.
        :param pulumi.Input[str] expires_at: The ISO 8601 formatted date representing the expiration of the credential.
        :param pulumi.Input[str] id: The ID of the client credential.
        :param pulumi.Input[str] name: Friendly name for a credential.
        :param pulumi.Input[str] thumbprint_sha256: The X509 certificate's SHA256 thumbprint.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "pem", pem)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if thumbprint_sha256 is not None:
            pulumi.set(__self__, "thumbprint_sha256", thumbprint_sha256)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def pem(self) -> pulumi.Input[str]:
        """
        PEM-formatted X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[str]]:
        """
        Credential type. Supported types: `x509_cert`.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date representing the expiration of the credential.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="thumbprintSha256")
    def thumbprint_sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The X509 certificate's SHA256 thumbprint.
        """
        return pulumi.get(self, "thumbprint_sha256")

    @thumbprint_sha256.setter
    def thumbprint_sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint_sha256", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ClientCredentialsSignedRequestObjectArgsDict(TypedDict):
        credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSignedRequestObjectCredentialArgsDict']]]
        """
        Client credentials for use with JWT-secured authorization requests.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Require JWT-secured authorization requests.
        """
elif False:
    ClientCredentialsSignedRequestObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsSignedRequestObjectArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSignedRequestObjectCredentialArgs']]],
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSignedRequestObjectCredentialArgs']]] credentials: Client credentials for use with JWT-secured authorization requests.
        :param pulumi.Input[bool] required: Require JWT-secured authorization requests.
        """
        pulumi.set(__self__, "credentials", credentials)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSignedRequestObjectCredentialArgs']]]:
        """
        Client credentials for use with JWT-secured authorization requests.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsSignedRequestObjectCredentialArgs']]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Require JWT-secured authorization requests.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ClientCredentialsSignedRequestObjectCredentialArgsDict(TypedDict):
        credential_type: pulumi.Input[str]
        """
        Credential type. Supported types: `public_key`.
        """
        pem: pulumi.Input[str]
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        algorithm: NotRequired[pulumi.Input[str]]
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was created.
        """
        expires_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the client credential.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The key identifier of the credential, generated on creation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Friendly name for a credential.
        """
        parse_expiry_from_cert: NotRequired[pulumi.Input[bool]]
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was updated.
        """
elif False:
    ClientCredentialsSignedRequestObjectCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsSignedRequestObjectCredentialArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[str],
                 pem: pulumi.Input[str],
                 algorithm: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parse_expiry_from_cert: Optional[pulumi.Input[bool]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_type: Credential type. Supported types: `public_key`.
        :param pulumi.Input[str] pem: PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        :param pulumi.Input[str] algorithm: Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the credential was created.
        :param pulumi.Input[str] expires_at: The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        :param pulumi.Input[str] id: The ID of the client credential.
        :param pulumi.Input[str] key_id: The key identifier of the credential, generated on creation.
        :param pulumi.Input[str] name: Friendly name for a credential.
        :param pulumi.Input[bool] parse_expiry_from_cert: Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "pem", pem)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parse_expiry_from_cert is not None:
            pulumi.set(__self__, "parse_expiry_from_cert", parse_expiry_from_cert)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[str]:
        """
        Credential type. Supported types: `public_key`.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter
    def pem(self) -> pulumi.Input[str]:
        """
        PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem", value)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm which will be used with the credential. Can be one of `RS256`, `RS384`, `PS256`. If not specified, `RS256` will be used.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date representing the expiration of the credential. It is not possible to set this to never expire after it has been set. Recreate the certificate if needed.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key identifier of the credential, generated on creation.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parseExpiryFromCert")
    def parse_expiry_from_cert(self) -> Optional[pulumi.Input[bool]]:
        """
        Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. If also the `expires_at` is set the credential expiry will be set to the explicit `expires_at` value.
        """
        return pulumi.get(self, "parse_expiry_from_cert")

    @parse_expiry_from_cert.setter
    def parse_expiry_from_cert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parse_expiry_from_cert", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ClientCredentialsTlsClientAuthArgsDict(TypedDict):
        credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsTlsClientAuthCredentialArgsDict']]]
        """
        Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
elif False:
    ClientCredentialsTlsClientAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsTlsClientAuthArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsTlsClientAuthCredentialArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClientCredentialsTlsClientAuthCredentialArgs']]] credentials: Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[Sequence[pulumi.Input['ClientCredentialsTlsClientAuthCredentialArgs']]]:
        """
        Credentials that will be enabled on the client for CA-based mTLS authentication.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[Sequence[pulumi.Input['ClientCredentialsTlsClientAuthCredentialArgs']]]):
        pulumi.set(self, "credentials", value)


if not MYPY:
    class ClientCredentialsTlsClientAuthCredentialArgsDict(TypedDict):
        credential_type: pulumi.Input[str]
        """
        Credential type. Supported types: `cert_subject_dn`.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was created.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the client credential.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Friendly name for a credential.
        """
        pem: NotRequired[pulumi.Input[str]]
        """
        PEM-formatted X509 certificate. Must be JSON escaped. Mutually exlusive with `subject_dn` property.
        """
        subject_dn: NotRequired[pulumi.Input[str]]
        """
        Subject Distinguished Name. Mutually exlusive with `pem` property.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the credential was updated.
        """
elif False:
    ClientCredentialsTlsClientAuthCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCredentialsTlsClientAuthCredentialArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pem: Optional[pulumi.Input[str]] = None,
                 subject_dn: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_type: Credential type. Supported types: `cert_subject_dn`.
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the credential was created.
        :param pulumi.Input[str] id: The ID of the client credential.
        :param pulumi.Input[str] name: Friendly name for a credential.
        :param pulumi.Input[str] pem: PEM-formatted X509 certificate. Must be JSON escaped. Mutually exlusive with `subject_dn` property.
        :param pulumi.Input[str] subject_dn: Subject Distinguished Name. Mutually exlusive with `pem` property.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the credential was updated.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pem is not None:
            pulumi.set(__self__, "pem", pem)
        if subject_dn is not None:
            pulumi.set(__self__, "subject_dn", subject_dn)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[str]:
        """
        Credential type. Supported types: `cert_subject_dn`.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the client credential.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name for a credential.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pem(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-formatted X509 certificate. Must be JSON escaped. Mutually exlusive with `subject_dn` property.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pem", value)

    @property
    @pulumi.getter(name="subjectDn")
    def subject_dn(self) -> Optional[pulumi.Input[str]]:
        """
        Subject Distinguished Name. Mutually exlusive with `pem` property.
        """
        return pulumi.get(self, "subject_dn")

    @subject_dn.setter
    def subject_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_dn", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the credential was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ClientDefaultOrganizationArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        If set, the `default_organization` will be removed.
        """
        flows: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Definition of the flow that needs to be configured. Eg. client_credentials
        """
        organization_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the organization
        """
elif False:
    ClientDefaultOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientDefaultOrganizationArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 flows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 organization_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable: If set, the `default_organization` will be removed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flows: Definition of the flow that needs to be configured. Eg. client_credentials
        :param pulumi.Input[str] organization_id: The unique identifier of the organization
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if flows is not None:
            pulumi.set(__self__, "flows", flows)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, the `default_organization` will be removed.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def flows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Definition of the flow that needs to be configured. Eg. client_credentials
        """
        return pulumi.get(self, "flows")

    @flows.setter
    def flows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flows", value)

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the organization
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization_id", value)


if not MYPY:
    class ClientJwtConfigurationArgsDict(TypedDict):
        alg: NotRequired[pulumi.Input[str]]
        """
        Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        """
        lifetime_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Number of seconds during which the JWT will be valid.
        """
        scopes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Permissions (scopes) included in JWTs.
        """
        secret_encoded: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the client secret is Base64-encoded.
        """
elif False:
    ClientJwtConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientJwtConfigurationArgs:
    def __init__(__self__, *,
                 alg: Optional[pulumi.Input[str]] = None,
                 lifetime_in_seconds: Optional[pulumi.Input[int]] = None,
                 scopes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secret_encoded: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] alg: Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        :param pulumi.Input[int] lifetime_in_seconds: Number of seconds during which the JWT will be valid.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] scopes: Permissions (scopes) included in JWTs.
        :param pulumi.Input[bool] secret_encoded: Indicates whether the client secret is Base64-encoded.
        """
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if lifetime_in_seconds is not None:
            pulumi.set(__self__, "lifetime_in_seconds", lifetime_in_seconds)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_encoded is not None:
            pulumi.set(__self__, "secret_encoded", secret_encoded)

    @property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm used to sign JWTs. Can be one of `HS256`, `RS256`, `PS256`.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alg", value)

    @property
    @pulumi.getter(name="lifetimeInSeconds")
    def lifetime_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds during which the JWT will be valid.
        """
        return pulumi.get(self, "lifetime_in_seconds")

    @lifetime_in_seconds.setter
    def lifetime_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_in_seconds", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Permissions (scopes) included in JWTs.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="secretEncoded")
    def secret_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the client secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_encoded")

    @secret_encoded.setter
    def secret_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret_encoded", value)


if not MYPY:
    class ClientMobileArgsDict(TypedDict):
        android: NotRequired[pulumi.Input['ClientMobileAndroidArgsDict']]
        """
        Configuration settings for Android native apps.
        """
        ios: NotRequired[pulumi.Input['ClientMobileIosArgsDict']]
        """
        Configuration settings for i0S native apps.
        """
elif False:
    ClientMobileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientMobileArgs:
    def __init__(__self__, *,
                 android: Optional[pulumi.Input['ClientMobileAndroidArgs']] = None,
                 ios: Optional[pulumi.Input['ClientMobileIosArgs']] = None):
        """
        :param pulumi.Input['ClientMobileAndroidArgs'] android: Configuration settings for Android native apps.
        :param pulumi.Input['ClientMobileIosArgs'] ios: Configuration settings for i0S native apps.
        """
        if android is not None:
            pulumi.set(__self__, "android", android)
        if ios is not None:
            pulumi.set(__self__, "ios", ios)

    @property
    @pulumi.getter
    def android(self) -> Optional[pulumi.Input['ClientMobileAndroidArgs']]:
        """
        Configuration settings for Android native apps.
        """
        return pulumi.get(self, "android")

    @android.setter
    def android(self, value: Optional[pulumi.Input['ClientMobileAndroidArgs']]):
        pulumi.set(self, "android", value)

    @property
    @pulumi.getter
    def ios(self) -> Optional[pulumi.Input['ClientMobileIosArgs']]:
        """
        Configuration settings for i0S native apps.
        """
        return pulumi.get(self, "ios")

    @ios.setter
    def ios(self, value: Optional[pulumi.Input['ClientMobileIosArgs']]):
        pulumi.set(self, "ios", value)


if not MYPY:
    class ClientMobileAndroidArgsDict(TypedDict):
        app_package_name: NotRequired[pulumi.Input[str]]
        sha256_cert_fingerprints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ClientMobileAndroidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientMobileAndroidArgs:
    def __init__(__self__, *,
                 app_package_name: Optional[pulumi.Input[str]] = None,
                 sha256_cert_fingerprints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if app_package_name is not None:
            pulumi.set(__self__, "app_package_name", app_package_name)
        if sha256_cert_fingerprints is not None:
            pulumi.set(__self__, "sha256_cert_fingerprints", sha256_cert_fingerprints)

    @property
    @pulumi.getter(name="appPackageName")
    def app_package_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_package_name")

    @app_package_name.setter
    def app_package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_package_name", value)

    @property
    @pulumi.getter(name="sha256CertFingerprints")
    def sha256_cert_fingerprints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sha256_cert_fingerprints")

    @sha256_cert_fingerprints.setter
    def sha256_cert_fingerprints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sha256_cert_fingerprints", value)


if not MYPY:
    class ClientMobileIosArgsDict(TypedDict):
        app_bundle_identifier: NotRequired[pulumi.Input[str]]
        team_id: NotRequired[pulumi.Input[str]]
elif False:
    ClientMobileIosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientMobileIosArgs:
    def __init__(__self__, *,
                 app_bundle_identifier: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None):
        if app_bundle_identifier is not None:
            pulumi.set(__self__, "app_bundle_identifier", app_bundle_identifier)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="appBundleIdentifier")
    def app_bundle_identifier(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_bundle_identifier")

    @app_bundle_identifier.setter
    def app_bundle_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_bundle_identifier", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ClientNativeSocialLoginArgsDict(TypedDict):
        apple: NotRequired[pulumi.Input['ClientNativeSocialLoginAppleArgsDict']]
        facebook: NotRequired[pulumi.Input['ClientNativeSocialLoginFacebookArgsDict']]
elif False:
    ClientNativeSocialLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientNativeSocialLoginArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['ClientNativeSocialLoginAppleArgs']] = None,
                 facebook: Optional[pulumi.Input['ClientNativeSocialLoginFacebookArgs']] = None):
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)

    @property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['ClientNativeSocialLoginAppleArgs']]:
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['ClientNativeSocialLoginAppleArgs']]):
        pulumi.set(self, "apple", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['ClientNativeSocialLoginFacebookArgs']]:
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['ClientNativeSocialLoginFacebookArgs']]):
        pulumi.set(self, "facebook", value)


if not MYPY:
    class ClientNativeSocialLoginAppleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ClientNativeSocialLoginAppleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientNativeSocialLoginAppleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClientNativeSocialLoginFacebookArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ClientNativeSocialLoginFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientNativeSocialLoginFacebookArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClientRefreshTokenArgsDict(TypedDict):
        expiration_type: pulumi.Input[str]
        """
        Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        """
        rotation_type: pulumi.Input[str]
        """
        Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        """
        idle_token_lifetime: NotRequired[pulumi.Input[int]]
        """
        The time in seconds after which inactive refresh tokens will expire.
        """
        infinite_idle_token_lifetime: NotRequired[pulumi.Input[bool]]
        """
        Whether inactive refresh tokens should remain valid indefinitely.
        """
        infinite_token_lifetime: NotRequired[pulumi.Input[bool]]
        """
        Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        """
        leeway: NotRequired[pulumi.Input[int]]
        """
        The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        """
        token_lifetime: NotRequired[pulumi.Input[int]]
        """
        The absolute lifetime of a refresh token in seconds.
        """
elif False:
    ClientRefreshTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientRefreshTokenArgs:
    def __init__(__self__, *,
                 expiration_type: pulumi.Input[str],
                 rotation_type: pulumi.Input[str],
                 idle_token_lifetime: Optional[pulumi.Input[int]] = None,
                 infinite_idle_token_lifetime: Optional[pulumi.Input[bool]] = None,
                 infinite_token_lifetime: Optional[pulumi.Input[bool]] = None,
                 leeway: Optional[pulumi.Input[int]] = None,
                 token_lifetime: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] expiration_type: Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        :param pulumi.Input[str] rotation_type: Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        :param pulumi.Input[int] idle_token_lifetime: The time in seconds after which inactive refresh tokens will expire.
        :param pulumi.Input[bool] infinite_idle_token_lifetime: Whether inactive refresh tokens should remain valid indefinitely.
        :param pulumi.Input[bool] infinite_token_lifetime: Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        :param pulumi.Input[int] leeway: The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        :param pulumi.Input[int] token_lifetime: The absolute lifetime of a refresh token in seconds.
        """
        pulumi.set(__self__, "expiration_type", expiration_type)
        pulumi.set(__self__, "rotation_type", rotation_type)
        if idle_token_lifetime is not None:
            pulumi.set(__self__, "idle_token_lifetime", idle_token_lifetime)
        if infinite_idle_token_lifetime is not None:
            pulumi.set(__self__, "infinite_idle_token_lifetime", infinite_idle_token_lifetime)
        if infinite_token_lifetime is not None:
            pulumi.set(__self__, "infinite_token_lifetime", infinite_token_lifetime)
        if leeway is not None:
            pulumi.set(__self__, "leeway", leeway)
        if token_lifetime is not None:
            pulumi.set(__self__, "token_lifetime", token_lifetime)

    @property
    @pulumi.getter(name="expirationType")
    def expiration_type(self) -> pulumi.Input[str]:
        """
        Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
        """
        return pulumi.get(self, "expiration_type")

    @expiration_type.setter
    def expiration_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "expiration_type", value)

    @property
    @pulumi.getter(name="rotationType")
    def rotation_type(self) -> pulumi.Input[str]:
        """
        Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
        """
        return pulumi.get(self, "rotation_type")

    @rotation_type.setter
    def rotation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rotation_type", value)

    @property
    @pulumi.getter(name="idleTokenLifetime")
    def idle_token_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds after which inactive refresh tokens will expire.
        """
        return pulumi.get(self, "idle_token_lifetime")

    @idle_token_lifetime.setter
    def idle_token_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_token_lifetime", value)

    @property
    @pulumi.getter(name="infiniteIdleTokenLifetime")
    def infinite_idle_token_lifetime(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether inactive refresh tokens should remain valid indefinitely.
        """
        return pulumi.get(self, "infinite_idle_token_lifetime")

    @infinite_idle_token_lifetime.setter
    def infinite_idle_token_lifetime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infinite_idle_token_lifetime", value)

    @property
    @pulumi.getter(name="infiniteTokenLifetime")
    def infinite_token_lifetime(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether refresh tokens should remain valid indefinitely. If false, `token_lifetime` should also be set.
        """
        return pulumi.get(self, "infinite_token_lifetime")

    @infinite_token_lifetime.setter
    def infinite_token_lifetime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infinite_token_lifetime", value)

    @property
    @pulumi.getter
    def leeway(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
        """
        return pulumi.get(self, "leeway")

    @leeway.setter
    def leeway(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "leeway", value)

    @property
    @pulumi.getter(name="tokenLifetime")
    def token_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        The absolute lifetime of a refresh token in seconds.
        """
        return pulumi.get(self, "token_lifetime")

    @token_lifetime.setter
    def token_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "token_lifetime", value)


if not MYPY:
    class ConnectionOptionsArgsDict(TypedDict):
        adfs_server: NotRequired[pulumi.Input[str]]
        """
        ADFS URL where to fetch the metadata source.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of allowed audiences.
        """
        api_enable_users: NotRequired[pulumi.Input[bool]]
        """
        Enable API Access to users.
        """
        app_id: NotRequired[pulumi.Input[str]]
        """
        App ID.
        """
        attribute_map: NotRequired[pulumi.Input['ConnectionOptionsAttributeMapArgsDict']]
        """
        OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeArgsDict']]]]
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        auth_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Query string parameters to be included as part of the generated passwordless email link.
        """
        authorization_endpoint: NotRequired[pulumi.Input[str]]
        """
        Authorization endpoint.
        """
        brute_force_protection: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The strategy's client ID.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The strategy's client secret.
        """
        community_base_url: NotRequired[pulumi.Input[str]]
        """
        Salesforce community base URL.
        """
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        """
        connection_settings: NotRequired[pulumi.Input['ConnectionOptionsConnectionSettingsArgsDict']]
        """
        Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        """
        custom_scripts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of scripts used to integrate with a custom database.
        """
        debug: NotRequired[pulumi.Input[bool]]
        """
        When enabled, additional debug information will be generated.
        """
        decryption_key: NotRequired[pulumi.Input['ConnectionOptionsDecryptionKeyArgsDict']]
        """
        The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        digest_algorithm: NotRequired[pulumi.Input[str]]
        """
        Sign Request Algorithm Digest.
        """
        disable_cache: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to disable the cache or not.
        """
        disable_self_service_change_password: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to remove the forgot password link within the New Universal Login.
        """
        disable_sign_out: NotRequired[pulumi.Input[bool]]
        """
        When enabled, will disable sign out.
        """
        disable_signup: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to allow user sign-ups to your application.
        """
        discovery_url: NotRequired[pulumi.Input[str]]
        """
        OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Domain name.
        """
        domain_aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        """
        enable_script_context: NotRequired[pulumi.Input[bool]]
        """
        Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        """
        enabled_database_customization: NotRequired[pulumi.Input[bool]]
        """
        Set to `true` to use a legacy user store.
        """
        entity_id: NotRequired[pulumi.Input[str]]
        """
        Custom Entity ID for the connection.
        """
        fed_metadata_xml: NotRequired[pulumi.Input[str]]
        """
        Federation Metadata for the ADFS connection.
        """
        fields_map: NotRequired[pulumi.Input[str]]
        """
        If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        """
        forward_request_info: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not request info should be forwarded to sms gateway.
        """
        from_: NotRequired[pulumi.Input[str]]
        """
        Address to use as the sender.
        """
        gateway_authentication: NotRequired[pulumi.Input['ConnectionOptionsGatewayAuthenticationArgsDict']]
        """
        Defines the parameters used to generate the auth token for the custom gateway.
        """
        gateway_url: NotRequired[pulumi.Input[str]]
        """
        Defines a custom sms gateway to use instead of Twilio.
        """
        icon_url: NotRequired[pulumi.Input[str]]
        """
        Icon URL.
        """
        identity_api: NotRequired[pulumi.Input[str]]
        """
        Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        """
        idp_initiated: NotRequired[pulumi.Input['ConnectionOptionsIdpInitiatedArgsDict']]
        """
        Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        """
        import_mode: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IPs.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer URL, e.g. `https://auth.example.com`.
        """
        jwks_uri: NotRequired[pulumi.Input[str]]
        """
        JWKS URI.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        Apple Key ID.
        """
        map_user_id_to_id: NotRequired[pulumi.Input[bool]]
        """
        By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        """
        max_groups_to_retrieve: NotRequired[pulumi.Input[str]]
        """
        Maximum number of groups to retrieve.
        """
        messaging_service_sid: NotRequired[pulumi.Input[str]]
        """
        SID for Copilot. Used when SMS Source is Copilot.
        """
        metadata_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the SAML metadata document.
        """
        metadata_xml: NotRequired[pulumi.Input[str]]
        """
        The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        """
        mfa: NotRequired[pulumi.Input['ConnectionOptionsMfaArgsDict']]
        """
        Configuration options for multifactor authentication.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        """
        non_persistent_attrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        """
        password_complexity_options: NotRequired[pulumi.Input['ConnectionOptionsPasswordComplexityOptionsArgsDict']]
        """
        Configuration settings for password complexity.
        """
        password_dictionary: NotRequired[pulumi.Input['ConnectionOptionsPasswordDictionaryArgsDict']]
        """
        Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        """
        password_histories: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsPasswordHistoryArgsDict']]]]
        """
        Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        """
        password_no_personal_info: NotRequired[pulumi.Input['ConnectionOptionsPasswordNoPersonalInfoArgsDict']]
        """
        Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        """
        password_policy: NotRequired[pulumi.Input[str]]
        """
        Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        """
        ping_federate_base_url: NotRequired[pulumi.Input[str]]
        """
        Ping Federate Server URL.
        """
        pkce_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        """
        precedences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        protocol_binding: NotRequired[pulumi.Input[str]]
        """
        The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        Defines the custom `sms_gateway` provider.
        """
        request_template: NotRequired[pulumi.Input[str]]
        """
        Template that formats the SAML request.
        """
        requires_username: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the user is required to provide a username in addition to an email address.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        """
        scripts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        """
        set_user_root_attributes: NotRequired[pulumi.Input[str]]
        """
        Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`. Default value: `on_each_login`.
        """
        should_trust_email_verified_connection: NotRequired[pulumi.Input[str]]
        """
        Choose how Auth0 sets the email_verified field in the user profile.
        """
        sign_in_endpoint: NotRequired[pulumi.Input[str]]
        """
        SAML single login URL for the connection.
        """
        sign_out_endpoint: NotRequired[pulumi.Input[str]]
        """
        SAML single logout URL for the connection.
        """
        sign_saml_request: NotRequired[pulumi.Input[bool]]
        """
        When enabled, the SAML authentication request will be signed.
        """
        signature_algorithm: NotRequired[pulumi.Input[str]]
        """
        Sign Request Algorithm.
        """
        signing_cert: NotRequired[pulumi.Input[str]]
        """
        X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        """
        signing_key: NotRequired[pulumi.Input['ConnectionOptionsSigningKeyArgsDict']]
        """
        The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        strategy_version: NotRequired[pulumi.Input[int]]
        """
        Version 1 is deprecated, use version 2.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Subject line of the email.
        """
        syntax: NotRequired[pulumi.Input[str]]
        """
        Syntax of the template body.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        Apple Team ID.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        Body of the template.
        """
        tenant_domain: NotRequired[pulumi.Input[str]]
        """
        Tenant domain name.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        Token endpoint.
        """
        totp: NotRequired[pulumi.Input['ConnectionOptionsTotpArgsDict']]
        """
        Configuration options for one-time passwords.
        """
        twilio_sid: NotRequired[pulumi.Input[str]]
        """
        SID for your Twilio account.
        """
        twilio_token: NotRequired[pulumi.Input[str]]
        """
        AuthToken for your Twilio account.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        """
        upstream_params: NotRequired[pulumi.Input[str]]
        """
        You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        """
        use_cert_auth: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use cert auth or not.
        """
        use_kerberos: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use Kerberos or not.
        """
        use_wsfed: NotRequired[pulumi.Input[bool]]
        """
        Whether to use WS-Fed.
        """
        user_id_attribute: NotRequired[pulumi.Input[str]]
        """
        Attribute in the token that will be mapped to the user_id property in Auth0.
        """
        userinfo_endpoint: NotRequired[pulumi.Input[str]]
        """
        User info endpoint.
        """
        validation: NotRequired[pulumi.Input['ConnectionOptionsValidationArgsDict']]
        """
        Validation of the minimum and maximum values allowed for a user to have as username.
        """
        waad_common_endpoint: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        """
        waad_protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol to use.
        """
elif False:
    ConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsArgs:
    def __init__(__self__, *,
                 adfs_server: Optional[pulumi.Input[str]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 api_enable_users: Optional[pulumi.Input[bool]] = None,
                 app_id: Optional[pulumi.Input[str]] = None,
                 attribute_map: Optional[pulumi.Input['ConnectionOptionsAttributeMapArgs']] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeArgs']]]] = None,
                 auth_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[str]] = None,
                 brute_force_protection: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 community_base_url: Optional[pulumi.Input[str]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 connection_settings: Optional[pulumi.Input['ConnectionOptionsConnectionSettingsArgs']] = None,
                 custom_scripts: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 debug: Optional[pulumi.Input[bool]] = None,
                 decryption_key: Optional[pulumi.Input['ConnectionOptionsDecryptionKeyArgs']] = None,
                 digest_algorithm: Optional[pulumi.Input[str]] = None,
                 disable_cache: Optional[pulumi.Input[bool]] = None,
                 disable_self_service_change_password: Optional[pulumi.Input[bool]] = None,
                 disable_sign_out: Optional[pulumi.Input[bool]] = None,
                 disable_signup: Optional[pulumi.Input[bool]] = None,
                 discovery_url: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 domain_aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_script_context: Optional[pulumi.Input[bool]] = None,
                 enabled_database_customization: Optional[pulumi.Input[bool]] = None,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 fed_metadata_xml: Optional[pulumi.Input[str]] = None,
                 fields_map: Optional[pulumi.Input[str]] = None,
                 forward_request_info: Optional[pulumi.Input[bool]] = None,
                 from_: Optional[pulumi.Input[str]] = None,
                 gateway_authentication: Optional[pulumi.Input['ConnectionOptionsGatewayAuthenticationArgs']] = None,
                 gateway_url: Optional[pulumi.Input[str]] = None,
                 icon_url: Optional[pulumi.Input[str]] = None,
                 identity_api: Optional[pulumi.Input[str]] = None,
                 idp_initiated: Optional[pulumi.Input['ConnectionOptionsIdpInitiatedArgs']] = None,
                 import_mode: Optional[pulumi.Input[bool]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 jwks_uri: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 map_user_id_to_id: Optional[pulumi.Input[bool]] = None,
                 max_groups_to_retrieve: Optional[pulumi.Input[str]] = None,
                 messaging_service_sid: Optional[pulumi.Input[str]] = None,
                 metadata_url: Optional[pulumi.Input[str]] = None,
                 metadata_xml: Optional[pulumi.Input[str]] = None,
                 mfa: Optional[pulumi.Input['ConnectionOptionsMfaArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 non_persistent_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password_complexity_options: Optional[pulumi.Input['ConnectionOptionsPasswordComplexityOptionsArgs']] = None,
                 password_dictionary: Optional[pulumi.Input['ConnectionOptionsPasswordDictionaryArgs']] = None,
                 password_histories: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsPasswordHistoryArgs']]]] = None,
                 password_no_personal_info: Optional[pulumi.Input['ConnectionOptionsPasswordNoPersonalInfoArgs']] = None,
                 password_policy: Optional[pulumi.Input[str]] = None,
                 ping_federate_base_url: Optional[pulumi.Input[str]] = None,
                 pkce_enabled: Optional[pulumi.Input[bool]] = None,
                 precedences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocol_binding: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 request_template: Optional[pulumi.Input[str]] = None,
                 requires_username: Optional[pulumi.Input[bool]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 scripts: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 set_user_root_attributes: Optional[pulumi.Input[str]] = None,
                 should_trust_email_verified_connection: Optional[pulumi.Input[str]] = None,
                 sign_in_endpoint: Optional[pulumi.Input[str]] = None,
                 sign_out_endpoint: Optional[pulumi.Input[str]] = None,
                 sign_saml_request: Optional[pulumi.Input[bool]] = None,
                 signature_algorithm: Optional[pulumi.Input[str]] = None,
                 signing_cert: Optional[pulumi.Input[str]] = None,
                 signing_key: Optional[pulumi.Input['ConnectionOptionsSigningKeyArgs']] = None,
                 strategy_version: Optional[pulumi.Input[int]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 syntax: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None,
                 tenant_domain: Optional[pulumi.Input[str]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None,
                 totp: Optional[pulumi.Input['ConnectionOptionsTotpArgs']] = None,
                 twilio_sid: Optional[pulumi.Input[str]] = None,
                 twilio_token: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 upstream_params: Optional[pulumi.Input[str]] = None,
                 use_cert_auth: Optional[pulumi.Input[bool]] = None,
                 use_kerberos: Optional[pulumi.Input[bool]] = None,
                 use_wsfed: Optional[pulumi.Input[bool]] = None,
                 user_id_attribute: Optional[pulumi.Input[str]] = None,
                 userinfo_endpoint: Optional[pulumi.Input[str]] = None,
                 validation: Optional[pulumi.Input['ConnectionOptionsValidationArgs']] = None,
                 waad_common_endpoint: Optional[pulumi.Input[bool]] = None,
                 waad_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] adfs_server: ADFS URL where to fetch the metadata source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: List of allowed audiences.
        :param pulumi.Input[bool] api_enable_users: Enable API Access to users.
        :param pulumi.Input[str] app_id: App ID.
        :param pulumi.Input['ConnectionOptionsAttributeMapArgs'] attribute_map: OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeArgs']]] attributes: Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] auth_params: Query string parameters to be included as part of the generated passwordless email link.
        :param pulumi.Input[str] authorization_endpoint: Authorization endpoint.
        :param pulumi.Input[bool] brute_force_protection: Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        :param pulumi.Input[str] client_id: The strategy's client ID.
        :param pulumi.Input[str] client_secret: The strategy's client secret.
        :param pulumi.Input[str] community_base_url: Salesforce community base URL.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] configuration: A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        :param pulumi.Input['ConnectionOptionsConnectionSettingsArgs'] connection_settings: Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_scripts: A map of scripts used to integrate with a custom database.
        :param pulumi.Input[bool] debug: When enabled, additional debug information will be generated.
        :param pulumi.Input['ConnectionOptionsDecryptionKeyArgs'] decryption_key: The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param pulumi.Input[str] digest_algorithm: Sign Request Algorithm Digest.
        :param pulumi.Input[bool] disable_cache: Indicates whether to disable the cache or not.
        :param pulumi.Input[bool] disable_self_service_change_password: Indicates whether to remove the forgot password link within the New Universal Login.
        :param pulumi.Input[bool] disable_sign_out: When enabled, will disable sign out.
        :param pulumi.Input[bool] disable_signup: Indicates whether to allow user sign-ups to your application.
        :param pulumi.Input[str] discovery_url: OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        :param pulumi.Input[str] domain: Domain name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domain_aliases: List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        :param pulumi.Input[bool] enable_script_context: Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        :param pulumi.Input[bool] enabled_database_customization: Set to `true` to use a legacy user store.
        :param pulumi.Input[str] entity_id: Custom Entity ID for the connection.
        :param pulumi.Input[str] fed_metadata_xml: Federation Metadata for the ADFS connection.
        :param pulumi.Input[str] fields_map: If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        :param pulumi.Input[bool] forward_request_info: Specifies whether or not request info should be forwarded to sms gateway.
        :param pulumi.Input[str] from_: Address to use as the sender.
        :param pulumi.Input['ConnectionOptionsGatewayAuthenticationArgs'] gateway_authentication: Defines the parameters used to generate the auth token for the custom gateway.
        :param pulumi.Input[str] gateway_url: Defines a custom sms gateway to use instead of Twilio.
        :param pulumi.Input[str] icon_url: Icon URL.
        :param pulumi.Input[str] identity_api: Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        :param pulumi.Input['ConnectionOptionsIdpInitiatedArgs'] idp_initiated: Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        :param pulumi.Input[bool] import_mode: Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: A list of IPs.
        :param pulumi.Input[str] issuer: Issuer URL, e.g. `https://auth.example.com`.
        :param pulumi.Input[str] jwks_uri: JWKS URI.
        :param pulumi.Input[str] key_id: Apple Key ID.
        :param pulumi.Input[bool] map_user_id_to_id: By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        :param pulumi.Input[str] max_groups_to_retrieve: Maximum number of groups to retrieve.
        :param pulumi.Input[str] messaging_service_sid: SID for Copilot. Used when SMS Source is Copilot.
        :param pulumi.Input[str] metadata_url: The URL of the SAML metadata document.
        :param pulumi.Input[str] metadata_xml: The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        :param pulumi.Input['ConnectionOptionsMfaArgs'] mfa: Configuration options for multifactor authentication.
        :param pulumi.Input[str] name: The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_persistent_attrs: If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        :param pulumi.Input['ConnectionOptionsPasswordComplexityOptionsArgs'] password_complexity_options: Configuration settings for password complexity.
        :param pulumi.Input['ConnectionOptionsPasswordDictionaryArgs'] password_dictionary: Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsPasswordHistoryArgs']]] password_histories: Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        :param pulumi.Input['ConnectionOptionsPasswordNoPersonalInfoArgs'] password_no_personal_info: Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        :param pulumi.Input[str] password_policy: Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        :param pulumi.Input[str] ping_federate_base_url: Ping Federate Server URL.
        :param pulumi.Input[bool] pkce_enabled: Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] precedences: Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        :param pulumi.Input[str] protocol_binding: The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        :param pulumi.Input[str] provider: Defines the custom `sms_gateway` provider.
        :param pulumi.Input[str] request_template: Template that formats the SAML request.
        :param pulumi.Input[bool] requires_username: Indicates whether the user is required to provide a username in addition to an email address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] scripts: A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        :param pulumi.Input[str] set_user_root_attributes: Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`. Default value: `on_each_login`.
        :param pulumi.Input[str] should_trust_email_verified_connection: Choose how Auth0 sets the email_verified field in the user profile.
        :param pulumi.Input[str] sign_in_endpoint: SAML single login URL for the connection.
        :param pulumi.Input[str] sign_out_endpoint: SAML single logout URL for the connection.
        :param pulumi.Input[bool] sign_saml_request: When enabled, the SAML authentication request will be signed.
        :param pulumi.Input[str] signature_algorithm: Sign Request Algorithm.
        :param pulumi.Input[str] signing_cert: X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        :param pulumi.Input['ConnectionOptionsSigningKeyArgs'] signing_key: The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        :param pulumi.Input[int] strategy_version: Version 1 is deprecated, use version 2.
        :param pulumi.Input[str] subject: Subject line of the email.
        :param pulumi.Input[str] syntax: Syntax of the template body.
        :param pulumi.Input[str] team_id: Apple Team ID.
        :param pulumi.Input[str] template: Body of the template.
        :param pulumi.Input[str] tenant_domain: Tenant domain name.
        :param pulumi.Input[str] token_endpoint: Token endpoint.
        :param pulumi.Input['ConnectionOptionsTotpArgs'] totp: Configuration options for one-time passwords.
        :param pulumi.Input[str] twilio_sid: SID for your Twilio account.
        :param pulumi.Input[str] twilio_token: AuthToken for your Twilio account.
        :param pulumi.Input[str] type: Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        :param pulumi.Input[str] upstream_params: You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        :param pulumi.Input[bool] use_cert_auth: Indicates whether to use cert auth or not.
        :param pulumi.Input[bool] use_kerberos: Indicates whether to use Kerberos or not.
        :param pulumi.Input[bool] use_wsfed: Whether to use WS-Fed.
        :param pulumi.Input[str] user_id_attribute: Attribute in the token that will be mapped to the user_id property in Auth0.
        :param pulumi.Input[str] userinfo_endpoint: User info endpoint.
        :param pulumi.Input['ConnectionOptionsValidationArgs'] validation: Validation of the minimum and maximum values allowed for a user to have as username.
        :param pulumi.Input[bool] waad_common_endpoint: Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        :param pulumi.Input[str] waad_protocol: Protocol to use.
        """
        if adfs_server is not None:
            pulumi.set(__self__, "adfs_server", adfs_server)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if api_enable_users is not None:
            pulumi.set(__self__, "api_enable_users", api_enable_users)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if attribute_map is not None:
            pulumi.set(__self__, "attribute_map", attribute_map)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_params is not None:
            pulumi.set(__self__, "auth_params", auth_params)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if brute_force_protection is not None:
            pulumi.set(__self__, "brute_force_protection", brute_force_protection)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if community_base_url is not None:
            pulumi.set(__self__, "community_base_url", community_base_url)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if connection_settings is not None:
            pulumi.set(__self__, "connection_settings", connection_settings)
        if custom_scripts is not None:
            pulumi.set(__self__, "custom_scripts", custom_scripts)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if decryption_key is not None:
            pulumi.set(__self__, "decryption_key", decryption_key)
        if digest_algorithm is not None:
            pulumi.set(__self__, "digest_algorithm", digest_algorithm)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_self_service_change_password is not None:
            pulumi.set(__self__, "disable_self_service_change_password", disable_self_service_change_password)
        if disable_sign_out is not None:
            pulumi.set(__self__, "disable_sign_out", disable_sign_out)
        if disable_signup is not None:
            pulumi.set(__self__, "disable_signup", disable_signup)
        if discovery_url is not None:
            pulumi.set(__self__, "discovery_url", discovery_url)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_aliases is not None:
            pulumi.set(__self__, "domain_aliases", domain_aliases)
        if enable_script_context is not None:
            pulumi.set(__self__, "enable_script_context", enable_script_context)
        if enabled_database_customization is not None:
            pulumi.set(__self__, "enabled_database_customization", enabled_database_customization)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if fed_metadata_xml is not None:
            pulumi.set(__self__, "fed_metadata_xml", fed_metadata_xml)
        if fields_map is not None:
            pulumi.set(__self__, "fields_map", fields_map)
        if forward_request_info is not None:
            pulumi.set(__self__, "forward_request_info", forward_request_info)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if gateway_authentication is not None:
            pulumi.set(__self__, "gateway_authentication", gateway_authentication)
        if gateway_url is not None:
            pulumi.set(__self__, "gateway_url", gateway_url)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)
        if identity_api is not None:
            pulumi.set(__self__, "identity_api", identity_api)
        if idp_initiated is not None:
            pulumi.set(__self__, "idp_initiated", idp_initiated)
        if import_mode is not None:
            pulumi.set(__self__, "import_mode", import_mode)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if map_user_id_to_id is not None:
            pulumi.set(__self__, "map_user_id_to_id", map_user_id_to_id)
        if max_groups_to_retrieve is not None:
            pulumi.set(__self__, "max_groups_to_retrieve", max_groups_to_retrieve)
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if metadata_url is not None:
            pulumi.set(__self__, "metadata_url", metadata_url)
        if metadata_xml is not None:
            pulumi.set(__self__, "metadata_xml", metadata_xml)
        if mfa is not None:
            pulumi.set(__self__, "mfa", mfa)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_persistent_attrs is not None:
            pulumi.set(__self__, "non_persistent_attrs", non_persistent_attrs)
        if password_complexity_options is not None:
            pulumi.set(__self__, "password_complexity_options", password_complexity_options)
        if password_dictionary is not None:
            pulumi.set(__self__, "password_dictionary", password_dictionary)
        if password_histories is not None:
            pulumi.set(__self__, "password_histories", password_histories)
        if password_no_personal_info is not None:
            pulumi.set(__self__, "password_no_personal_info", password_no_personal_info)
        if password_policy is not None:
            pulumi.set(__self__, "password_policy", password_policy)
        if ping_federate_base_url is not None:
            pulumi.set(__self__, "ping_federate_base_url", ping_federate_base_url)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if precedences is not None:
            pulumi.set(__self__, "precedences", precedences)
        if protocol_binding is not None:
            pulumi.set(__self__, "protocol_binding", protocol_binding)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if request_template is not None:
            pulumi.set(__self__, "request_template", request_template)
        if requires_username is not None:
            pulumi.set(__self__, "requires_username", requires_username)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if scripts is not None:
            pulumi.set(__self__, "scripts", scripts)
        if set_user_root_attributes is not None:
            pulumi.set(__self__, "set_user_root_attributes", set_user_root_attributes)
        if should_trust_email_verified_connection is not None:
            pulumi.set(__self__, "should_trust_email_verified_connection", should_trust_email_verified_connection)
        if sign_in_endpoint is not None:
            pulumi.set(__self__, "sign_in_endpoint", sign_in_endpoint)
        if sign_out_endpoint is not None:
            pulumi.set(__self__, "sign_out_endpoint", sign_out_endpoint)
        if sign_saml_request is not None:
            pulumi.set(__self__, "sign_saml_request", sign_saml_request)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if signing_cert is not None:
            pulumi.set(__self__, "signing_cert", signing_cert)
        if signing_key is not None:
            pulumi.set(__self__, "signing_key", signing_key)
        if strategy_version is not None:
            pulumi.set(__self__, "strategy_version", strategy_version)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if syntax is not None:
            pulumi.set(__self__, "syntax", syntax)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tenant_domain is not None:
            pulumi.set(__self__, "tenant_domain", tenant_domain)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if totp is not None:
            pulumi.set(__self__, "totp", totp)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)
        if twilio_token is not None:
            pulumi.set(__self__, "twilio_token", twilio_token)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upstream_params is not None:
            pulumi.set(__self__, "upstream_params", upstream_params)
        if use_cert_auth is not None:
            pulumi.set(__self__, "use_cert_auth", use_cert_auth)
        if use_kerberos is not None:
            pulumi.set(__self__, "use_kerberos", use_kerberos)
        if use_wsfed is not None:
            pulumi.set(__self__, "use_wsfed", use_wsfed)
        if user_id_attribute is not None:
            pulumi.set(__self__, "user_id_attribute", user_id_attribute)
        if userinfo_endpoint is not None:
            pulumi.set(__self__, "userinfo_endpoint", userinfo_endpoint)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)
        if waad_common_endpoint is not None:
            pulumi.set(__self__, "waad_common_endpoint", waad_common_endpoint)
        if waad_protocol is not None:
            pulumi.set(__self__, "waad_protocol", waad_protocol)

    @property
    @pulumi.getter(name="adfsServer")
    def adfs_server(self) -> Optional[pulumi.Input[str]]:
        """
        ADFS URL where to fetch the metadata source.
        """
        return pulumi.get(self, "adfs_server")

    @adfs_server.setter
    def adfs_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adfs_server", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of allowed audiences.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="apiEnableUsers")
    def api_enable_users(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable API Access to users.
        """
        return pulumi.get(self, "api_enable_users")

    @api_enable_users.setter
    def api_enable_users(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "api_enable_users", value)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        App ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="attributeMap")
    def attribute_map(self) -> Optional[pulumi.Input['ConnectionOptionsAttributeMapArgs']]:
        """
        OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
        """
        return pulumi.get(self, "attribute_map")

    @attribute_map.setter
    def attribute_map(self, value: Optional[pulumi.Input['ConnectionOptionsAttributeMapArgs']]):
        pulumi.set(self, "attribute_map", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeArgs']]]]:
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="authParams")
    def auth_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Query string parameters to be included as part of the generated passwordless email link.
        """
        return pulumi.get(self, "auth_params")

    @auth_params.setter
    def auth_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "auth_params", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="bruteForceProtection")
    def brute_force_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
        """
        return pulumi.get(self, "brute_force_protection")

    @brute_force_protection.setter
    def brute_force_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "brute_force_protection", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy's client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy's client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="communityBaseUrl")
    def community_base_url(self) -> Optional[pulumi.Input[str]]:
        """
        Salesforce community base URL.
        """
        return pulumi.get(self, "community_base_url")

    @community_base_url.setter
    def community_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_base_url", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="connectionSettings")
    def connection_settings(self) -> Optional[pulumi.Input['ConnectionOptionsConnectionSettingsArgs']]:
        """
        Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
        """
        return pulumi.get(self, "connection_settings")

    @connection_settings.setter
    def connection_settings(self, value: Optional[pulumi.Input['ConnectionOptionsConnectionSettingsArgs']]):
        pulumi.set(self, "connection_settings", value)

    @property
    @pulumi.getter(name="customScripts")
    def custom_scripts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of scripts used to integrate with a custom database.
        """
        return pulumi.get(self, "custom_scripts")

    @custom_scripts.setter
    def custom_scripts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_scripts", value)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, additional debug information will be generated.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="decryptionKey")
    def decryption_key(self) -> Optional[pulumi.Input['ConnectionOptionsDecryptionKeyArgs']]:
        """
        The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "decryption_key")

    @decryption_key.setter
    def decryption_key(self, value: Optional[pulumi.Input['ConnectionOptionsDecryptionKeyArgs']]):
        pulumi.set(self, "decryption_key", value)

    @property
    @pulumi.getter(name="digestAlgorithm")
    def digest_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Sign Request Algorithm Digest.
        """
        return pulumi.get(self, "digest_algorithm")

    @digest_algorithm.setter
    def digest_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest_algorithm", value)

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to disable the cache or not.
        """
        return pulumi.get(self, "disable_cache")

    @disable_cache.setter
    def disable_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_cache", value)

    @property
    @pulumi.getter(name="disableSelfServiceChangePassword")
    def disable_self_service_change_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to remove the forgot password link within the New Universal Login.
        """
        return pulumi.get(self, "disable_self_service_change_password")

    @disable_self_service_change_password.setter
    def disable_self_service_change_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_self_service_change_password", value)

    @property
    @pulumi.getter(name="disableSignOut")
    def disable_sign_out(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, will disable sign out.
        """
        return pulumi.get(self, "disable_sign_out")

    @disable_sign_out.setter
    def disable_sign_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_sign_out", value)

    @property
    @pulumi.getter(name="disableSignup")
    def disable_signup(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to allow user sign-ups to your application.
        """
        return pulumi.get(self, "disable_signup")

    @disable_signup.setter
    def disable_signup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_signup", value)

    @property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> Optional[pulumi.Input[str]]:
        """
        OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discovery_url", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="domainAliases")
    def domain_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
        """
        return pulumi.get(self, "domain_aliases")

    @domain_aliases.setter
    def domain_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domain_aliases", value)

    @property
    @pulumi.getter(name="enableScriptContext")
    def enable_script_context(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
        """
        return pulumi.get(self, "enable_script_context")

    @enable_script_context.setter
    def enable_script_context(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_script_context", value)

    @property
    @pulumi.getter(name="enabledDatabaseCustomization")
    def enabled_database_customization(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to `true` to use a legacy user store.
        """
        return pulumi.get(self, "enabled_database_customization")

    @enabled_database_customization.setter
    def enabled_database_customization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled_database_customization", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Custom Entity ID for the connection.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="fedMetadataXml")
    def fed_metadata_xml(self) -> Optional[pulumi.Input[str]]:
        """
        Federation Metadata for the ADFS connection.
        """
        return pulumi.get(self, "fed_metadata_xml")

    @fed_metadata_xml.setter
    def fed_metadata_xml(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fed_metadata_xml", value)

    @property
    @pulumi.getter(name="fieldsMap")
    def fields_map(self) -> Optional[pulumi.Input[str]]:
        """
        If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
        """
        return pulumi.get(self, "fields_map")

    @fields_map.setter
    def fields_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fields_map", value)

    @property
    @pulumi.getter(name="forwardRequestInfo")
    def forward_request_info(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not request info should be forwarded to sms gateway.
        """
        return pulumi.get(self, "forward_request_info")

    @forward_request_info.setter
    def forward_request_info(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "forward_request_info", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        Address to use as the sender.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="gatewayAuthentication")
    def gateway_authentication(self) -> Optional[pulumi.Input['ConnectionOptionsGatewayAuthenticationArgs']]:
        """
        Defines the parameters used to generate the auth token for the custom gateway.
        """
        return pulumi.get(self, "gateway_authentication")

    @gateway_authentication.setter
    def gateway_authentication(self, value: Optional[pulumi.Input['ConnectionOptionsGatewayAuthenticationArgs']]):
        pulumi.set(self, "gateway_authentication", value)

    @property
    @pulumi.getter(name="gatewayUrl")
    def gateway_url(self) -> Optional[pulumi.Input[str]]:
        """
        Defines a custom sms gateway to use instead of Twilio.
        """
        return pulumi.get(self, "gateway_url")

    @gateway_url.setter
    def gateway_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_url", value)

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[str]]:
        """
        Icon URL.
        """
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_url", value)

    @property
    @pulumi.getter(name="identityApi")
    def identity_api(self) -> Optional[pulumi.Input[str]]:
        """
        Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
        """
        return pulumi.get(self, "identity_api")

    @identity_api.setter
    def identity_api(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_api", value)

    @property
    @pulumi.getter(name="idpInitiated")
    def idp_initiated(self) -> Optional[pulumi.Input['ConnectionOptionsIdpInitiatedArgs']]:
        """
        Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
        """
        return pulumi.get(self, "idp_initiated")

    @idp_initiated.setter
    def idp_initiated(self, value: Optional[pulumi.Input['ConnectionOptionsIdpInitiatedArgs']]):
        pulumi.set(self, "idp_initiated", value)

    @property
    @pulumi.getter(name="importMode")
    def import_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
        """
        return pulumi.get(self, "import_mode")

    @import_mode.setter
    def import_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "import_mode", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer URL, e.g. `https://auth.example.com`.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[pulumi.Input[str]]:
        """
        JWKS URI.
        """
        return pulumi.get(self, "jwks_uri")

    @jwks_uri.setter
    def jwks_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwks_uri", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Apple Key ID.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="mapUserIdToId")
    def map_user_id_to_id(self) -> Optional[pulumi.Input[bool]]:
        """
        By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to 'id' instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
        """
        return pulumi.get(self, "map_user_id_to_id")

    @map_user_id_to_id.setter
    def map_user_id_to_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "map_user_id_to_id", value)

    @property
    @pulumi.getter(name="maxGroupsToRetrieve")
    def max_groups_to_retrieve(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum number of groups to retrieve.
        """
        return pulumi.get(self, "max_groups_to_retrieve")

    @max_groups_to_retrieve.setter
    def max_groups_to_retrieve(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_groups_to_retrieve", value)

    @property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[pulumi.Input[str]]:
        """
        SID for Copilot. Used when SMS Source is Copilot.
        """
        return pulumi.get(self, "messaging_service_sid")

    @messaging_service_sid.setter
    def messaging_service_sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "messaging_service_sid", value)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the SAML metadata document.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_url", value)

    @property
    @pulumi.getter(name="metadataXml")
    def metadata_xml(self) -> Optional[pulumi.Input[str]]:
        """
        The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
        """
        return pulumi.get(self, "metadata_xml")

    @metadata_xml.setter
    def metadata_xml(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_xml", value)

    @property
    @pulumi.getter
    def mfa(self) -> Optional[pulumi.Input['ConnectionOptionsMfaArgs']]:
        """
        Configuration options for multifactor authentication.
        """
        return pulumi.get(self, "mfa")

    @mfa.setter
    def mfa(self, value: Optional[pulumi.Input['ConnectionOptionsMfaArgs']]):
        pulumi.set(self, "mfa", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nonPersistentAttrs")
    def non_persistent_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
        """
        return pulumi.get(self, "non_persistent_attrs")

    @non_persistent_attrs.setter
    def non_persistent_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_persistent_attrs", value)

    @property
    @pulumi.getter(name="passwordComplexityOptions")
    def password_complexity_options(self) -> Optional[pulumi.Input['ConnectionOptionsPasswordComplexityOptionsArgs']]:
        """
        Configuration settings for password complexity.
        """
        return pulumi.get(self, "password_complexity_options")

    @password_complexity_options.setter
    def password_complexity_options(self, value: Optional[pulumi.Input['ConnectionOptionsPasswordComplexityOptionsArgs']]):
        pulumi.set(self, "password_complexity_options", value)

    @property
    @pulumi.getter(name="passwordDictionary")
    def password_dictionary(self) -> Optional[pulumi.Input['ConnectionOptionsPasswordDictionaryArgs']]:
        """
        Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
        """
        return pulumi.get(self, "password_dictionary")

    @password_dictionary.setter
    def password_dictionary(self, value: Optional[pulumi.Input['ConnectionOptionsPasswordDictionaryArgs']]):
        pulumi.set(self, "password_dictionary", value)

    @property
    @pulumi.getter(name="passwordHistories")
    def password_histories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsPasswordHistoryArgs']]]]:
        """
        Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
        """
        return pulumi.get(self, "password_histories")

    @password_histories.setter
    def password_histories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsPasswordHistoryArgs']]]]):
        pulumi.set(self, "password_histories", value)

    @property
    @pulumi.getter(name="passwordNoPersonalInfo")
    def password_no_personal_info(self) -> Optional[pulumi.Input['ConnectionOptionsPasswordNoPersonalInfoArgs']]:
        """
        Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
        """
        return pulumi.get(self, "password_no_personal_info")

    @password_no_personal_info.setter
    def password_no_personal_info(self, value: Optional[pulumi.Input['ConnectionOptionsPasswordNoPersonalInfoArgs']]):
        pulumi.set(self, "password_no_personal_info", value)

    @property
    @pulumi.getter(name="passwordPolicy")
    def password_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
        """
        return pulumi.get(self, "password_policy")

    @password_policy.setter
    def password_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_policy", value)

    @property
    @pulumi.getter(name="pingFederateBaseUrl")
    def ping_federate_base_url(self) -> Optional[pulumi.Input[str]]:
        """
        Ping Federate Server URL.
        """
        return pulumi.get(self, "ping_federate_base_url")

    @ping_federate_base_url.setter
    def ping_federate_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_federate_base_url", value)

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
        """
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @property
    @pulumi.getter
    def precedences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Order of attributes for precedence in identification.Valid values: email, phone*number, username. If Precedence is set, it must contain all values (email, phone*number, username) in specific order
        """
        return pulumi.get(self, "precedences")

    @precedences.setter
    def precedences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "precedences", value)

    @property
    @pulumi.getter(name="protocolBinding")
    def protocol_binding(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
        """
        return pulumi.get(self, "protocol_binding")

    @protocol_binding.setter
    def protocol_binding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_binding", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the custom `sms_gateway` provider.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="requestTemplate")
    def request_template(self) -> Optional[pulumi.Input[str]]:
        """
        Template that formats the SAML request.
        """
        return pulumi.get(self, "request_template")

    @request_template.setter
    def request_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_template", value)

    @property
    @pulumi.getter(name="requiresUsername")
    def requires_username(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the user is required to provide a username in addition to an email address.
        """
        return pulumi.get(self, "requires_username")

    @requires_username.setter
    def requires_username(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "requires_username", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def scripts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
        """
        return pulumi.get(self, "scripts")

    @scripts.setter
    def scripts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "scripts", value)

    @property
    @pulumi.getter(name="setUserRootAttributes")
    def set_user_root_attributes(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`. Default value: `on_each_login`.
        """
        return pulumi.get(self, "set_user_root_attributes")

    @set_user_root_attributes.setter
    def set_user_root_attributes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_user_root_attributes", value)

    @property
    @pulumi.getter(name="shouldTrustEmailVerifiedConnection")
    def should_trust_email_verified_connection(self) -> Optional[pulumi.Input[str]]:
        """
        Choose how Auth0 sets the email_verified field in the user profile.
        """
        return pulumi.get(self, "should_trust_email_verified_connection")

    @should_trust_email_verified_connection.setter
    def should_trust_email_verified_connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "should_trust_email_verified_connection", value)

    @property
    @pulumi.getter(name="signInEndpoint")
    def sign_in_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        SAML single login URL for the connection.
        """
        return pulumi.get(self, "sign_in_endpoint")

    @sign_in_endpoint.setter
    def sign_in_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sign_in_endpoint", value)

    @property
    @pulumi.getter(name="signOutEndpoint")
    def sign_out_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        SAML single logout URL for the connection.
        """
        return pulumi.get(self, "sign_out_endpoint")

    @sign_out_endpoint.setter
    def sign_out_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sign_out_endpoint", value)

    @property
    @pulumi.getter(name="signSamlRequest")
    def sign_saml_request(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the SAML authentication request will be signed.
        """
        return pulumi.get(self, "sign_saml_request")

    @sign_saml_request.setter
    def sign_saml_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_saml_request", value)

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Sign Request Algorithm.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signature_algorithm", value)

    @property
    @pulumi.getter(name="signingCert")
    def signing_cert(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
        """
        return pulumi.get(self, "signing_cert")

    @signing_cert.setter
    def signing_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_cert", value)

    @property
    @pulumi.getter(name="signingKey")
    def signing_key(self) -> Optional[pulumi.Input['ConnectionOptionsSigningKeyArgs']]:
        """
        The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
        """
        return pulumi.get(self, "signing_key")

    @signing_key.setter
    def signing_key(self, value: Optional[pulumi.Input['ConnectionOptionsSigningKeyArgs']]):
        pulumi.set(self, "signing_key", value)

    @property
    @pulumi.getter(name="strategyVersion")
    def strategy_version(self) -> Optional[pulumi.Input[int]]:
        """
        Version 1 is deprecated, use version 2.
        """
        return pulumi.get(self, "strategy_version")

    @strategy_version.setter
    def strategy_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "strategy_version", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject line of the email.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def syntax(self) -> Optional[pulumi.Input[str]]:
        """
        Syntax of the template body.
        """
        return pulumi.get(self, "syntax")

    @syntax.setter
    def syntax(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syntax", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        Apple Team ID.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        Body of the template.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="tenantDomain")
    def tenant_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant domain name.
        """
        return pulumi.get(self, "tenant_domain")

    @tenant_domain.setter
    def tenant_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_domain", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter
    def totp(self) -> Optional[pulumi.Input['ConnectionOptionsTotpArgs']]:
        """
        Configuration options for one-time passwords.
        """
        return pulumi.get(self, "totp")

    @totp.setter
    def totp(self, value: Optional[pulumi.Input['ConnectionOptionsTotpArgs']]):
        pulumi.set(self, "totp", value)

    @property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[pulumi.Input[str]]:
        """
        SID for your Twilio account.
        """
        return pulumi.get(self, "twilio_sid")

    @twilio_sid.setter
    def twilio_sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "twilio_sid", value)

    @property
    @pulumi.getter(name="twilioToken")
    def twilio_token(self) -> Optional[pulumi.Input[str]]:
        """
        AuthToken for your Twilio account.
        """
        return pulumi.get(self, "twilio_token")

    @twilio_token.setter
    def twilio_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "twilio_token", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="upstreamParams")
    def upstream_params(self) -> Optional[pulumi.Input[str]]:
        """
        You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
        """
        return pulumi.get(self, "upstream_params")

    @upstream_params.setter
    def upstream_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upstream_params", value)

    @property
    @pulumi.getter(name="useCertAuth")
    def use_cert_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use cert auth or not.
        """
        return pulumi.get(self, "use_cert_auth")

    @use_cert_auth.setter
    def use_cert_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_cert_auth", value)

    @property
    @pulumi.getter(name="useKerberos")
    def use_kerberos(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use Kerberos or not.
        """
        return pulumi.get(self, "use_kerberos")

    @use_kerberos.setter
    def use_kerberos(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_kerberos", value)

    @property
    @pulumi.getter(name="useWsfed")
    def use_wsfed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use WS-Fed.
        """
        return pulumi.get(self, "use_wsfed")

    @use_wsfed.setter
    def use_wsfed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_wsfed", value)

    @property
    @pulumi.getter(name="userIdAttribute")
    def user_id_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Attribute in the token that will be mapped to the user_id property in Auth0.
        """
        return pulumi.get(self, "user_id_attribute")

    @user_id_attribute.setter
    def user_id_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id_attribute", value)

    @property
    @pulumi.getter(name="userinfoEndpoint")
    def userinfo_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        User info endpoint.
        """
        return pulumi.get(self, "userinfo_endpoint")

    @userinfo_endpoint.setter
    def userinfo_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userinfo_endpoint", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['ConnectionOptionsValidationArgs']]:
        """
        Validation of the minimum and maximum values allowed for a user to have as username.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['ConnectionOptionsValidationArgs']]):
        pulumi.set(self, "validation", value)

    @property
    @pulumi.getter(name="waadCommonEndpoint")
    def waad_common_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
        """
        return pulumi.get(self, "waad_common_endpoint")

    @waad_common_endpoint.setter
    def waad_common_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "waad_common_endpoint", value)

    @property
    @pulumi.getter(name="waadProtocol")
    def waad_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to use.
        """
        return pulumi.get(self, "waad_protocol")

    @waad_protocol.setter
    def waad_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waad_protocol", value)


if not MYPY:
    class ConnectionOptionsAttributeArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailArgsDict']]]]
        """
        Connection Options for Email Attribute
        """
        phone_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberArgsDict']]]]
        """
        Connection Options for Phone Number Attribute
        """
        usernames: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameArgsDict']]]]
        """
        Connection Options for User Name Attribute
        """
elif False:
    ConnectionOptionsAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailArgs']]]] = None,
                 phone_numbers: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberArgs']]]] = None,
                 usernames: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailArgs']]] emails: Connection Options for Email Attribute
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberArgs']]] phone_numbers: Connection Options for Phone Number Attribute
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameArgs']]] usernames: Connection Options for User Name Attribute
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if phone_numbers is not None:
            pulumi.set(__self__, "phone_numbers", phone_numbers)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailArgs']]]]:
        """
        Connection Options for Email Attribute
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailArgs']]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberArgs']]]]:
        """
        Connection Options for Phone Number Attribute
        """
        return pulumi.get(self, "phone_numbers")

    @phone_numbers.setter
    def phone_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberArgs']]]]):
        pulumi.set(self, "phone_numbers", value)

    @property
    @pulumi.getter
    def usernames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameArgs']]]]:
        """
        Connection Options for User Name Attribute
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameArgs']]]]):
        pulumi.set(self, "usernames", value)


if not MYPY:
    class ConnectionOptionsAttributeEmailArgsDict(TypedDict):
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailIdentifierArgsDict']]]]
        """
        Connection Options Email Attribute Identifier
        """
        profile_required: NotRequired[pulumi.Input[bool]]
        """
        Defines whether Profile is required
        """
        signups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupArgsDict']]]]
        """
        Defines signup settings for Email attribute
        """
elif False:
    ConnectionOptionsAttributeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeEmailArgs:
    def __init__(__self__, *,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailIdentifierArgs']]]] = None,
                 profile_required: Optional[pulumi.Input[bool]] = None,
                 signups: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailIdentifierArgs']]] identifiers: Connection Options Email Attribute Identifier
        :param pulumi.Input[bool] profile_required: Defines whether Profile is required
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupArgs']]] signups: Defines signup settings for Email attribute
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailIdentifierArgs']]]]:
        """
        Connection Options Email Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailIdentifierArgs']]]]):
        pulumi.set(self, "identifiers", value)

    @property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @profile_required.setter
    def profile_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "profile_required", value)

    @property
    @pulumi.getter
    def signups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupArgs']]]]:
        """
        Defines signup settings for Email attribute
        """
        return pulumi.get(self, "signups")

    @signups.setter
    def signups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupArgs']]]]):
        pulumi.set(self, "signups", value)


if not MYPY:
    class ConnectionOptionsAttributeEmailIdentifierArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines whether email attribute is active as an identifier
        """
elif False:
    ConnectionOptionsAttributeEmailIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeEmailIdentifierArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Defines whether email attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether email attribute is active as an identifier
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class ConnectionOptionsAttributeEmailSignupArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        Defines signup status for Email Attribute
        """
        verifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupVerificationArgsDict']]]]
        """
        Defines settings for Verification under Email attribute
        """
elif False:
    ConnectionOptionsAttributeEmailSignupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeEmailSignupArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None,
                 verifications: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupVerificationArgs']]]] = None):
        """
        :param pulumi.Input[str] status: Defines signup status for Email Attribute
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupVerificationArgs']]] verifications: Defines settings for Verification under Email attribute
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if verifications is not None:
            pulumi.set(__self__, "verifications", verifications)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Defines signup status for Email Attribute
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def verifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupVerificationArgs']]]]:
        """
        Defines settings for Verification under Email attribute
        """
        return pulumi.get(self, "verifications")

    @verifications.setter
    def verifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeEmailSignupVerificationArgs']]]]):
        pulumi.set(self, "verifications", value)


if not MYPY:
    class ConnectionOptionsAttributeEmailSignupVerificationArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines verification settings for signup attribute
        """
elif False:
    ConnectionOptionsAttributeEmailSignupVerificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeEmailSignupVerificationArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Defines verification settings for signup attribute
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines verification settings for signup attribute
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class ConnectionOptionsAttributeMapArgsDict(TypedDict):
        mapping_mode: pulumi.Input[str]
        """
        Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        """
        attributes: NotRequired[pulumi.Input[str]]
        """
        This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        """
        userinfo_scope: NotRequired[pulumi.Input[str]]
        """
        This property defines the scopes that Auth0 sends to the IdPs UserInfo endpoint when requested.
        """
elif False:
    ConnectionOptionsAttributeMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeMapArgs:
    def __init__(__self__, *,
                 mapping_mode: pulumi.Input[str],
                 attributes: Optional[pulumi.Input[str]] = None,
                 userinfo_scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mapping_mode: Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        :param pulumi.Input[str] attributes: This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        :param pulumi.Input[str] userinfo_scope: This property defines the scopes that Auth0 sends to the IdPs UserInfo endpoint when requested.
        """
        pulumi.set(__self__, "mapping_mode", mapping_mode)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if userinfo_scope is not None:
            pulumi.set(__self__, "userinfo_scope", userinfo_scope)

    @property
    @pulumi.getter(name="mappingMode")
    def mapping_mode(self) -> pulumi.Input[str]:
        """
        Method used to map incoming claims. Possible values: `use_map` (Okta or OIDC), `bind_all` (OIDC) or `basic_profile` (Okta).
        """
        return pulumi.get(self, "mapping_mode")

    @mapping_mode.setter
    def mapping_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mapping_mode", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[str]]:
        """
        This property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="userinfoScope")
    def userinfo_scope(self) -> Optional[pulumi.Input[str]]:
        """
        This property defines the scopes that Auth0 sends to the IdPs UserInfo endpoint when requested.
        """
        return pulumi.get(self, "userinfo_scope")

    @userinfo_scope.setter
    def userinfo_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userinfo_scope", value)


if not MYPY:
    class ConnectionOptionsAttributePhoneNumberArgsDict(TypedDict):
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberIdentifierArgsDict']]]]
        """
        Connection Options Phone Number Attribute Identifier
        """
        profile_required: NotRequired[pulumi.Input[bool]]
        """
        Defines whether Profile is required
        """
        signups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupArgsDict']]]]
        """
        Defines signup settings for Phone Number attribute
        """
elif False:
    ConnectionOptionsAttributePhoneNumberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributePhoneNumberArgs:
    def __init__(__self__, *,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberIdentifierArgs']]]] = None,
                 profile_required: Optional[pulumi.Input[bool]] = None,
                 signups: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberIdentifierArgs']]] identifiers: Connection Options Phone Number Attribute Identifier
        :param pulumi.Input[bool] profile_required: Defines whether Profile is required
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupArgs']]] signups: Defines signup settings for Phone Number attribute
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberIdentifierArgs']]]]:
        """
        Connection Options Phone Number Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberIdentifierArgs']]]]):
        pulumi.set(self, "identifiers", value)

    @property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @profile_required.setter
    def profile_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "profile_required", value)

    @property
    @pulumi.getter
    def signups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupArgs']]]]:
        """
        Defines signup settings for Phone Number attribute
        """
        return pulumi.get(self, "signups")

    @signups.setter
    def signups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupArgs']]]]):
        pulumi.set(self, "signups", value)


if not MYPY:
    class ConnectionOptionsAttributePhoneNumberIdentifierArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines whether Phone Number attribute is active as an identifier
        """
elif False:
    ConnectionOptionsAttributePhoneNumberIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributePhoneNumberIdentifierArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Defines whether Phone Number attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether Phone Number attribute is active as an identifier
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class ConnectionOptionsAttributePhoneNumberSignupArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        Defines status of signup for Phone Number attribute
        """
        verifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupVerificationArgsDict']]]]
        """
        Defines verification settings for Phone Number attribute
        """
elif False:
    ConnectionOptionsAttributePhoneNumberSignupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributePhoneNumberSignupArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None,
                 verifications: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupVerificationArgs']]]] = None):
        """
        :param pulumi.Input[str] status: Defines status of signup for Phone Number attribute
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupVerificationArgs']]] verifications: Defines verification settings for Phone Number attribute
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if verifications is not None:
            pulumi.set(__self__, "verifications", verifications)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Defines status of signup for Phone Number attribute
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def verifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupVerificationArgs']]]]:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "verifications")

    @verifications.setter
    def verifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributePhoneNumberSignupVerificationArgs']]]]):
        pulumi.set(self, "verifications", value)


if not MYPY:
    class ConnectionOptionsAttributePhoneNumberSignupVerificationArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines verification settings for Phone Number attribute
        """
elif False:
    ConnectionOptionsAttributePhoneNumberSignupVerificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributePhoneNumberSignupVerificationArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Defines verification settings for Phone Number attribute
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines verification settings for Phone Number attribute
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class ConnectionOptionsAttributeUsernameArgsDict(TypedDict):
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameIdentifierArgsDict']]]]
        """
        Connection options for User Name Attribute Identifier
        """
        profile_required: NotRequired[pulumi.Input[bool]]
        """
        Defines whether Profile is required
        """
        signups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameSignupArgsDict']]]]
        """
        Defines signup settings for User Name attribute
        """
        validations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationArgsDict']]]]
        """
        Defines validation settings for User Name attribute
        """
elif False:
    ConnectionOptionsAttributeUsernameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeUsernameArgs:
    def __init__(__self__, *,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameIdentifierArgs']]]] = None,
                 profile_required: Optional[pulumi.Input[bool]] = None,
                 signups: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameSignupArgs']]]] = None,
                 validations: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameIdentifierArgs']]] identifiers: Connection options for User Name Attribute Identifier
        :param pulumi.Input[bool] profile_required: Defines whether Profile is required
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameSignupArgs']]] signups: Defines signup settings for User Name attribute
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationArgs']]] validations: Defines validation settings for User Name attribute
        """
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if profile_required is not None:
            pulumi.set(__self__, "profile_required", profile_required)
        if signups is not None:
            pulumi.set(__self__, "signups", signups)
        if validations is not None:
            pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameIdentifierArgs']]]]:
        """
        Connection options for User Name Attribute Identifier
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameIdentifierArgs']]]]):
        pulumi.set(self, "identifiers", value)

    @property
    @pulumi.getter(name="profileRequired")
    def profile_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether Profile is required
        """
        return pulumi.get(self, "profile_required")

    @profile_required.setter
    def profile_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "profile_required", value)

    @property
    @pulumi.getter
    def signups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameSignupArgs']]]]:
        """
        Defines signup settings for User Name attribute
        """
        return pulumi.get(self, "signups")

    @signups.setter
    def signups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameSignupArgs']]]]):
        pulumi.set(self, "signups", value)

    @property
    @pulumi.getter
    def validations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationArgs']]]]:
        """
        Defines validation settings for User Name attribute
        """
        return pulumi.get(self, "validations")

    @validations.setter
    def validations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationArgs']]]]):
        pulumi.set(self, "validations", value)


if not MYPY:
    class ConnectionOptionsAttributeUsernameIdentifierArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines whether UserName attribute is active as an identifier
        """
elif False:
    ConnectionOptionsAttributeUsernameIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeUsernameIdentifierArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Defines whether UserName attribute is active as an identifier
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether UserName attribute is active as an identifier
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class ConnectionOptionsAttributeUsernameSignupArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        Defines whether User Name attribute is active as an identifier
        """
elif False:
    ConnectionOptionsAttributeUsernameSignupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeUsernameSignupArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: Defines whether User Name attribute is active as an identifier
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Defines whether User Name attribute is active as an identifier
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ConnectionOptionsAttributeUsernameValidationArgsDict(TypedDict):
        allowed_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgsDict']]]]
        """
        Defines allowed types for for UserName attribute
        """
        max_length: NotRequired[pulumi.Input[int]]
        """
        Defines Max Length for User Name attribute
        """
        min_length: NotRequired[pulumi.Input[int]]
        """
        Defines Min Length for User Name attribute
        """
elif False:
    ConnectionOptionsAttributeUsernameValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeUsernameValidationArgs:
    def __init__(__self__, *,
                 allowed_types: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs']]]] = None,
                 max_length: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs']]] allowed_types: Defines allowed types for for UserName attribute
        :param pulumi.Input[int] max_length: Defines Max Length for User Name attribute
        :param pulumi.Input[int] min_length: Defines Min Length for User Name attribute
        """
        if allowed_types is not None:
            pulumi.set(__self__, "allowed_types", allowed_types)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @property
    @pulumi.getter(name="allowedTypes")
    def allowed_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs']]]]:
        """
        Defines allowed types for for UserName attribute
        """
        return pulumi.get(self, "allowed_types")

    @allowed_types.setter
    def allowed_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs']]]]):
        pulumi.set(self, "allowed_types", value)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[int]]:
        """
        Defines Max Length for User Name attribute
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        Defines Min Length for User Name attribute
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)


if not MYPY:
    class ConnectionOptionsAttributeUsernameValidationAllowedTypeArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[bool]]
        """
        One of the allowed types for UserName signup attribute
        """
        phone_number: NotRequired[pulumi.Input[bool]]
        """
        One of the allowed types for UserName signup attribute
        """
elif False:
    ConnectionOptionsAttributeUsernameValidationAllowedTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsAttributeUsernameValidationAllowedTypeArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] email: One of the allowed types for UserName signup attribute
        :param pulumi.Input[bool] phone_number: One of the allowed types for UserName signup attribute
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[bool]]:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[bool]]:
        """
        One of the allowed types for UserName signup attribute
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ConnectionOptionsConnectionSettingsArgsDict(TypedDict):
        pkce: pulumi.Input[str]
        """
        PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
elif False:
    ConnectionOptionsConnectionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsConnectionSettingsArgs:
    def __init__(__self__, *,
                 pkce: pulumi.Input[str]):
        """
        :param pulumi.Input[str] pkce: PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        pulumi.set(__self__, "pkce", pkce)

    @property
    @pulumi.getter
    def pkce(self) -> pulumi.Input[str]:
        """
        PKCE configuration. Possible values: `auto` (uses the strongest algorithm available), `S256` (uses the SHA-256 algorithm), `plain` (uses plaintext as described in the PKCE specification) or `disabled` (disables support for PKCE).
        """
        return pulumi.get(self, "pkce")

    @pkce.setter
    def pkce(self, value: pulumi.Input[str]):
        pulumi.set(self, "pkce", value)


if not MYPY:
    class ConnectionOptionsDecryptionKeyArgsDict(TypedDict):
        cert: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    ConnectionOptionsDecryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsDecryptionKeyArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[str]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ConnectionOptionsGatewayAuthenticationArgsDict(TypedDict):
        audience: NotRequired[pulumi.Input[str]]
        """
        Audience claim for the HS256 token sent to `gateway_url`.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Authentication method (default is `bearer` token).
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Secret used to sign the HS256 token sent to `gateway_url`.
        """
        secret_base64_encoded: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not the secret is Base64-encoded.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Subject claim for the HS256 token sent to `gateway_url`.
        """
elif False:
    ConnectionOptionsGatewayAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsGatewayAuthenticationArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 secret_base64_encoded: Optional[pulumi.Input[bool]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audience: Audience claim for the HS256 token sent to `gateway_url`.
        :param pulumi.Input[str] method: Authentication method (default is `bearer` token).
        :param pulumi.Input[str] secret: Secret used to sign the HS256 token sent to `gateway_url`.
        :param pulumi.Input[bool] secret_base64_encoded: Specifies whether or not the secret is Base64-encoded.
        :param pulumi.Input[str] subject: Subject claim for the HS256 token sent to `gateway_url`.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_base64_encoded is not None:
            pulumi.set(__self__, "secret_base64_encoded", secret_base64_encoded)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Audience claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication method (default is `bearer` token).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret used to sign the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="secretBase64Encoded")
    def secret_base64_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not the secret is Base64-encoded.
        """
        return pulumi.get(self, "secret_base64_encoded")

    @secret_base64_encoded.setter
    def secret_base64_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret_base64_encoded", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject claim for the HS256 token sent to `gateway_url`.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class ConnectionOptionsIdpInitiatedArgsDict(TypedDict):
        client_authorize_query: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_protocol: NotRequired[pulumi.Input[str]]
elif False:
    ConnectionOptionsIdpInitiatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsIdpInitiatedArgs:
    def __init__(__self__, *,
                 client_authorize_query: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_protocol: Optional[pulumi.Input[str]] = None):
        if client_authorize_query is not None:
            pulumi.set(__self__, "client_authorize_query", client_authorize_query)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_protocol is not None:
            pulumi.set(__self__, "client_protocol", client_protocol)

    @property
    @pulumi.getter(name="clientAuthorizeQuery")
    def client_authorize_query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_authorize_query")

    @client_authorize_query.setter
    def client_authorize_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_authorize_query", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_protocol")

    @client_protocol.setter
    def client_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_protocol", value)


if not MYPY:
    class ConnectionOptionsMfaArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether multifactor authentication is enabled for this connection.
        """
        return_enroll_settings: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether multifactor authentication enrollment settings will be returned.
        """
elif False:
    ConnectionOptionsMfaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsMfaArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None,
                 return_enroll_settings: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Indicates whether multifactor authentication is enabled for this connection.
        :param pulumi.Input[bool] return_enroll_settings: Indicates whether multifactor authentication enrollment settings will be returned.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if return_enroll_settings is not None:
            pulumi.set(__self__, "return_enroll_settings", return_enroll_settings)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether multifactor authentication is enabled for this connection.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="returnEnrollSettings")
    def return_enroll_settings(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether multifactor authentication enrollment settings will be returned.
        """
        return pulumi.get(self, "return_enroll_settings")

    @return_enroll_settings.setter
    def return_enroll_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_enroll_settings", value)


if not MYPY:
    class ConnectionOptionsPasswordComplexityOptionsArgsDict(TypedDict):
        min_length: NotRequired[pulumi.Input[int]]
        """
        Minimum number of characters allowed in passwords.
        """
elif False:
    ConnectionOptionsPasswordComplexityOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsPasswordComplexityOptionsArgs:
    def __init__(__self__, *,
                 min_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] min_length: Minimum number of characters allowed in passwords.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of characters allowed in passwords.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)


if not MYPY:
    class ConnectionOptionsPasswordDictionaryArgsDict(TypedDict):
        dictionaries: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        """
        enable: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the password dictionary check is enabled for this connection.
        """
elif False:
    ConnectionOptionsPasswordDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsPasswordDictionaryArgs:
    def __init__(__self__, *,
                 dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dictionaries: Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        :param pulumi.Input[bool] enable: Indicates whether the password dictionary check is enabled for this connection.
        """
        if dictionaries is not None:
            pulumi.set(__self__, "dictionaries", dictionaries)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def dictionaries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Customized contents of the password dictionary. By default, the password dictionary contains a list of the [10,000 most common passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt); your customized content is used in addition to the default password dictionary. Matching is not case-sensitive.
        """
        return pulumi.get(self, "dictionaries")

    @dictionaries.setter
    def dictionaries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dictionaries", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the password dictionary check is enabled for this connection.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class ConnectionOptionsPasswordHistoryArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        size: NotRequired[pulumi.Input[int]]
elif False:
    ConnectionOptionsPasswordHistoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsPasswordHistoryArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[int]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class ConnectionOptionsPasswordNoPersonalInfoArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
elif False:
    ConnectionOptionsPasswordNoPersonalInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsPasswordNoPersonalInfoArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class ConnectionOptionsSigningKeyArgsDict(TypedDict):
        cert: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    ConnectionOptionsSigningKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsSigningKeyArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[str]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ConnectionOptionsTotpArgsDict(TypedDict):
        length: NotRequired[pulumi.Input[int]]
        """
        Length of the one-time password.
        """
        time_step: NotRequired[pulumi.Input[int]]
        """
        Seconds between allowed generation of new passwords.
        """
elif False:
    ConnectionOptionsTotpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsTotpArgs:
    def __init__(__self__, *,
                 length: Optional[pulumi.Input[int]] = None,
                 time_step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] length: Length of the one-time password.
        :param pulumi.Input[int] time_step: Seconds between allowed generation of new passwords.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if time_step is not None:
            pulumi.set(__self__, "time_step", time_step)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        Length of the one-time password.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter(name="timeStep")
    def time_step(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds between allowed generation of new passwords.
        """
        return pulumi.get(self, "time_step")

    @time_step.setter
    def time_step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_step", value)


if not MYPY:
    class ConnectionOptionsValidationArgsDict(TypedDict):
        username: NotRequired[pulumi.Input['ConnectionOptionsValidationUsernameArgsDict']]
        """
        Specifies the `min` and `max` values of username length.
        """
elif False:
    ConnectionOptionsValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsValidationArgs:
    def __init__(__self__, *,
                 username: Optional[pulumi.Input['ConnectionOptionsValidationUsernameArgs']] = None):
        """
        :param pulumi.Input['ConnectionOptionsValidationUsernameArgs'] username: Specifies the `min` and `max` values of username length.
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input['ConnectionOptionsValidationUsernameArgs']]:
        """
        Specifies the `min` and `max` values of username length.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input['ConnectionOptionsValidationUsernameArgs']]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ConnectionOptionsValidationUsernameArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[int]]
        min: NotRequired[pulumi.Input[int]]
elif False:
    ConnectionOptionsValidationUsernameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionOptionsValidationUsernameArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class ConnectionScimConfigurationMappingArgsDict(TypedDict):
        auth0: pulumi.Input[str]
        """
        The field location in the Auth0 schema.
        """
        scim: pulumi.Input[str]
        """
        The field location in the SCIM schema.
        """
elif False:
    ConnectionScimConfigurationMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionScimConfigurationMappingArgs:
    def __init__(__self__, *,
                 auth0: pulumi.Input[str],
                 scim: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth0: The field location in the Auth0 schema.
        :param pulumi.Input[str] scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @property
    @pulumi.getter
    def auth0(self) -> pulumi.Input[str]:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @auth0.setter
    def auth0(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth0", value)

    @property
    @pulumi.getter
    def scim(self) -> pulumi.Input[str]:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")

    @scim.setter
    def scim(self, value: pulumi.Input[str]):
        pulumi.set(self, "scim", value)


if not MYPY:
    class CustomDomainVerificationArgsDict(TypedDict):
        methods: NotRequired[pulumi.Input[Sequence[Any]]]
        """
        Verification methods for the domain.
        """
elif False:
    CustomDomainVerificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainVerificationArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[Any]]] = None):
        """
        :param pulumi.Input[Sequence[Any]] methods: Verification methods for the domain.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Verification methods for the domain.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "methods", value)


if not MYPY:
    class EmailProviderCredentialsArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        AWS Access Key ID. Used only for AWS.
        """
        api_key: NotRequired[pulumi.Input[str]]
        """
        API Key for your email service. Will always be encrypted in our database.
        """
        azure_cs_connection_string: NotRequired[pulumi.Input[str]]
        """
        Azure Communication Services Connection String.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Domain name.
        """
        ms365_client_id: NotRequired[pulumi.Input[str]]
        """
        Microsoft 365 Client ID.
        """
        ms365_client_secret: NotRequired[pulumi.Input[str]]
        """
        Microsoft 365 Client Secret.
        """
        ms365_tenant_id: NotRequired[pulumi.Input[str]]
        """
        Microsoft 365 Tenant ID.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Default region. Used only for AWS, Mailgun, and SparkPost.
        """
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
        """
        smtp_host: NotRequired[pulumi.Input[str]]
        """
        Hostname or IP address of your SMTP server. Used only for SMTP.
        """
        smtp_pass: NotRequired[pulumi.Input[str]]
        """
        SMTP password. Used only for SMTP.
        """
        smtp_port: NotRequired[pulumi.Input[int]]
        """
        Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
        """
        smtp_user: NotRequired[pulumi.Input[str]]
        """
        SMTP username. Used only for SMTP.
        """
elif False:
    EmailProviderCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailProviderCredentialsArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 api_key: Optional[pulumi.Input[str]] = None,
                 azure_cs_connection_string: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 ms365_client_id: Optional[pulumi.Input[str]] = None,
                 ms365_client_secret: Optional[pulumi.Input[str]] = None,
                 ms365_tenant_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None,
                 smtp_host: Optional[pulumi.Input[str]] = None,
                 smtp_pass: Optional[pulumi.Input[str]] = None,
                 smtp_port: Optional[pulumi.Input[int]] = None,
                 smtp_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: AWS Access Key ID. Used only for AWS.
        :param pulumi.Input[str] api_key: API Key for your email service. Will always be encrypted in our database.
        :param pulumi.Input[str] azure_cs_connection_string: Azure Communication Services Connection String.
        :param pulumi.Input[str] domain: Domain name.
        :param pulumi.Input[str] ms365_client_id: Microsoft 365 Client ID.
        :param pulumi.Input[str] ms365_client_secret: Microsoft 365 Client Secret.
        :param pulumi.Input[str] ms365_tenant_id: Microsoft 365 Tenant ID.
        :param pulumi.Input[str] region: Default region. Used only for AWS, Mailgun, and SparkPost.
        :param pulumi.Input[str] secret_access_key: AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
        :param pulumi.Input[str] smtp_host: Hostname or IP address of your SMTP server. Used only for SMTP.
        :param pulumi.Input[str] smtp_pass: SMTP password. Used only for SMTP.
        :param pulumi.Input[int] smtp_port: Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
        :param pulumi.Input[str] smtp_user: SMTP username. Used only for SMTP.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if azure_cs_connection_string is not None:
            pulumi.set(__self__, "azure_cs_connection_string", azure_cs_connection_string)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if ms365_client_id is not None:
            pulumi.set(__self__, "ms365_client_id", ms365_client_id)
        if ms365_client_secret is not None:
            pulumi.set(__self__, "ms365_client_secret", ms365_client_secret)
        if ms365_tenant_id is not None:
            pulumi.set(__self__, "ms365_tenant_id", ms365_tenant_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if smtp_host is not None:
            pulumi.set(__self__, "smtp_host", smtp_host)
        if smtp_pass is not None:
            pulumi.set(__self__, "smtp_pass", smtp_pass)
        if smtp_port is not None:
            pulumi.set(__self__, "smtp_port", smtp_port)
        if smtp_user is not None:
            pulumi.set(__self__, "smtp_user", smtp_user)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Access Key ID. Used only for AWS.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        API Key for your email service. Will always be encrypted in our database.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="azureCsConnectionString")
    def azure_cs_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Communication Services Connection String.
        """
        return pulumi.get(self, "azure_cs_connection_string")

    @azure_cs_connection_string.setter
    def azure_cs_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_cs_connection_string", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="ms365ClientId")
    def ms365_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Microsoft 365 Client ID.
        """
        return pulumi.get(self, "ms365_client_id")

    @ms365_client_id.setter
    def ms365_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ms365_client_id", value)

    @property
    @pulumi.getter(name="ms365ClientSecret")
    def ms365_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Microsoft 365 Client Secret.
        """
        return pulumi.get(self, "ms365_client_secret")

    @ms365_client_secret.setter
    def ms365_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ms365_client_secret", value)

    @property
    @pulumi.getter(name="ms365TenantId")
    def ms365_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Microsoft 365 Tenant ID.
        """
        return pulumi.get(self, "ms365_tenant_id")

    @ms365_tenant_id.setter
    def ms365_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ms365_tenant_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Default region. Used only for AWS, Mailgun, and SparkPost.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="smtpHost")
    def smtp_host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname or IP address of your SMTP server. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_host")

    @smtp_host.setter
    def smtp_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "smtp_host", value)

    @property
    @pulumi.getter(name="smtpPass")
    def smtp_pass(self) -> Optional[pulumi.Input[str]]:
        """
        SMTP password. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_pass")

    @smtp_pass.setter
    def smtp_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "smtp_pass", value)

    @property
    @pulumi.getter(name="smtpPort")
    def smtp_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_port")

    @smtp_port.setter
    def smtp_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "smtp_port", value)

    @property
    @pulumi.getter(name="smtpUser")
    def smtp_user(self) -> Optional[pulumi.Input[str]]:
        """
        SMTP username. Used only for SMTP.
        """
        return pulumi.get(self, "smtp_user")

    @smtp_user.setter
    def smtp_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "smtp_user", value)


if not MYPY:
    class EmailProviderSettingsArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input['EmailProviderSettingsHeadersArgsDict']]
        """
        Headers settings for the `smtp` email provider.
        """
        message: NotRequired[pulumi.Input['EmailProviderSettingsMessageArgsDict']]
        """
        Message settings for the `mandrill` or `ses` email provider.
        """
elif False:
    EmailProviderSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailProviderSettingsArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input['EmailProviderSettingsHeadersArgs']] = None,
                 message: Optional[pulumi.Input['EmailProviderSettingsMessageArgs']] = None):
        """
        :param pulumi.Input['EmailProviderSettingsHeadersArgs'] headers: Headers settings for the `smtp` email provider.
        :param pulumi.Input['EmailProviderSettingsMessageArgs'] message: Message settings for the `mandrill` or `ses` email provider.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['EmailProviderSettingsHeadersArgs']]:
        """
        Headers settings for the `smtp` email provider.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['EmailProviderSettingsHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input['EmailProviderSettingsMessageArgs']]:
        """
        Message settings for the `mandrill` or `ses` email provider.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input['EmailProviderSettingsMessageArgs']]):
        pulumi.set(self, "message", value)


if not MYPY:
    class EmailProviderSettingsHeadersArgsDict(TypedDict):
        x_mc_view_content_link: NotRequired[pulumi.Input[str]]
        """
        Disable or enable the default View Content Link for sensitive emails.
        """
        x_ses_configuration_set: NotRequired[pulumi.Input[str]]
        """
        SES Configuration set to include when sending emails.
        """
elif False:
    EmailProviderSettingsHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailProviderSettingsHeadersArgs:
    def __init__(__self__, *,
                 x_mc_view_content_link: Optional[pulumi.Input[str]] = None,
                 x_ses_configuration_set: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x_mc_view_content_link: Disable or enable the default View Content Link for sensitive emails.
        :param pulumi.Input[str] x_ses_configuration_set: SES Configuration set to include when sending emails.
        """
        if x_mc_view_content_link is not None:
            pulumi.set(__self__, "x_mc_view_content_link", x_mc_view_content_link)
        if x_ses_configuration_set is not None:
            pulumi.set(__self__, "x_ses_configuration_set", x_ses_configuration_set)

    @property
    @pulumi.getter(name="xMcViewContentLink")
    def x_mc_view_content_link(self) -> Optional[pulumi.Input[str]]:
        """
        Disable or enable the default View Content Link for sensitive emails.
        """
        return pulumi.get(self, "x_mc_view_content_link")

    @x_mc_view_content_link.setter
    def x_mc_view_content_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_mc_view_content_link", value)

    @property
    @pulumi.getter(name="xSesConfigurationSet")
    def x_ses_configuration_set(self) -> Optional[pulumi.Input[str]]:
        """
        SES Configuration set to include when sending emails.
        """
        return pulumi.get(self, "x_ses_configuration_set")

    @x_ses_configuration_set.setter
    def x_ses_configuration_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_ses_configuration_set", value)


if not MYPY:
    class EmailProviderSettingsMessageArgsDict(TypedDict):
        configuration_set_name: NotRequired[pulumi.Input[str]]
        """
        Setting for the `ses` email provider. The name of the configuration set to apply to the sent emails.
        """
        view_content_link: NotRequired[pulumi.Input[bool]]
        """
        Setting for the `mandrill` email provider. Set to `true` to see the content of individual emails sent to users.
        """
elif False:
    EmailProviderSettingsMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailProviderSettingsMessageArgs:
    def __init__(__self__, *,
                 configuration_set_name: Optional[pulumi.Input[str]] = None,
                 view_content_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] configuration_set_name: Setting for the `ses` email provider. The name of the configuration set to apply to the sent emails.
        :param pulumi.Input[bool] view_content_link: Setting for the `mandrill` email provider. Set to `true` to see the content of individual emails sent to users.
        """
        if configuration_set_name is not None:
            pulumi.set(__self__, "configuration_set_name", configuration_set_name)
        if view_content_link is not None:
            pulumi.set(__self__, "view_content_link", view_content_link)

    @property
    @pulumi.getter(name="configurationSetName")
    def configuration_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        Setting for the `ses` email provider. The name of the configuration set to apply to the sent emails.
        """
        return pulumi.get(self, "configuration_set_name")

    @configuration_set_name.setter
    def configuration_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_set_name", value)

    @property
    @pulumi.getter(name="viewContentLink")
    def view_content_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting for the `mandrill` email provider. Set to `true` to see the content of individual emails sent to users.
        """
        return pulumi.get(self, "view_content_link")

    @view_content_link.setter
    def view_content_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "view_content_link", value)


if not MYPY:
    class EncryptionKeyManagerCustomerProvidedRootKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the customer provided root key was created.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The key ID of the customer provided root key.
        """
        parent_key_id: NotRequired[pulumi.Input[str]]
        """
        The key ID of the parent wrapping key.
        """
        public_wrapping_key: NotRequired[pulumi.Input[str]]
        """
        The public wrapping key in PEM format.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the customer provided root key. Should be `customer-provided-root-key`.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the customer provided root key was updated.
        """
        wrapped_key: NotRequired[pulumi.Input[str]]
        """
        The base64-encoded customer provided root key, wrapped using the `public_wrapping_key`. This can be removed after the wrapped key has been applied.
        """
        wrapping_algorithm: NotRequired[pulumi.Input[str]]
        """
        The algorithm that should be used to wrap the customer provided root key. Should be `CKM_RSA_AES_KEY_WRAP`.
        """
elif False:
    EncryptionKeyManagerCustomerProvidedRootKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionKeyManagerCustomerProvidedRootKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 parent_key_id: Optional[pulumi.Input[str]] = None,
                 public_wrapping_key: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 wrapped_key: Optional[pulumi.Input[str]] = None,
                 wrapping_algorithm: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the customer provided root key was created.
        :param pulumi.Input[str] key_id: The key ID of the customer provided root key.
        :param pulumi.Input[str] parent_key_id: The key ID of the parent wrapping key.
        :param pulumi.Input[str] public_wrapping_key: The public wrapping key in PEM format.
        :param pulumi.Input[str] state: The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        :param pulumi.Input[str] type: The type of the customer provided root key. Should be `customer-provided-root-key`.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the customer provided root key was updated.
        :param pulumi.Input[str] wrapped_key: The base64-encoded customer provided root key, wrapped using the `public_wrapping_key`. This can be removed after the wrapped key has been applied.
        :param pulumi.Input[str] wrapping_algorithm: The algorithm that should be used to wrap the customer provided root key. Should be `CKM_RSA_AES_KEY_WRAP`.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if parent_key_id is not None:
            pulumi.set(__self__, "parent_key_id", parent_key_id)
        if public_wrapping_key is not None:
            pulumi.set(__self__, "public_wrapping_key", public_wrapping_key)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if wrapped_key is not None:
            pulumi.set(__self__, "wrapped_key", wrapped_key)
        if wrapping_algorithm is not None:
            pulumi.set(__self__, "wrapping_algorithm", wrapping_algorithm)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the customer provided root key was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key ID of the customer provided root key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="parentKeyId")
    def parent_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key ID of the parent wrapping key.
        """
        return pulumi.get(self, "parent_key_id")

    @parent_key_id.setter
    def parent_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_key_id", value)

    @property
    @pulumi.getter(name="publicWrappingKey")
    def public_wrapping_key(self) -> Optional[pulumi.Input[str]]:
        """
        The public wrapping key in PEM format.
        """
        return pulumi.get(self, "public_wrapping_key")

    @public_wrapping_key.setter
    def public_wrapping_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_wrapping_key", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the customer provided root key. Should be `customer-provided-root-key`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the customer provided root key was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> Optional[pulumi.Input[str]]:
        """
        The base64-encoded customer provided root key, wrapped using the `public_wrapping_key`. This can be removed after the wrapped key has been applied.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wrapped_key", value)

    @property
    @pulumi.getter(name="wrappingAlgorithm")
    def wrapping_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        The algorithm that should be used to wrap the customer provided root key. Should be `CKM_RSA_AES_KEY_WRAP`.
        """
        return pulumi.get(self, "wrapping_algorithm")

    @wrapping_algorithm.setter
    def wrapping_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wrapping_algorithm", value)


if not MYPY:
    class EncryptionKeyManagerEncryptionKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the encryption key was created.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The key ID of the encryption key.
        """
        parent_key_id: NotRequired[pulumi.Input[str]]
        """
        The key ID of the parent wrapping key.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the encryption key. One of `customer-provided-root-key`, `environment-root-key`, or `tenant-master-key`.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The ISO 8601 formatted date the encryption key was updated.
        """
elif False:
    EncryptionKeyManagerEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionKeyManagerEncryptionKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 parent_key_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The ISO 8601 formatted date the encryption key was created.
        :param pulumi.Input[str] key_id: The key ID of the encryption key.
        :param pulumi.Input[str] parent_key_id: The key ID of the parent wrapping key.
        :param pulumi.Input[str] state: The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        :param pulumi.Input[str] type: The type of the encryption key. One of `customer-provided-root-key`, `environment-root-key`, or `tenant-master-key`.
        :param pulumi.Input[str] updated_at: The ISO 8601 formatted date the encryption key was updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if parent_key_id is not None:
            pulumi.set(__self__, "parent_key_id", parent_key_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the encryption key was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key ID of the encryption key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="parentKeyId")
    def parent_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key ID of the parent wrapping key.
        """
        return pulumi.get(self, "parent_key_id")

    @parent_key_id.setter
    def parent_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_key_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the encryption key. One of `pre-activation`, `active`, `deactivated`, or `destroyed`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the encryption key. One of `customer-provided-root-key`, `environment-root-key`, or `tenant-master-key`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO 8601 formatted date the encryption key was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class FormLanguageArgsDict(TypedDict):
        primary: pulumi.Input[str]
        """
        Primary language for the form.
        """
        default: NotRequired[pulumi.Input[str]]
        """
        Default language for the form.
        """
elif False:
    FormLanguageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FormLanguageArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input[str],
                 default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] primary: Primary language for the form.
        :param pulumi.Input[str] default: Default language for the form.
        """
        pulumi.set(__self__, "primary", primary)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def primary(self) -> pulumi.Input[str]:
        """
        Primary language for the form.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        Default language for the form.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class FormMessageArgsDict(TypedDict):
        custom: NotRequired[pulumi.Input[str]]
        """
        Custom message for the form. (JSON encoded)
        """
        errors: NotRequired[pulumi.Input[str]]
        """
        Error message for the form. (JSON encoded)
        """
elif False:
    FormMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FormMessageArgs:
    def __init__(__self__, *,
                 custom: Optional[pulumi.Input[str]] = None,
                 errors: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] custom: Custom message for the form. (JSON encoded)
        :param pulumi.Input[str] errors: Error message for the form. (JSON encoded)
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[str]]:
        """
        Custom message for the form. (JSON encoded)
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[str]]:
        """
        Error message for the form. (JSON encoded)
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "errors", value)


if not MYPY:
    class GuardianDuoArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether Duo MFA is enabled.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Duo API Hostname, see the Duo documentation for more details on Duo setup.
        """
        integration_key: NotRequired[pulumi.Input[str]]
        """
        Duo client ID, see the Duo documentation for more details on Duo setup.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Duo client secret, see the Duo documentation for more details on Duo setup.
        """
elif False:
    GuardianDuoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianDuoArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 hostname: Optional[pulumi.Input[str]] = None,
                 integration_key: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether Duo MFA is enabled.
        :param pulumi.Input[str] hostname: Duo API Hostname, see the Duo documentation for more details on Duo setup.
        :param pulumi.Input[str] integration_key: Duo client ID, see the Duo documentation for more details on Duo setup.
        :param pulumi.Input[str] secret_key: Duo client secret, see the Duo documentation for more details on Duo setup.
        """
        pulumi.set(__self__, "enabled", enabled)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if integration_key is not None:
            pulumi.set(__self__, "integration_key", integration_key)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether Duo MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Duo API Hostname, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> Optional[pulumi.Input[str]]:
        """
        Duo client ID, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integration_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Duo client secret, see the Duo documentation for more details on Duo setup.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class GuardianPhoneArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether Phone MFA is enabled.
        """
        message_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
        """
        options: NotRequired[pulumi.Input['GuardianPhoneOptionsArgsDict']]
        """
        Options for the various providers.
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
        """
elif False:
    GuardianPhoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPhoneArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 message_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 options: Optional[pulumi.Input['GuardianPhoneOptionsArgs']] = None,
                 provider: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether Phone MFA is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] message_types: Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
        :param pulumi.Input['GuardianPhoneOptionsArgs'] options: Options for the various providers.
        :param pulumi.Input[str] provider: Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
        """
        pulumi.set(__self__, "enabled", enabled)
        if message_types is not None:
            pulumi.set(__self__, "message_types", message_types)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether Phone MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="messageTypes")
    def message_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
        """
        return pulumi.get(self, "message_types")

    @message_types.setter
    def message_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "message_types", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input['GuardianPhoneOptionsArgs']]:
        """
        Options for the various providers.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input['GuardianPhoneOptionsArgs']]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)


if not MYPY:
    class GuardianPhoneOptionsArgsDict(TypedDict):
        auth_token: NotRequired[pulumi.Input[str]]
        """
        AuthToken for your Twilio account.
        """
        enrollment_message: NotRequired[pulumi.Input[str]]
        """
        This message will be sent whenever a user enrolls a new device for the first time using MFA. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        from_: NotRequired[pulumi.Input[str]]
        """
        Phone number to use as the sender.
        """
        messaging_service_sid: NotRequired[pulumi.Input[str]]
        """
        Messaging service SID.
        """
        sid: NotRequired[pulumi.Input[str]]
        """
        SID for your Twilio account.
        """
        verification_message: NotRequired[pulumi.Input[str]]
        """
        This message will be sent whenever a user logs in after the enrollment. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
elif False:
    GuardianPhoneOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPhoneOptionsArgs:
    def __init__(__self__, *,
                 auth_token: Optional[pulumi.Input[str]] = None,
                 enrollment_message: Optional[pulumi.Input[str]] = None,
                 from_: Optional[pulumi.Input[str]] = None,
                 messaging_service_sid: Optional[pulumi.Input[str]] = None,
                 sid: Optional[pulumi.Input[str]] = None,
                 verification_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_token: AuthToken for your Twilio account.
        :param pulumi.Input[str] enrollment_message: This message will be sent whenever a user enrolls a new device for the first time using MFA. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        :param pulumi.Input[str] from_: Phone number to use as the sender.
        :param pulumi.Input[str] messaging_service_sid: Messaging service SID.
        :param pulumi.Input[str] sid: SID for your Twilio account.
        :param pulumi.Input[str] verification_message: This message will be sent whenever a user logs in after the enrollment. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if enrollment_message is not None:
            pulumi.set(__self__, "enrollment_message", enrollment_message)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)
        if verification_message is not None:
            pulumi.set(__self__, "verification_message", verification_message)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[str]]:
        """
        AuthToken for your Twilio account.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter(name="enrollmentMessage")
    def enrollment_message(self) -> Optional[pulumi.Input[str]]:
        """
        This message will be sent whenever a user enrolls a new device for the first time using MFA. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        return pulumi.get(self, "enrollment_message")

    @enrollment_message.setter
    def enrollment_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enrollment_message", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        Phone number to use as the sender.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[pulumi.Input[str]]:
        """
        Messaging service SID.
        """
        return pulumi.get(self, "messaging_service_sid")

    @messaging_service_sid.setter
    def messaging_service_sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "messaging_service_sid", value)

    @property
    @pulumi.getter
    def sid(self) -> Optional[pulumi.Input[str]]:
        """
        SID for your Twilio account.
        """
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sid", value)

    @property
    @pulumi.getter(name="verificationMessage")
    def verification_message(self) -> Optional[pulumi.Input[str]]:
        """
        This message will be sent whenever a user logs in after the enrollment. Supports Liquid syntax, see [Auth0 docs](https://auth0.com/docs/customize/customize-sms-or-voice-messages).
        """
        return pulumi.get(self, "verification_message")

    @verification_message.setter
    def verification_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verification_message", value)


if not MYPY:
    class GuardianPushArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether Push MFA is enabled.
        """
        amazon_sns: NotRequired[pulumi.Input['GuardianPushAmazonSnsArgsDict']]
        """
        Configuration for Amazon SNS.
        """
        custom_app: NotRequired[pulumi.Input['GuardianPushCustomAppArgsDict']]
        """
        Configuration for the Guardian Custom App.
        """
        direct_apns: NotRequired[pulumi.Input['GuardianPushDirectApnsArgsDict']]
        """
        Configuration for the Apple Push Notification service (APNs) settings.
        """
        direct_fcm: NotRequired[pulumi.Input['GuardianPushDirectFcmArgsDict']]
        """
        Configuration for Firebase Cloud Messaging (FCM) settings.
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        Provider to use, one of `direct`, `guardian`, `sns`.
        """
elif False:
    GuardianPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPushArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 amazon_sns: Optional[pulumi.Input['GuardianPushAmazonSnsArgs']] = None,
                 custom_app: Optional[pulumi.Input['GuardianPushCustomAppArgs']] = None,
                 direct_apns: Optional[pulumi.Input['GuardianPushDirectApnsArgs']] = None,
                 direct_fcm: Optional[pulumi.Input['GuardianPushDirectFcmArgs']] = None,
                 provider: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether Push MFA is enabled.
        :param pulumi.Input['GuardianPushAmazonSnsArgs'] amazon_sns: Configuration for Amazon SNS.
        :param pulumi.Input['GuardianPushCustomAppArgs'] custom_app: Configuration for the Guardian Custom App.
        :param pulumi.Input['GuardianPushDirectApnsArgs'] direct_apns: Configuration for the Apple Push Notification service (APNs) settings.
        :param pulumi.Input['GuardianPushDirectFcmArgs'] direct_fcm: Configuration for Firebase Cloud Messaging (FCM) settings.
        :param pulumi.Input[str] provider: Provider to use, one of `direct`, `guardian`, `sns`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if amazon_sns is not None:
            pulumi.set(__self__, "amazon_sns", amazon_sns)
        if custom_app is not None:
            pulumi.set(__self__, "custom_app", custom_app)
        if direct_apns is not None:
            pulumi.set(__self__, "direct_apns", direct_apns)
        if direct_fcm is not None:
            pulumi.set(__self__, "direct_fcm", direct_fcm)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether Push MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="amazonSns")
    def amazon_sns(self) -> Optional[pulumi.Input['GuardianPushAmazonSnsArgs']]:
        """
        Configuration for Amazon SNS.
        """
        return pulumi.get(self, "amazon_sns")

    @amazon_sns.setter
    def amazon_sns(self, value: Optional[pulumi.Input['GuardianPushAmazonSnsArgs']]):
        pulumi.set(self, "amazon_sns", value)

    @property
    @pulumi.getter(name="customApp")
    def custom_app(self) -> Optional[pulumi.Input['GuardianPushCustomAppArgs']]:
        """
        Configuration for the Guardian Custom App.
        """
        return pulumi.get(self, "custom_app")

    @custom_app.setter
    def custom_app(self, value: Optional[pulumi.Input['GuardianPushCustomAppArgs']]):
        pulumi.set(self, "custom_app", value)

    @property
    @pulumi.getter(name="directApns")
    def direct_apns(self) -> Optional[pulumi.Input['GuardianPushDirectApnsArgs']]:
        """
        Configuration for the Apple Push Notification service (APNs) settings.
        """
        return pulumi.get(self, "direct_apns")

    @direct_apns.setter
    def direct_apns(self, value: Optional[pulumi.Input['GuardianPushDirectApnsArgs']]):
        pulumi.set(self, "direct_apns", value)

    @property
    @pulumi.getter(name="directFcm")
    def direct_fcm(self) -> Optional[pulumi.Input['GuardianPushDirectFcmArgs']]:
        """
        Configuration for Firebase Cloud Messaging (FCM) settings.
        """
        return pulumi.get(self, "direct_fcm")

    @direct_fcm.setter
    def direct_fcm(self, value: Optional[pulumi.Input['GuardianPushDirectFcmArgs']]):
        pulumi.set(self, "direct_fcm", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Provider to use, one of `direct`, `guardian`, `sns`.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)


if not MYPY:
    class GuardianPushAmazonSnsArgsDict(TypedDict):
        aws_access_key_id: pulumi.Input[str]
        """
        Your AWS Access Key ID.
        """
        aws_region: pulumi.Input[str]
        """
        Your AWS application's region.
        """
        aws_secret_access_key: pulumi.Input[str]
        """
        Your AWS Secret Access Key.
        """
        sns_apns_platform_application_arn: pulumi.Input[str]
        """
        The Amazon Resource Name for your Apple Push Notification Service.
        """
        sns_gcm_platform_application_arn: pulumi.Input[str]
        """
        The Amazon Resource Name for your Firebase Cloud Messaging Service.
        """
elif False:
    GuardianPushAmazonSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPushAmazonSnsArgs:
    def __init__(__self__, *,
                 aws_access_key_id: pulumi.Input[str],
                 aws_region: pulumi.Input[str],
                 aws_secret_access_key: pulumi.Input[str],
                 sns_apns_platform_application_arn: pulumi.Input[str],
                 sns_gcm_platform_application_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] aws_access_key_id: Your AWS Access Key ID.
        :param pulumi.Input[str] aws_region: Your AWS application's region.
        :param pulumi.Input[str] aws_secret_access_key: Your AWS Secret Access Key.
        :param pulumi.Input[str] sns_apns_platform_application_arn: The Amazon Resource Name for your Apple Push Notification Service.
        :param pulumi.Input[str] sns_gcm_platform_application_arn: The Amazon Resource Name for your Firebase Cloud Messaging Service.
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        pulumi.set(__self__, "sns_apns_platform_application_arn", sns_apns_platform_application_arn)
        pulumi.set(__self__, "sns_gcm_platform_application_arn", sns_gcm_platform_application_arn)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> pulumi.Input[str]:
        """
        Your AWS Access Key ID.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> pulumi.Input[str]:
        """
        Your AWS application's region.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> pulumi.Input[str]:
        """
        Your AWS Secret Access Key.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter(name="snsApnsPlatformApplicationArn")
    def sns_apns_platform_application_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name for your Apple Push Notification Service.
        """
        return pulumi.get(self, "sns_apns_platform_application_arn")

    @sns_apns_platform_application_arn.setter
    def sns_apns_platform_application_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "sns_apns_platform_application_arn", value)

    @property
    @pulumi.getter(name="snsGcmPlatformApplicationArn")
    def sns_gcm_platform_application_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name for your Firebase Cloud Messaging Service.
        """
        return pulumi.get(self, "sns_gcm_platform_application_arn")

    @sns_gcm_platform_application_arn.setter
    def sns_gcm_platform_application_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "sns_gcm_platform_application_arn", value)


if not MYPY:
    class GuardianPushCustomAppArgsDict(TypedDict):
        app_name: NotRequired[pulumi.Input[str]]
        """
        Custom Application Name.
        """
        apple_app_link: NotRequired[pulumi.Input[str]]
        """
        Apple App Store URL. Must be HTTPS or an empty string.
        """
        google_app_link: NotRequired[pulumi.Input[str]]
        """
        Google Store URL. Must be HTTPS or an empty string.
        """
elif False:
    GuardianPushCustomAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPushCustomAppArgs:
    def __init__(__self__, *,
                 app_name: Optional[pulumi.Input[str]] = None,
                 apple_app_link: Optional[pulumi.Input[str]] = None,
                 google_app_link: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] app_name: Custom Application Name.
        :param pulumi.Input[str] apple_app_link: Apple App Store URL. Must be HTTPS or an empty string.
        :param pulumi.Input[str] google_app_link: Google Store URL. Must be HTTPS or an empty string.
        """
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if apple_app_link is not None:
            pulumi.set(__self__, "apple_app_link", apple_app_link)
        if google_app_link is not None:
            pulumi.set(__self__, "google_app_link", google_app_link)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom Application Name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_name", value)

    @property
    @pulumi.getter(name="appleAppLink")
    def apple_app_link(self) -> Optional[pulumi.Input[str]]:
        """
        Apple App Store URL. Must be HTTPS or an empty string.
        """
        return pulumi.get(self, "apple_app_link")

    @apple_app_link.setter
    def apple_app_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apple_app_link", value)

    @property
    @pulumi.getter(name="googleAppLink")
    def google_app_link(self) -> Optional[pulumi.Input[str]]:
        """
        Google Store URL. Must be HTTPS or an empty string.
        """
        return pulumi.get(self, "google_app_link")

    @google_app_link.setter
    def google_app_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_app_link", value)


if not MYPY:
    class GuardianPushDirectApnsArgsDict(TypedDict):
        bundle_id: pulumi.Input[str]
        """
        The Apple Push Notification service Bundle ID.
        """
        p12: pulumi.Input[str]
        """
        The base64 encoded certificate in P12 format.
        """
        sandbox: pulumi.Input[bool]
        """
        Set to true to use the sandbox iOS app environment, otherwise set to false to use the production iOS app environment.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the Apple Push Notification service is enabled.
        """
elif False:
    GuardianPushDirectApnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPushDirectApnsArgs:
    def __init__(__self__, *,
                 bundle_id: pulumi.Input[str],
                 p12: pulumi.Input[str],
                 sandbox: pulumi.Input[bool],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bundle_id: The Apple Push Notification service Bundle ID.
        :param pulumi.Input[str] p12: The base64 encoded certificate in P12 format.
        :param pulumi.Input[bool] sandbox: Set to true to use the sandbox iOS app environment, otherwise set to false to use the production iOS app environment.
        :param pulumi.Input[bool] enabled: Indicates whether the Apple Push Notification service is enabled.
        """
        pulumi.set(__self__, "bundle_id", bundle_id)
        pulumi.set(__self__, "p12", p12)
        pulumi.set(__self__, "sandbox", sandbox)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> pulumi.Input[str]:
        """
        The Apple Push Notification service Bundle ID.
        """
        return pulumi.get(self, "bundle_id")

    @bundle_id.setter
    def bundle_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "bundle_id", value)

    @property
    @pulumi.getter
    def p12(self) -> pulumi.Input[str]:
        """
        The base64 encoded certificate in P12 format.
        """
        return pulumi.get(self, "p12")

    @p12.setter
    def p12(self, value: pulumi.Input[str]):
        pulumi.set(self, "p12", value)

    @property
    @pulumi.getter
    def sandbox(self) -> pulumi.Input[bool]:
        """
        Set to true to use the sandbox iOS app environment, otherwise set to false to use the production iOS app environment.
        """
        return pulumi.get(self, "sandbox")

    @sandbox.setter
    def sandbox(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sandbox", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Apple Push Notification service is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GuardianPushDirectFcmArgsDict(TypedDict):
        server_key: pulumi.Input[str]
        """
        The Firebase Cloud Messaging Server Key. For security purposes, we dont retrieve your existing FCM server key to check for drift.
        """
elif False:
    GuardianPushDirectFcmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianPushDirectFcmArgs:
    def __init__(__self__, *,
                 server_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] server_key: The Firebase Cloud Messaging Server Key. For security purposes, we dont retrieve your existing FCM server key to check for drift.
        """
        pulumi.set(__self__, "server_key", server_key)

    @property
    @pulumi.getter(name="serverKey")
    def server_key(self) -> pulumi.Input[str]:
        """
        The Firebase Cloud Messaging Server Key. For security purposes, we dont retrieve your existing FCM server key to check for drift.
        """
        return pulumi.get(self, "server_key")

    @server_key.setter
    def server_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_key", value)


if not MYPY:
    class GuardianWebauthnPlatformArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
        """
        override_relying_party: NotRequired[pulumi.Input[bool]]
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        relying_party_identifier: NotRequired[pulumi.Input[str]]
        """
        The Relying Party should be a suffix of the custom domain.
        """
elif False:
    GuardianWebauthnPlatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianWebauthnPlatformArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 override_relying_party: Optional[pulumi.Input[bool]] = None,
                 relying_party_identifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
        :param pulumi.Input[bool] override_relying_party: The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        :param pulumi.Input[str] relying_party_identifier: The Relying Party should be a suffix of the custom domain.
        """
        pulumi.set(__self__, "enabled", enabled)
        if override_relying_party is not None:
            pulumi.set(__self__, "override_relying_party", override_relying_party)
        if relying_party_identifier is not None:
            pulumi.set(__self__, "relying_party_identifier", relying_party_identifier)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="overrideRelyingParty")
    def override_relying_party(self) -> Optional[pulumi.Input[bool]]:
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        return pulumi.get(self, "override_relying_party")

    @override_relying_party.setter
    def override_relying_party(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_relying_party", value)

    @property
    @pulumi.getter(name="relyingPartyIdentifier")
    def relying_party_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        The Relying Party should be a suffix of the custom domain.
        """
        return pulumi.get(self, "relying_party_identifier")

    @relying_party_identifier.setter
    def relying_party_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_identifier", value)


if not MYPY:
    class GuardianWebauthnRoamingArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
        """
        override_relying_party: NotRequired[pulumi.Input[bool]]
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        relying_party_identifier: NotRequired[pulumi.Input[str]]
        """
        The Relying Party should be a suffix of the custom domain.
        """
        user_verification: NotRequired[pulumi.Input[str]]
        """
        User verification, one of `discouraged`, `preferred` or `required`.
        """
elif False:
    GuardianWebauthnRoamingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardianWebauthnRoamingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 override_relying_party: Optional[pulumi.Input[bool]] = None,
                 relying_party_identifier: Optional[pulumi.Input[str]] = None,
                 user_verification: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
        :param pulumi.Input[bool] override_relying_party: The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        :param pulumi.Input[str] relying_party_identifier: The Relying Party should be a suffix of the custom domain.
        :param pulumi.Input[str] user_verification: User verification, one of `discouraged`, `preferred` or `required`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if override_relying_party is not None:
            pulumi.set(__self__, "override_relying_party", override_relying_party)
        if relying_party_identifier is not None:
            pulumi.set(__self__, "relying_party_identifier", relying_party_identifier)
        if user_verification is not None:
            pulumi.set(__self__, "user_verification", user_verification)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="overrideRelyingParty")
    def override_relying_party(self) -> Optional[pulumi.Input[bool]]:
        """
        The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
        """
        return pulumi.get(self, "override_relying_party")

    @override_relying_party.setter
    def override_relying_party(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_relying_party", value)

    @property
    @pulumi.getter(name="relyingPartyIdentifier")
    def relying_party_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        The Relying Party should be a suffix of the custom domain.
        """
        return pulumi.get(self, "relying_party_identifier")

    @relying_party_identifier.setter
    def relying_party_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_identifier", value)

    @property
    @pulumi.getter(name="userVerification")
    def user_verification(self) -> Optional[pulumi.Input[str]]:
        """
        User verification, one of `discouraged`, `preferred` or `required`.
        """
        return pulumi.get(self, "user_verification")

    @user_verification.setter
    def user_verification(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_verification", value)


if not MYPY:
    class LogStreamSinkArgsDict(TypedDict):
        aws_account_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Account ID.
        """
        aws_partner_event_source: NotRequired[pulumi.Input[str]]
        """
        Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
        """
        aws_region: NotRequired[pulumi.Input[str]]
        """
        The region in which the EventBridge event source will be created. Possible values: `ap-east-1`, `ap-northeast-1`, `ap-northeast-2`, `ap-northeast-3`, `ap-south-1`, `ap-southeast-1`, `ap-southeast-2`, `ca-central-1`, `cn-north-1`, `cn-northwest-1`, `eu-central-1`, `eu-north-1`, `eu-west-1`, `eu-west-2`, `eu-west-3`, `me-south-1`, `sa-east-1`, `us-gov-east-1`, `us-gov-west-1`, `us-east-1`, `us-east-2`, `us-west-1`, `us-west-2`.
        """
        azure_partner_topic: NotRequired[pulumi.Input[str]]
        """
        Name of the Partner Topic to be used with Azure. Generally should not be specified.
        """
        azure_region: NotRequired[pulumi.Input[str]]
        """
        The Azure region code. Possible values: `australiacentral`, `australiaeast`, `australiasoutheast`, `brazilsouth`, `canadacentral`, `canadaeast`, `centralindia`, `centralus`, `eastasia`, `eastus`, `eastus2`, `francecentral`, `germanywestcentral`, `japaneast`, `japanwest`, `koreacentral`, `koreasouth`, `northcentralus`, `northeurope`, `norwayeast`, `southafricanorth`, `southcentralus`, `southeastasia`, `southindia`, `switzerlandnorth`, `uaenorth`, `uksouth`, `ukwest`, `westcentralus`, `westeurope`, `westindia`, `westus`, `westus2`.
        """
        azure_resource_group: NotRequired[pulumi.Input[str]]
        """
        The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
        """
        azure_subscription_id: NotRequired[pulumi.Input[str]]
        """
        The unique alphanumeric string that identifies your Azure subscription.
        """
        datadog_api_key: NotRequired[pulumi.Input[str]]
        """
        The Datadog API key.
        """
        datadog_region: NotRequired[pulumi.Input[str]]
        """
        The Datadog region. Possible values: `us`, `eu`, `us3`, `us5`.
        """
        http_authorization: NotRequired[pulumi.Input[str]]
        """
        Sent in the HTTP "Authorization" header with each request.
        """
        http_content_format: NotRequired[pulumi.Input[str]]
        """
        The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
        """
        http_content_type: NotRequired[pulumi.Input[str]]
        """
        The "Content-Type" header to send over HTTP. Common value is "application/json".
        """
        http_custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]
        """
        Additional HTTP headers to be included as part of the HTTP request.
        """
        http_endpoint: NotRequired[pulumi.Input[str]]
        """
        The HTTP endpoint to send streaming logs.
        """
        mixpanel_project_id: NotRequired[pulumi.Input[str]]
        """
        The Mixpanel project ID, found on the Project Settings page.
        """
        mixpanel_region: NotRequired[pulumi.Input[str]]
        """
        The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
        """
        mixpanel_service_account_password: NotRequired[pulumi.Input[str]]
        """
        The Mixpanel Service Account password.
        """
        mixpanel_service_account_username: NotRequired[pulumi.Input[str]]
        """
        The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
        """
        segment_write_key: NotRequired[pulumi.Input[str]]
        """
        The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
        """
        splunk_domain: NotRequired[pulumi.Input[str]]
        """
        The Splunk domain name.
        """
        splunk_port: NotRequired[pulumi.Input[str]]
        """
        The Splunk port.
        """
        splunk_secure: NotRequired[pulumi.Input[bool]]
        """
        This toggle should be turned off when using self-signed certificates.
        """
        splunk_token: NotRequired[pulumi.Input[str]]
        """
        The Splunk access token.
        """
        sumo_source_address: NotRequired[pulumi.Input[str]]
        """
        Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
        """
elif False:
    LogStreamSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogStreamSinkArgs:
    def __init__(__self__, *,
                 aws_account_id: Optional[pulumi.Input[str]] = None,
                 aws_partner_event_source: Optional[pulumi.Input[str]] = None,
                 aws_region: Optional[pulumi.Input[str]] = None,
                 azure_partner_topic: Optional[pulumi.Input[str]] = None,
                 azure_region: Optional[pulumi.Input[str]] = None,
                 azure_resource_group: Optional[pulumi.Input[str]] = None,
                 azure_subscription_id: Optional[pulumi.Input[str]] = None,
                 datadog_api_key: Optional[pulumi.Input[str]] = None,
                 datadog_region: Optional[pulumi.Input[str]] = None,
                 http_authorization: Optional[pulumi.Input[str]] = None,
                 http_content_format: Optional[pulumi.Input[str]] = None,
                 http_content_type: Optional[pulumi.Input[str]] = None,
                 http_custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 mixpanel_project_id: Optional[pulumi.Input[str]] = None,
                 mixpanel_region: Optional[pulumi.Input[str]] = None,
                 mixpanel_service_account_password: Optional[pulumi.Input[str]] = None,
                 mixpanel_service_account_username: Optional[pulumi.Input[str]] = None,
                 segment_write_key: Optional[pulumi.Input[str]] = None,
                 splunk_domain: Optional[pulumi.Input[str]] = None,
                 splunk_port: Optional[pulumi.Input[str]] = None,
                 splunk_secure: Optional[pulumi.Input[bool]] = None,
                 splunk_token: Optional[pulumi.Input[str]] = None,
                 sumo_source_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_account_id: The AWS Account ID.
        :param pulumi.Input[str] aws_partner_event_source: Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
        :param pulumi.Input[str] aws_region: The region in which the EventBridge event source will be created. Possible values: `ap-east-1`, `ap-northeast-1`, `ap-northeast-2`, `ap-northeast-3`, `ap-south-1`, `ap-southeast-1`, `ap-southeast-2`, `ca-central-1`, `cn-north-1`, `cn-northwest-1`, `eu-central-1`, `eu-north-1`, `eu-west-1`, `eu-west-2`, `eu-west-3`, `me-south-1`, `sa-east-1`, `us-gov-east-1`, `us-gov-west-1`, `us-east-1`, `us-east-2`, `us-west-1`, `us-west-2`.
        :param pulumi.Input[str] azure_partner_topic: Name of the Partner Topic to be used with Azure. Generally should not be specified.
        :param pulumi.Input[str] azure_region: The Azure region code. Possible values: `australiacentral`, `australiaeast`, `australiasoutheast`, `brazilsouth`, `canadacentral`, `canadaeast`, `centralindia`, `centralus`, `eastasia`, `eastus`, `eastus2`, `francecentral`, `germanywestcentral`, `japaneast`, `japanwest`, `koreacentral`, `koreasouth`, `northcentralus`, `northeurope`, `norwayeast`, `southafricanorth`, `southcentralus`, `southeastasia`, `southindia`, `switzerlandnorth`, `uaenorth`, `uksouth`, `ukwest`, `westcentralus`, `westeurope`, `westindia`, `westus`, `westus2`.
        :param pulumi.Input[str] azure_resource_group: The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
        :param pulumi.Input[str] azure_subscription_id: The unique alphanumeric string that identifies your Azure subscription.
        :param pulumi.Input[str] datadog_api_key: The Datadog API key.
        :param pulumi.Input[str] datadog_region: The Datadog region. Possible values: `us`, `eu`, `us3`, `us5`.
        :param pulumi.Input[str] http_authorization: Sent in the HTTP "Authorization" header with each request.
        :param pulumi.Input[str] http_content_format: The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
        :param pulumi.Input[str] http_content_type: The "Content-Type" header to send over HTTP. Common value is "application/json".
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] http_custom_headers: Additional HTTP headers to be included as part of the HTTP request.
        :param pulumi.Input[str] http_endpoint: The HTTP endpoint to send streaming logs.
        :param pulumi.Input[str] mixpanel_project_id: The Mixpanel project ID, found on the Project Settings page.
        :param pulumi.Input[str] mixpanel_region: The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
        :param pulumi.Input[str] mixpanel_service_account_password: The Mixpanel Service Account password.
        :param pulumi.Input[str] mixpanel_service_account_username: The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
        :param pulumi.Input[str] segment_write_key: The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
        :param pulumi.Input[str] splunk_domain: The Splunk domain name.
        :param pulumi.Input[str] splunk_port: The Splunk port.
        :param pulumi.Input[bool] splunk_secure: This toggle should be turned off when using self-signed certificates.
        :param pulumi.Input[str] splunk_token: The Splunk access token.
        :param pulumi.Input[str] sumo_source_address: Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
        """
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_partner_event_source is not None:
            pulumi.set(__self__, "aws_partner_event_source", aws_partner_event_source)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if azure_partner_topic is not None:
            pulumi.set(__self__, "azure_partner_topic", azure_partner_topic)
        if azure_region is not None:
            pulumi.set(__self__, "azure_region", azure_region)
        if azure_resource_group is not None:
            pulumi.set(__self__, "azure_resource_group", azure_resource_group)
        if azure_subscription_id is not None:
            pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if http_authorization is not None:
            pulumi.set(__self__, "http_authorization", http_authorization)
        if http_content_format is not None:
            pulumi.set(__self__, "http_content_format", http_content_format)
        if http_content_type is not None:
            pulumi.set(__self__, "http_content_type", http_content_type)
        if http_custom_headers is not None:
            pulumi.set(__self__, "http_custom_headers", http_custom_headers)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if mixpanel_project_id is not None:
            pulumi.set(__self__, "mixpanel_project_id", mixpanel_project_id)
        if mixpanel_region is not None:
            pulumi.set(__self__, "mixpanel_region", mixpanel_region)
        if mixpanel_service_account_password is not None:
            pulumi.set(__self__, "mixpanel_service_account_password", mixpanel_service_account_password)
        if mixpanel_service_account_username is not None:
            pulumi.set(__self__, "mixpanel_service_account_username", mixpanel_service_account_username)
        if segment_write_key is not None:
            pulumi.set(__self__, "segment_write_key", segment_write_key)
        if splunk_domain is not None:
            pulumi.set(__self__, "splunk_domain", splunk_domain)
        if splunk_port is not None:
            pulumi.set(__self__, "splunk_port", splunk_port)
        if splunk_secure is not None:
            pulumi.set(__self__, "splunk_secure", splunk_secure)
        if splunk_token is not None:
            pulumi.set(__self__, "splunk_token", splunk_token)
        if sumo_source_address is not None:
            pulumi.set(__self__, "sumo_source_address", sumo_source_address)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Account ID.
        """
        return pulumi.get(self, "aws_account_id")

    @aws_account_id.setter
    def aws_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_account_id", value)

    @property
    @pulumi.getter(name="awsPartnerEventSource")
    def aws_partner_event_source(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
        """
        return pulumi.get(self, "aws_partner_event_source")

    @aws_partner_event_source.setter
    def aws_partner_event_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_partner_event_source", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region in which the EventBridge event source will be created. Possible values: `ap-east-1`, `ap-northeast-1`, `ap-northeast-2`, `ap-northeast-3`, `ap-south-1`, `ap-southeast-1`, `ap-southeast-2`, `ca-central-1`, `cn-north-1`, `cn-northwest-1`, `eu-central-1`, `eu-north-1`, `eu-west-1`, `eu-west-2`, `eu-west-3`, `me-south-1`, `sa-east-1`, `us-gov-east-1`, `us-gov-west-1`, `us-east-1`, `us-east-2`, `us-west-1`, `us-west-2`.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter(name="azurePartnerTopic")
    def azure_partner_topic(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Partner Topic to be used with Azure. Generally should not be specified.
        """
        return pulumi.get(self, "azure_partner_topic")

    @azure_partner_topic.setter
    def azure_partner_topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_partner_topic", value)

    @property
    @pulumi.getter(name="azureRegion")
    def azure_region(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure region code. Possible values: `australiacentral`, `australiaeast`, `australiasoutheast`, `brazilsouth`, `canadacentral`, `canadaeast`, `centralindia`, `centralus`, `eastasia`, `eastus`, `eastus2`, `francecentral`, `germanywestcentral`, `japaneast`, `japanwest`, `koreacentral`, `koreasouth`, `northcentralus`, `northeurope`, `norwayeast`, `southafricanorth`, `southcentralus`, `southeastasia`, `southindia`, `switzerlandnorth`, `uaenorth`, `uksouth`, `ukwest`, `westcentralus`, `westeurope`, `westindia`, `westus`, `westus2`.
        """
        return pulumi.get(self, "azure_region")

    @azure_region.setter
    def azure_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_region", value)

    @property
    @pulumi.getter(name="azureResourceGroup")
    def azure_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
        """
        return pulumi.get(self, "azure_resource_group")

    @azure_resource_group.setter
    def azure_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_resource_group", value)

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique alphanumeric string that identifies your Azure subscription.
        """
        return pulumi.get(self, "azure_subscription_id")

    @azure_subscription_id.setter
    def azure_subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_subscription_id", value)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Datadog API key.
        """
        return pulumi.get(self, "datadog_api_key")

    @datadog_api_key.setter
    def datadog_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_api_key", value)

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[pulumi.Input[str]]:
        """
        The Datadog region. Possible values: `us`, `eu`, `us3`, `us5`.
        """
        return pulumi.get(self, "datadog_region")

    @datadog_region.setter
    def datadog_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_region", value)

    @property
    @pulumi.getter(name="httpAuthorization")
    def http_authorization(self) -> Optional[pulumi.Input[str]]:
        """
        Sent in the HTTP "Authorization" header with each request.
        """
        return pulumi.get(self, "http_authorization")

    @http_authorization.setter
    def http_authorization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_authorization", value)

    @property
    @pulumi.getter(name="httpContentFormat")
    def http_content_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
        """
        return pulumi.get(self, "http_content_format")

    @http_content_format.setter
    def http_content_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_content_format", value)

    @property
    @pulumi.getter(name="httpContentType")
    def http_content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The "Content-Type" header to send over HTTP. Common value is "application/json".
        """
        return pulumi.get(self, "http_content_type")

    @http_content_type.setter
    def http_content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_content_type", value)

    @property
    @pulumi.getter(name="httpCustomHeaders")
    def http_custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        Additional HTTP headers to be included as part of the HTTP request.
        """
        return pulumi.get(self, "http_custom_headers")

    @http_custom_headers.setter
    def http_custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "http_custom_headers", value)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP endpoint to send streaming logs.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="mixpanelProjectId")
    def mixpanel_project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Mixpanel project ID, found on the Project Settings page.
        """
        return pulumi.get(self, "mixpanel_project_id")

    @mixpanel_project_id.setter
    def mixpanel_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mixpanel_project_id", value)

    @property
    @pulumi.getter(name="mixpanelRegion")
    def mixpanel_region(self) -> Optional[pulumi.Input[str]]:
        """
        The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
        """
        return pulumi.get(self, "mixpanel_region")

    @mixpanel_region.setter
    def mixpanel_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mixpanel_region", value)

    @property
    @pulumi.getter(name="mixpanelServiceAccountPassword")
    def mixpanel_service_account_password(self) -> Optional[pulumi.Input[str]]:
        """
        The Mixpanel Service Account password.
        """
        return pulumi.get(self, "mixpanel_service_account_password")

    @mixpanel_service_account_password.setter
    def mixpanel_service_account_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mixpanel_service_account_password", value)

    @property
    @pulumi.getter(name="mixpanelServiceAccountUsername")
    def mixpanel_service_account_username(self) -> Optional[pulumi.Input[str]]:
        """
        The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
        """
        return pulumi.get(self, "mixpanel_service_account_username")

    @mixpanel_service_account_username.setter
    def mixpanel_service_account_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mixpanel_service_account_username", value)

    @property
    @pulumi.getter(name="segmentWriteKey")
    def segment_write_key(self) -> Optional[pulumi.Input[str]]:
        """
        The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
        """
        return pulumi.get(self, "segment_write_key")

    @segment_write_key.setter
    def segment_write_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_write_key", value)

    @property
    @pulumi.getter(name="splunkDomain")
    def splunk_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The Splunk domain name.
        """
        return pulumi.get(self, "splunk_domain")

    @splunk_domain.setter
    def splunk_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "splunk_domain", value)

    @property
    @pulumi.getter(name="splunkPort")
    def splunk_port(self) -> Optional[pulumi.Input[str]]:
        """
        The Splunk port.
        """
        return pulumi.get(self, "splunk_port")

    @splunk_port.setter
    def splunk_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "splunk_port", value)

    @property
    @pulumi.getter(name="splunkSecure")
    def splunk_secure(self) -> Optional[pulumi.Input[bool]]:
        """
        This toggle should be turned off when using self-signed certificates.
        """
        return pulumi.get(self, "splunk_secure")

    @splunk_secure.setter
    def splunk_secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "splunk_secure", value)

    @property
    @pulumi.getter(name="splunkToken")
    def splunk_token(self) -> Optional[pulumi.Input[str]]:
        """
        The Splunk access token.
        """
        return pulumi.get(self, "splunk_token")

    @splunk_token.setter
    def splunk_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "splunk_token", value)

    @property
    @pulumi.getter(name="sumoSourceAddress")
    def sumo_source_address(self) -> Optional[pulumi.Input[str]]:
        """
        Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
        """
        return pulumi.get(self, "sumo_source_address")

    @sumo_source_address.setter
    def sumo_source_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sumo_source_address", value)


if not MYPY:
    class OrganizationBrandingArgsDict(TypedDict):
        colors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Color scheme used to customize the login pages.
        """
        logo_url: NotRequired[pulumi.Input[str]]
        """
        URL of logo to display on login page.
        """
elif False:
    OrganizationBrandingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationBrandingArgs:
    def __init__(__self__, *,
                 colors: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 logo_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] colors: Color scheme used to customize the login pages.
        :param pulumi.Input[str] logo_url: URL of logo to display on login page.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)

    @property
    @pulumi.getter
    def colors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Color scheme used to customize the login pages.
        """
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "colors", value)

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")

    @logo_url.setter
    def logo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_url", value)


if not MYPY:
    class OrganizationConnectionsEnabledConnectionArgsDict(TypedDict):
        connection_id: pulumi.Input[str]
        """
        The ID of the connection to enable for the organization.
        """
        assign_membership_on_login: NotRequired[pulumi.Input[bool]]
        """
        When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        """
        is_signup_enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        """
        show_as_button: NotRequired[pulumi.Input[bool]]
        """
        Determines whether a connection should be displayed on this organizations login prompt. Only applicable for enterprise connections.
        """
elif False:
    OrganizationConnectionsEnabledConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationConnectionsEnabledConnectionArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[str],
                 assign_membership_on_login: Optional[pulumi.Input[bool]] = None,
                 is_signup_enabled: Optional[pulumi.Input[bool]] = None,
                 show_as_button: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] connection_id: The ID of the connection to enable for the organization.
        :param pulumi.Input[bool] assign_membership_on_login: When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        :param pulumi.Input[bool] is_signup_enabled: Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        :param pulumi.Input[bool] show_as_button: Determines whether a connection should be displayed on this organizations login prompt. Only applicable for enterprise connections.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        if assign_membership_on_login is not None:
            pulumi.set(__self__, "assign_membership_on_login", assign_membership_on_login)
        if is_signup_enabled is not None:
            pulumi.set(__self__, "is_signup_enabled", is_signup_enabled)
        if show_as_button is not None:
            pulumi.set(__self__, "show_as_button", show_as_button)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[str]:
        """
        The ID of the connection to enable for the organization.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="assignMembershipOnLogin")
    def assign_membership_on_login(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, all users that log in with this connection will be automatically granted membership in the organization. When `false`, users must be granted membership in the organization before logging in with this connection.
        """
        return pulumi.get(self, "assign_membership_on_login")

    @assign_membership_on_login.setter
    def assign_membership_on_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_membership_on_login", value)

    @property
    @pulumi.getter(name="isSignupEnabled")
    def is_signup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether organization sign-up should be enabled for this organization connection. Only applicable for database connections. Note: `is_signup_enabled` can only be `true` if `assign_membership_on_login` is `true`.
        """
        return pulumi.get(self, "is_signup_enabled")

    @is_signup_enabled.setter
    def is_signup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_signup_enabled", value)

    @property
    @pulumi.getter(name="showAsButton")
    def show_as_button(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether a connection should be displayed on this organizations login prompt. Only applicable for enterprise connections.
        """
        return pulumi.get(self, "show_as_button")

    @show_as_button.setter
    def show_as_button(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_as_button", value)


if not MYPY:
    class PagesChangePasswordArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        """
        html: pulumi.Input[str]
        """
        Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
elif False:
    PagesChangePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesChangePasswordArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 html: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        :param pulumi.Input[str] html: Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        """
        Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)


if not MYPY:
    class PagesErrorArgsDict(TypedDict):
        show_log_link: pulumi.Input[bool]
        """
        Indicates whether to show the link to logs as part of the default error page.
        """
        html: NotRequired[pulumi.Input[str]]
        """
        Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        url: NotRequired[pulumi.Input[str]]
        """
        URL to redirect to when an error occurs, instead of showing the default error page.
        """
elif False:
    PagesErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesErrorArgs:
    def __init__(__self__, *,
                 show_log_link: pulumi.Input[bool],
                 html: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] show_log_link: Indicates whether to show the link to logs as part of the default error page.
        :param pulumi.Input[str] html: Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        :param pulumi.Input[str] url: URL to redirect to when an error occurs, instead of showing the default error page.
        """
        pulumi.set(__self__, "show_log_link", show_log_link)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="showLogLink")
    def show_log_link(self) -> pulumi.Input[bool]:
        """
        Indicates whether to show the link to logs as part of the default error page.
        """
        return pulumi.get(self, "show_log_link")

    @show_log_link.setter
    def show_log_link(self, value: pulumi.Input[bool]):
        pulumi.set(self, "show_log_link", value)

    @property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[str]]:
        """
        Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to redirect to when an error occurs, instead of showing the default error page.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesGuardianMfaArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        """
        html: pulumi.Input[str]
        """
        Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
elif False:
    PagesGuardianMfaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesGuardianMfaArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 html: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        :param pulumi.Input[str] html: Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        """
        Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)


if not MYPY:
    class PagesLoginArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        """
        html: pulumi.Input[str]
        """
        Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
elif False:
    PagesLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesLoginArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 html: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        :param pulumi.Input[str] html: Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "html", html)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def html(self) -> pulumi.Input[str]:
        """
        Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: pulumi.Input[str]):
        pulumi.set(self, "html", value)


if not MYPY:
    class PromptScreenPartialInsertionPointsArgsDict(TypedDict):
        form_content_end: NotRequired[pulumi.Input[str]]
        """
        Content that goes at the end of the form.
        """
        form_content_start: NotRequired[pulumi.Input[str]]
        """
        Content that goes at the start of the form.
        """
        form_footer_end: NotRequired[pulumi.Input[str]]
        """
        Footer content for the end of the footer.
        """
        form_footer_start: NotRequired[pulumi.Input[str]]
        """
        Footer content for the start of the footer.
        """
        secondary_actions_end: NotRequired[pulumi.Input[str]]
        """
        Actions that go at the end of secondary actions.
        """
        secondary_actions_start: NotRequired[pulumi.Input[str]]
        """
        Actions that go at the start of secondary actions.
        """
elif False:
    PromptScreenPartialInsertionPointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptScreenPartialInsertionPointsArgs:
    def __init__(__self__, *,
                 form_content_end: Optional[pulumi.Input[str]] = None,
                 form_content_start: Optional[pulumi.Input[str]] = None,
                 form_footer_end: Optional[pulumi.Input[str]] = None,
                 form_footer_start: Optional[pulumi.Input[str]] = None,
                 secondary_actions_end: Optional[pulumi.Input[str]] = None,
                 secondary_actions_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] form_content_end: Content that goes at the end of the form.
        :param pulumi.Input[str] form_content_start: Content that goes at the start of the form.
        :param pulumi.Input[str] form_footer_end: Footer content for the end of the footer.
        :param pulumi.Input[str] form_footer_start: Footer content for the start of the footer.
        :param pulumi.Input[str] secondary_actions_end: Actions that go at the end of secondary actions.
        :param pulumi.Input[str] secondary_actions_start: Actions that go at the start of secondary actions.
        """
        if form_content_end is not None:
            pulumi.set(__self__, "form_content_end", form_content_end)
        if form_content_start is not None:
            pulumi.set(__self__, "form_content_start", form_content_start)
        if form_footer_end is not None:
            pulumi.set(__self__, "form_footer_end", form_footer_end)
        if form_footer_start is not None:
            pulumi.set(__self__, "form_footer_start", form_footer_start)
        if secondary_actions_end is not None:
            pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        if secondary_actions_start is not None:
            pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> Optional[pulumi.Input[str]]:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @form_content_end.setter
    def form_content_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_content_end", value)

    @property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> Optional[pulumi.Input[str]]:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @form_content_start.setter
    def form_content_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_content_start", value)

    @property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> Optional[pulumi.Input[str]]:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @form_footer_end.setter
    def form_footer_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_footer_end", value)

    @property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> Optional[pulumi.Input[str]]:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @form_footer_start.setter
    def form_footer_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_footer_start", value)

    @property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> Optional[pulumi.Input[str]]:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @secondary_actions_end.setter
    def secondary_actions_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_actions_end", value)

    @property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> Optional[pulumi.Input[str]]:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")

    @secondary_actions_start.setter
    def secondary_actions_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_actions_start", value)


if not MYPY:
    class PromptScreenPartialsScreenPartialArgsDict(TypedDict):
        insertion_points: pulumi.Input['PromptScreenPartialsScreenPartialInsertionPointsArgsDict']
        screen_name: pulumi.Input[str]
        """
        The name of the screen associated with the partials
        """
elif False:
    PromptScreenPartialsScreenPartialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptScreenPartialsScreenPartialArgs:
    def __init__(__self__, *,
                 insertion_points: pulumi.Input['PromptScreenPartialsScreenPartialInsertionPointsArgs'],
                 screen_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] screen_name: The name of the screen associated with the partials
        """
        pulumi.set(__self__, "insertion_points", insertion_points)
        pulumi.set(__self__, "screen_name", screen_name)

    @property
    @pulumi.getter(name="insertionPoints")
    def insertion_points(self) -> pulumi.Input['PromptScreenPartialsScreenPartialInsertionPointsArgs']:
        return pulumi.get(self, "insertion_points")

    @insertion_points.setter
    def insertion_points(self, value: pulumi.Input['PromptScreenPartialsScreenPartialInsertionPointsArgs']):
        pulumi.set(self, "insertion_points", value)

    @property
    @pulumi.getter(name="screenName")
    def screen_name(self) -> pulumi.Input[str]:
        """
        The name of the screen associated with the partials
        """
        return pulumi.get(self, "screen_name")

    @screen_name.setter
    def screen_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "screen_name", value)


if not MYPY:
    class PromptScreenPartialsScreenPartialInsertionPointsArgsDict(TypedDict):
        form_content_end: NotRequired[pulumi.Input[str]]
        """
        Content that goes at the end of the form.
        """
        form_content_start: NotRequired[pulumi.Input[str]]
        """
        Content that goes at the start of the form.
        """
        form_footer_end: NotRequired[pulumi.Input[str]]
        """
        Footer content for the end of the footer.
        """
        form_footer_start: NotRequired[pulumi.Input[str]]
        """
        Footer content for the start of the footer.
        """
        secondary_actions_end: NotRequired[pulumi.Input[str]]
        """
        Actions that go at the end of secondary actions.
        """
        secondary_actions_start: NotRequired[pulumi.Input[str]]
        """
        Actions that go at the start of secondary actions.
        """
elif False:
    PromptScreenPartialsScreenPartialInsertionPointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptScreenPartialsScreenPartialInsertionPointsArgs:
    def __init__(__self__, *,
                 form_content_end: Optional[pulumi.Input[str]] = None,
                 form_content_start: Optional[pulumi.Input[str]] = None,
                 form_footer_end: Optional[pulumi.Input[str]] = None,
                 form_footer_start: Optional[pulumi.Input[str]] = None,
                 secondary_actions_end: Optional[pulumi.Input[str]] = None,
                 secondary_actions_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] form_content_end: Content that goes at the end of the form.
        :param pulumi.Input[str] form_content_start: Content that goes at the start of the form.
        :param pulumi.Input[str] form_footer_end: Footer content for the end of the footer.
        :param pulumi.Input[str] form_footer_start: Footer content for the start of the footer.
        :param pulumi.Input[str] secondary_actions_end: Actions that go at the end of secondary actions.
        :param pulumi.Input[str] secondary_actions_start: Actions that go at the start of secondary actions.
        """
        if form_content_end is not None:
            pulumi.set(__self__, "form_content_end", form_content_end)
        if form_content_start is not None:
            pulumi.set(__self__, "form_content_start", form_content_start)
        if form_footer_end is not None:
            pulumi.set(__self__, "form_footer_end", form_footer_end)
        if form_footer_start is not None:
            pulumi.set(__self__, "form_footer_start", form_footer_start)
        if secondary_actions_end is not None:
            pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        if secondary_actions_start is not None:
            pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> Optional[pulumi.Input[str]]:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @form_content_end.setter
    def form_content_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_content_end", value)

    @property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> Optional[pulumi.Input[str]]:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @form_content_start.setter
    def form_content_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_content_start", value)

    @property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> Optional[pulumi.Input[str]]:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @form_footer_end.setter
    def form_footer_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_footer_end", value)

    @property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> Optional[pulumi.Input[str]]:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @form_footer_start.setter
    def form_footer_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_footer_start", value)

    @property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> Optional[pulumi.Input[str]]:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @secondary_actions_end.setter
    def secondary_actions_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_actions_end", value)

    @property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> Optional[pulumi.Input[str]]:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")

    @secondary_actions_start.setter
    def secondary_actions_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_actions_start", value)


if not MYPY:
    class ResourceServerAuthorizationDetailArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Disable authorization details.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of authorization details.
        """
elif False:
    ResourceServerAuthorizationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerAuthorizationDetailArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable: Disable authorization details.
        :param pulumi.Input[str] type: Type of authorization details.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable authorization details.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of authorization details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceServerProofOfPossessionArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Disable proof-of-possession.
        """
        mechanism: NotRequired[pulumi.Input[str]]
        """
        Mechanism used for proof-of-possession. Only `mtls` is supported.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether proof-of-possession is required with this resource server.
        """
elif False:
    ResourceServerProofOfPossessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerProofOfPossessionArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 mechanism: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable: Disable proof-of-possession.
        :param pulumi.Input[str] mechanism: Mechanism used for proof-of-possession. Only `mtls` is supported.
        :param pulumi.Input[bool] required: Indicates whether proof-of-possession is required with this resource server.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable proof-of-possession.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        Mechanism used for proof-of-possession. Only `mtls` is supported.
        """
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mechanism", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether proof-of-possession is required with this resource server.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ResourceServerScopesScopeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        User-friendly description of the scope (permission).
        """
elif False:
    ResourceServerScopesScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerScopesScopeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
        :param pulumi.Input[str] description: User-friendly description of the scope (permission).
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        User-friendly description of the scope (permission).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ResourceServerTokenEncryptionArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Disable token encryption.
        """
        encryption_key: NotRequired[pulumi.Input['ResourceServerTokenEncryptionEncryptionKeyArgsDict']]
        """
        Authorization details for this resource server.
        """
        format: NotRequired[pulumi.Input[str]]
        """
        Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
elif False:
    ResourceServerTokenEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerTokenEncryptionArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 encryption_key: Optional[pulumi.Input['ResourceServerTokenEncryptionEncryptionKeyArgs']] = None,
                 format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable: Disable token encryption.
        :param pulumi.Input['ResourceServerTokenEncryptionEncryptionKeyArgs'] encryption_key: Authorization details for this resource server.
        :param pulumi.Input[str] format: Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable token encryption.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[pulumi.Input['ResourceServerTokenEncryptionEncryptionKeyArgs']]:
        """
        Authorization details for this resource server.
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: Optional[pulumi.Input['ResourceServerTokenEncryptionEncryptionKeyArgs']]):
        pulumi.set(self, "encryption_key", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Format of the token encryption. Only `compact-nested-jwe` is supported.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class ResourceServerTokenEncryptionEncryptionKeyArgsDict(TypedDict):
        algorithm: pulumi.Input[str]
        """
        Algorithm used to encrypt the token.
        """
        pem: pulumi.Input[str]
        """
        PEM-formatted public key. Must be JSON escaped.
        """
        kid: NotRequired[pulumi.Input[str]]
        """
        Key ID.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the encryption key.
        """
elif False:
    ResourceServerTokenEncryptionEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerTokenEncryptionEncryptionKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 pem: pulumi.Input[str],
                 kid: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: Algorithm used to encrypt the token.
        :param pulumi.Input[str] pem: PEM-formatted public key. Must be JSON escaped.
        :param pulumi.Input[str] kid: Key ID.
        :param pulumi.Input[str] name: Name of the encryption key.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "pem", pem)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        Algorithm used to encrypt the token.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def pem(self) -> pulumi.Input[str]:
        """
        PEM-formatted public key. Must be JSON escaped.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem", value)

    @property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[str]]:
        """
        Key ID.
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the encryption key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RolePermissionsPermissionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of permission.
        """
        resource_server_identifier: pulumi.Input[str]
        """
        Resource server identifier associated with the permission.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the permission.
        """
        resource_server_name: NotRequired[pulumi.Input[str]]
        """
        Name of resource server that the permission is associated with.
        """
elif False:
    RolePermissionsPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolePermissionsPermissionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_server_identifier: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 resource_server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of permission.
        :param pulumi.Input[str] resource_server_identifier: Resource server identifier associated with the permission.
        :param pulumi.Input[str] description: Description of the permission.
        :param pulumi.Input[str] resource_server_name: Name of resource server that the permission is associated with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_server_name is not None:
            pulumi.set(__self__, "resource_server_name", resource_server_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> pulumi.Input[str]:
        """
        Resource server identifier associated with the permission.
        """
        return pulumi.get(self, "resource_server_identifier")

    @resource_server_identifier.setter
    def resource_server_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_server_identifier", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of resource server that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")

    @resource_server_name.setter
    def resource_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_server_name", value)


if not MYPY:
    class SelfServiceProfileBrandingArgsDict(TypedDict):
        colors: NotRequired[pulumi.Input['SelfServiceProfileBrandingColorsArgsDict']]
        """
        Configuration settings for colors for branding.
        """
        logo_url: NotRequired[pulumi.Input[str]]
        """
        URL of logo to display on login page.
        """
elif False:
    SelfServiceProfileBrandingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfServiceProfileBrandingArgs:
    def __init__(__self__, *,
                 colors: Optional[pulumi.Input['SelfServiceProfileBrandingColorsArgs']] = None,
                 logo_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SelfServiceProfileBrandingColorsArgs'] colors: Configuration settings for colors for branding.
        :param pulumi.Input[str] logo_url: URL of logo to display on login page.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)

    @property
    @pulumi.getter
    def colors(self) -> Optional[pulumi.Input['SelfServiceProfileBrandingColorsArgs']]:
        """
        Configuration settings for colors for branding.
        """
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[pulumi.Input['SelfServiceProfileBrandingColorsArgs']]):
        pulumi.set(self, "colors", value)

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of logo to display on login page.
        """
        return pulumi.get(self, "logo_url")

    @logo_url.setter
    def logo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_url", value)


if not MYPY:
    class SelfServiceProfileBrandingColorsArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[str]]
        """
        Primary button background color in hexadecimal.
        """
elif False:
    SelfServiceProfileBrandingColorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfServiceProfileBrandingColorsArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] primary: Primary button background color in hexadecimal.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[str]]:
        """
        Primary button background color in hexadecimal.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary", value)


if not MYPY:
    class SelfServiceProfileUserAttributeArgsDict(TypedDict):
        description: pulumi.Input[str]
        """
        A human readable description of the attribute.
        """
        is_optional: pulumi.Input[bool]
        """
        Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        """
        name: pulumi.Input[str]
        """
        Attributes name on Auth0 side
        """
elif False:
    SelfServiceProfileUserAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfServiceProfileUserAttributeArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 is_optional: pulumi.Input[bool],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] description: A human readable description of the attribute.
        :param pulumi.Input[bool] is_optional: Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        :param pulumi.Input[str] name: Attributes name on Auth0 side
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "is_optional", is_optional)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        A human readable description of the attribute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isOptional")
    def is_optional(self) -> pulumi.Input[bool]:
        """
        Indicates if this attribute is optional or if it has to be provided by the customer for the application to function.
        """
        return pulumi.get(self, "is_optional")

    @is_optional.setter
    def is_optional(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_optional", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Attributes name on Auth0 side
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TenantFlagsArgsDict(TypedDict):
        allow_legacy_delegation_grant_types: NotRequired[pulumi.Input[bool]]
        """
        Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        """
        allow_legacy_ro_grant_types: NotRequired[pulumi.Input[bool]]
        """
        Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        """
        allow_legacy_tokeninfo_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        """
        dashboard_insights_view: NotRequired[pulumi.Input[bool]]
        """
        Enables new insights activity page view.
        """
        dashboard_log_streams_next: NotRequired[pulumi.Input[bool]]
        """
        Enables beta access to log streaming changes.
        """
        disable_clickjack_protection_headers: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        """
        disable_fields_map_fix: NotRequired[pulumi.Input[bool]]
        """
        Disables SAML fields map fix for bad mappings with repeated attributes.
        """
        disable_management_api_sms_obfuscation: NotRequired[pulumi.Input[bool]]
        """
        If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        """
        enable_adfs_waad_email_verification: NotRequired[pulumi.Input[bool]]
        """
        If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        """
        enable_apis_section: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the APIs section is enabled for the tenant.
        """
        enable_client_connections: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether all current connections should be enabled when a new client is created.
        """
        enable_custom_domain_in_emails: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        """
        enable_dynamic_client_registration: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the tenant allows dynamic client registration.
        """
        enable_idtoken_api2: NotRequired[pulumi.Input[bool]]
        """
        Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        """
        enable_legacy_logs_search_v2: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use the older v2 legacy logs search.
        """
        enable_legacy_profile: NotRequired[pulumi.Input[bool]]
        """
        Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        """
        enable_pipeline2: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether advanced API Authorization scenarios are enabled.
        """
        enable_public_signup_user_exists_error: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        """
        enable_sso: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        """
        mfa_show_factor_list_on_enrollment: NotRequired[pulumi.Input[bool]]
        """
        Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        """
        no_disclose_enterprise_connections: NotRequired[pulumi.Input[bool]]
        """
        Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        """
        remove_alg_from_jwks: NotRequired[pulumi.Input[bool]]
        """
        Remove `alg` from jwks(JSON Web Key Sets).
        """
        require_pushed_authorization_requests: NotRequired[pulumi.Input[bool]]
        """
        This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        """
        revoke_refresh_token_grant: NotRequired[pulumi.Input[bool]]
        """
        Delete underlying grant when a refresh token is revoked via the Authentication API.
        """
        use_scope_descriptions_for_consent: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use scope descriptions for consent.
        """
elif False:
    TenantFlagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TenantFlagsArgs:
    def __init__(__self__, *,
                 allow_legacy_delegation_grant_types: Optional[pulumi.Input[bool]] = None,
                 allow_legacy_ro_grant_types: Optional[pulumi.Input[bool]] = None,
                 allow_legacy_tokeninfo_endpoint: Optional[pulumi.Input[bool]] = None,
                 dashboard_insights_view: Optional[pulumi.Input[bool]] = None,
                 dashboard_log_streams_next: Optional[pulumi.Input[bool]] = None,
                 disable_clickjack_protection_headers: Optional[pulumi.Input[bool]] = None,
                 disable_fields_map_fix: Optional[pulumi.Input[bool]] = None,
                 disable_management_api_sms_obfuscation: Optional[pulumi.Input[bool]] = None,
                 enable_adfs_waad_email_verification: Optional[pulumi.Input[bool]] = None,
                 enable_apis_section: Optional[pulumi.Input[bool]] = None,
                 enable_client_connections: Optional[pulumi.Input[bool]] = None,
                 enable_custom_domain_in_emails: Optional[pulumi.Input[bool]] = None,
                 enable_dynamic_client_registration: Optional[pulumi.Input[bool]] = None,
                 enable_idtoken_api2: Optional[pulumi.Input[bool]] = None,
                 enable_legacy_logs_search_v2: Optional[pulumi.Input[bool]] = None,
                 enable_legacy_profile: Optional[pulumi.Input[bool]] = None,
                 enable_pipeline2: Optional[pulumi.Input[bool]] = None,
                 enable_public_signup_user_exists_error: Optional[pulumi.Input[bool]] = None,
                 enable_sso: Optional[pulumi.Input[bool]] = None,
                 mfa_show_factor_list_on_enrollment: Optional[pulumi.Input[bool]] = None,
                 no_disclose_enterprise_connections: Optional[pulumi.Input[bool]] = None,
                 remove_alg_from_jwks: Optional[pulumi.Input[bool]] = None,
                 require_pushed_authorization_requests: Optional[pulumi.Input[bool]] = None,
                 revoke_refresh_token_grant: Optional[pulumi.Input[bool]] = None,
                 use_scope_descriptions_for_consent: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_legacy_delegation_grant_types: Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        :param pulumi.Input[bool] allow_legacy_ro_grant_types: Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        :param pulumi.Input[bool] allow_legacy_tokeninfo_endpoint: If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        :param pulumi.Input[bool] dashboard_insights_view: Enables new insights activity page view.
        :param pulumi.Input[bool] dashboard_log_streams_next: Enables beta access to log streaming changes.
        :param pulumi.Input[bool] disable_clickjack_protection_headers: Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        :param pulumi.Input[bool] disable_fields_map_fix: Disables SAML fields map fix for bad mappings with repeated attributes.
        :param pulumi.Input[bool] disable_management_api_sms_obfuscation: If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        :param pulumi.Input[bool] enable_adfs_waad_email_verification: If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        :param pulumi.Input[bool] enable_apis_section: Indicates whether the APIs section is enabled for the tenant.
        :param pulumi.Input[bool] enable_client_connections: Indicates whether all current connections should be enabled when a new client is created.
        :param pulumi.Input[bool] enable_custom_domain_in_emails: Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        :param pulumi.Input[bool] enable_dynamic_client_registration: Indicates whether the tenant allows dynamic client registration.
        :param pulumi.Input[bool] enable_idtoken_api2: Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        :param pulumi.Input[bool] enable_legacy_logs_search_v2: Indicates whether to use the older v2 legacy logs search.
        :param pulumi.Input[bool] enable_legacy_profile: Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        :param pulumi.Input[bool] enable_pipeline2: Indicates whether advanced API Authorization scenarios are enabled.
        :param pulumi.Input[bool] enable_public_signup_user_exists_error: Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        :param pulumi.Input[bool] enable_sso: Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        :param pulumi.Input[bool] mfa_show_factor_list_on_enrollment: Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        :param pulumi.Input[bool] no_disclose_enterprise_connections: Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        :param pulumi.Input[bool] remove_alg_from_jwks: Remove `alg` from jwks(JSON Web Key Sets).
        :param pulumi.Input[bool] require_pushed_authorization_requests: This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        :param pulumi.Input[bool] revoke_refresh_token_grant: Delete underlying grant when a refresh token is revoked via the Authentication API.
        :param pulumi.Input[bool] use_scope_descriptions_for_consent: Indicates whether to use scope descriptions for consent.
        """
        if allow_legacy_delegation_grant_types is not None:
            pulumi.set(__self__, "allow_legacy_delegation_grant_types", allow_legacy_delegation_grant_types)
        if allow_legacy_ro_grant_types is not None:
            pulumi.set(__self__, "allow_legacy_ro_grant_types", allow_legacy_ro_grant_types)
        if allow_legacy_tokeninfo_endpoint is not None:
            pulumi.set(__self__, "allow_legacy_tokeninfo_endpoint", allow_legacy_tokeninfo_endpoint)
        if dashboard_insights_view is not None:
            pulumi.set(__self__, "dashboard_insights_view", dashboard_insights_view)
        if dashboard_log_streams_next is not None:
            pulumi.set(__self__, "dashboard_log_streams_next", dashboard_log_streams_next)
        if disable_clickjack_protection_headers is not None:
            pulumi.set(__self__, "disable_clickjack_protection_headers", disable_clickjack_protection_headers)
        if disable_fields_map_fix is not None:
            pulumi.set(__self__, "disable_fields_map_fix", disable_fields_map_fix)
        if disable_management_api_sms_obfuscation is not None:
            pulumi.set(__self__, "disable_management_api_sms_obfuscation", disable_management_api_sms_obfuscation)
        if enable_adfs_waad_email_verification is not None:
            pulumi.set(__self__, "enable_adfs_waad_email_verification", enable_adfs_waad_email_verification)
        if enable_apis_section is not None:
            pulumi.set(__self__, "enable_apis_section", enable_apis_section)
        if enable_client_connections is not None:
            pulumi.set(__self__, "enable_client_connections", enable_client_connections)
        if enable_custom_domain_in_emails is not None:
            pulumi.set(__self__, "enable_custom_domain_in_emails", enable_custom_domain_in_emails)
        if enable_dynamic_client_registration is not None:
            pulumi.set(__self__, "enable_dynamic_client_registration", enable_dynamic_client_registration)
        if enable_idtoken_api2 is not None:
            pulumi.set(__self__, "enable_idtoken_api2", enable_idtoken_api2)
        if enable_legacy_logs_search_v2 is not None:
            pulumi.set(__self__, "enable_legacy_logs_search_v2", enable_legacy_logs_search_v2)
        if enable_legacy_profile is not None:
            pulumi.set(__self__, "enable_legacy_profile", enable_legacy_profile)
        if enable_pipeline2 is not None:
            pulumi.set(__self__, "enable_pipeline2", enable_pipeline2)
        if enable_public_signup_user_exists_error is not None:
            pulumi.set(__self__, "enable_public_signup_user_exists_error", enable_public_signup_user_exists_error)
        if enable_sso is not None:
            pulumi.set(__self__, "enable_sso", enable_sso)
        if mfa_show_factor_list_on_enrollment is not None:
            pulumi.set(__self__, "mfa_show_factor_list_on_enrollment", mfa_show_factor_list_on_enrollment)
        if no_disclose_enterprise_connections is not None:
            pulumi.set(__self__, "no_disclose_enterprise_connections", no_disclose_enterprise_connections)
        if remove_alg_from_jwks is not None:
            pulumi.set(__self__, "remove_alg_from_jwks", remove_alg_from_jwks)
        if require_pushed_authorization_requests is not None:
            warnings.warn("""This Flag is not supported by the Auth0 Management API and will be removed in the next major release.""", DeprecationWarning)
            pulumi.log.warn("""require_pushed_authorization_requests is deprecated: This Flag is not supported by the Auth0 Management API and will be removed in the next major release.""")
        if require_pushed_authorization_requests is not None:
            pulumi.set(__self__, "require_pushed_authorization_requests", require_pushed_authorization_requests)
        if revoke_refresh_token_grant is not None:
            pulumi.set(__self__, "revoke_refresh_token_grant", revoke_refresh_token_grant)
        if use_scope_descriptions_for_consent is not None:
            pulumi.set(__self__, "use_scope_descriptions_for_consent", use_scope_descriptions_for_consent)

    @property
    @pulumi.getter(name="allowLegacyDelegationGrantTypes")
    def allow_legacy_delegation_grant_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_delegation_grant_types")

    @allow_legacy_delegation_grant_types.setter
    def allow_legacy_delegation_grant_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_legacy_delegation_grant_types", value)

    @property
    @pulumi.getter(name="allowLegacyRoGrantTypes")
    def allow_legacy_ro_grant_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
        """
        return pulumi.get(self, "allow_legacy_ro_grant_types")

    @allow_legacy_ro_grant_types.setter
    def allow_legacy_ro_grant_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_legacy_ro_grant_types", value)

    @property
    @pulumi.getter(name="allowLegacyTokeninfoEndpoint")
    def allow_legacy_tokeninfo_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
        """
        return pulumi.get(self, "allow_legacy_tokeninfo_endpoint")

    @allow_legacy_tokeninfo_endpoint.setter
    def allow_legacy_tokeninfo_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_legacy_tokeninfo_endpoint", value)

    @property
    @pulumi.getter(name="dashboardInsightsView")
    def dashboard_insights_view(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables new insights activity page view.
        """
        return pulumi.get(self, "dashboard_insights_view")

    @dashboard_insights_view.setter
    def dashboard_insights_view(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dashboard_insights_view", value)

    @property
    @pulumi.getter(name="dashboardLogStreamsNext")
    def dashboard_log_streams_next(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables beta access to log streaming changes.
        """
        return pulumi.get(self, "dashboard_log_streams_next")

    @dashboard_log_streams_next.setter
    def dashboard_log_streams_next(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dashboard_log_streams_next", value)

    @property
    @pulumi.getter(name="disableClickjackProtectionHeaders")
    def disable_clickjack_protection_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
        """
        return pulumi.get(self, "disable_clickjack_protection_headers")

    @disable_clickjack_protection_headers.setter
    def disable_clickjack_protection_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_clickjack_protection_headers", value)

    @property
    @pulumi.getter(name="disableFieldsMapFix")
    def disable_fields_map_fix(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables SAML fields map fix for bad mappings with repeated attributes.
        """
        return pulumi.get(self, "disable_fields_map_fix")

    @disable_fields_map_fix.setter
    def disable_fields_map_fix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_fields_map_fix", value)

    @property
    @pulumi.getter(name="disableManagementApiSmsObfuscation")
    def disable_management_api_sms_obfuscation(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, SMS phone numbers will not be obfuscated in Management API GET calls.
        """
        return pulumi.get(self, "disable_management_api_sms_obfuscation")

    @disable_management_api_sms_obfuscation.setter
    def disable_management_api_sms_obfuscation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_management_api_sms_obfuscation", value)

    @property
    @pulumi.getter(name="enableAdfsWaadEmailVerification")
    def enable_adfs_waad_email_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
        """
        return pulumi.get(self, "enable_adfs_waad_email_verification")

    @enable_adfs_waad_email_verification.setter
    def enable_adfs_waad_email_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_adfs_waad_email_verification", value)

    @property
    @pulumi.getter(name="enableApisSection")
    def enable_apis_section(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the APIs section is enabled for the tenant.
        """
        return pulumi.get(self, "enable_apis_section")

    @enable_apis_section.setter
    def enable_apis_section(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_apis_section", value)

    @property
    @pulumi.getter(name="enableClientConnections")
    def enable_client_connections(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether all current connections should be enabled when a new client is created.
        """
        return pulumi.get(self, "enable_client_connections")

    @enable_client_connections.setter
    def enable_client_connections(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_client_connections", value)

    @property
    @pulumi.getter(name="enableCustomDomainInEmails")
    def enable_custom_domain_in_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the tenant allows custom domains in emails. Before enabling this flag, you must have a custom domain with status: `ready`.
        """
        return pulumi.get(self, "enable_custom_domain_in_emails")

    @enable_custom_domain_in_emails.setter
    def enable_custom_domain_in_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_custom_domain_in_emails", value)

    @property
    @pulumi.getter(name="enableDynamicClientRegistration")
    def enable_dynamic_client_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the tenant allows dynamic client registration.
        """
        return pulumi.get(self, "enable_dynamic_client_registration")

    @enable_dynamic_client_registration.setter
    def enable_dynamic_client_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_dynamic_client_registration", value)

    @property
    @pulumi.getter(name="enableIdtokenApi2")
    def enable_idtoken_api2(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
        """
        return pulumi.get(self, "enable_idtoken_api2")

    @enable_idtoken_api2.setter
    def enable_idtoken_api2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_idtoken_api2", value)

    @property
    @pulumi.getter(name="enableLegacyLogsSearchV2")
    def enable_legacy_logs_search_v2(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use the older v2 legacy logs search.
        """
        return pulumi.get(self, "enable_legacy_logs_search_v2")

    @enable_legacy_logs_search_v2.setter
    def enable_legacy_logs_search_v2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_legacy_logs_search_v2", value)

    @property
    @pulumi.getter(name="enableLegacyProfile")
    def enable_legacy_profile(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
        """
        return pulumi.get(self, "enable_legacy_profile")

    @enable_legacy_profile.setter
    def enable_legacy_profile(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_legacy_profile", value)

    @property
    @pulumi.getter(name="enablePipeline2")
    def enable_pipeline2(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether advanced API Authorization scenarios are enabled.
        """
        return pulumi.get(self, "enable_pipeline2")

    @enable_pipeline2.setter
    def enable_pipeline2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_pipeline2", value)

    @property
    @pulumi.getter(name="enablePublicSignupUserExistsError")
    def enable_public_signup_user_exists_error(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the public sign up process shows a `user_exists` error if the user already exists.
        """
        return pulumi.get(self, "enable_public_signup_user_exists_error")

    @enable_public_signup_user_exists_error.setter
    def enable_public_signup_user_exists_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_public_signup_user_exists_error", value)

    @property
    @pulumi.getter(name="enableSso")
    def enable_sso(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating whether users will not be prompted to confirm log in before SSO redirection. This flag applies to existing tenants only; new tenants have it enforced as true.
        """
        return pulumi.get(self, "enable_sso")

    @enable_sso.setter
    def enable_sso(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_sso", value)

    @property
    @pulumi.getter(name="mfaShowFactorListOnEnrollment")
    def mfa_show_factor_list_on_enrollment(self) -> Optional[pulumi.Input[bool]]:
        """
        Used to allow users to pick which factor to enroll with from the list of available MFA factors.
        """
        return pulumi.get(self, "mfa_show_factor_list_on_enrollment")

    @mfa_show_factor_list_on_enrollment.setter
    def mfa_show_factor_list_on_enrollment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mfa_show_factor_list_on_enrollment", value)

    @property
    @pulumi.getter(name="noDiscloseEnterpriseConnections")
    def no_disclose_enterprise_connections(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
        """
        return pulumi.get(self, "no_disclose_enterprise_connections")

    @no_disclose_enterprise_connections.setter
    def no_disclose_enterprise_connections(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_disclose_enterprise_connections", value)

    @property
    @pulumi.getter(name="removeAlgFromJwks")
    def remove_alg_from_jwks(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove `alg` from jwks(JSON Web Key Sets).
        """
        return pulumi.get(self, "remove_alg_from_jwks")

    @remove_alg_from_jwks.setter
    def remove_alg_from_jwks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove_alg_from_jwks", value)

    @property
    @pulumi.getter(name="requirePushedAuthorizationRequests")
    @_utilities.deprecated("""This Flag is not supported by the Auth0 Management API and will be removed in the next major release.""")
    def require_pushed_authorization_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        This Flag is not supported by the Auth0 Management API and will be removed in the next major release.
        """
        return pulumi.get(self, "require_pushed_authorization_requests")

    @require_pushed_authorization_requests.setter
    def require_pushed_authorization_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_pushed_authorization_requests", value)

    @property
    @pulumi.getter(name="revokeRefreshTokenGrant")
    def revoke_refresh_token_grant(self) -> Optional[pulumi.Input[bool]]:
        """
        Delete underlying grant when a refresh token is revoked via the Authentication API.
        """
        return pulumi.get(self, "revoke_refresh_token_grant")

    @revoke_refresh_token_grant.setter
    def revoke_refresh_token_grant(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "revoke_refresh_token_grant", value)

    @property
    @pulumi.getter(name="useScopeDescriptionsForConsent")
    def use_scope_descriptions_for_consent(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use scope descriptions for consent.
        """
        return pulumi.get(self, "use_scope_descriptions_for_consent")

    @use_scope_descriptions_for_consent.setter
    def use_scope_descriptions_for_consent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_scope_descriptions_for_consent", value)


if not MYPY:
    class TenantMtlsArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Disable mTLS settings.
        """
        enable_endpoint_aliases: NotRequired[pulumi.Input[bool]]
        """
        Enable mTLS endpoint aliases.
        """
elif False:
    TenantMtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TenantMtlsArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 enable_endpoint_aliases: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable: Disable mTLS settings.
        :param pulumi.Input[bool] enable_endpoint_aliases: Enable mTLS endpoint aliases.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if enable_endpoint_aliases is not None:
            pulumi.set(__self__, "enable_endpoint_aliases", enable_endpoint_aliases)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable mTLS settings.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter(name="enableEndpointAliases")
    def enable_endpoint_aliases(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable mTLS endpoint aliases.
        """
        return pulumi.get(self, "enable_endpoint_aliases")

    @enable_endpoint_aliases.setter
    def enable_endpoint_aliases(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_endpoint_aliases", value)


if not MYPY:
    class TenantSessionCookieArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
elif False:
    TenantSessionCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TenantSessionCookieArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TenantSessionsArgsDict(TypedDict):
        oidc_logout_prompt_enabled: pulumi.Input[bool]
        """
        When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
elif False:
    TenantSessionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TenantSessionsArgs:
    def __init__(__self__, *,
                 oidc_logout_prompt_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] oidc_logout_prompt_enabled: When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        pulumi.set(__self__, "oidc_logout_prompt_enabled", oidc_logout_prompt_enabled)

    @property
    @pulumi.getter(name="oidcLogoutPromptEnabled")
    def oidc_logout_prompt_enabled(self) -> pulumi.Input[bool]:
        """
        When active, users will be presented with a consent prompt to confirm the logout request if the request is not trustworthy. Turn off the consent prompt to bypass user confirmation.
        """
        return pulumi.get(self, "oidc_logout_prompt_enabled")

    @oidc_logout_prompt_enabled.setter
    def oidc_logout_prompt_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "oidc_logout_prompt_enabled", value)


if not MYPY:
    class TriggerActionsActionArgsDict(TypedDict):
        display_name: pulumi.Input[str]
        """
        The display name of the action within the flow.
        """
        id: pulumi.Input[str]
        """
        Action ID.
        """
elif False:
    TriggerActionsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionsActionArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] display_name: The display name of the action within the flow.
        :param pulumi.Input[str] id: Action ID.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The display name of the action within the flow.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Action ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class UserPermissionsPermissionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of permission.
        """
        resource_server_identifier: pulumi.Input[str]
        """
        Resource server identifier associated with the permission.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the permission.
        """
        resource_server_name: NotRequired[pulumi.Input[str]]
        """
        Name of resource server that the permission is associated with.
        """
elif False:
    UserPermissionsPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPermissionsPermissionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_server_identifier: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 resource_server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of permission.
        :param pulumi.Input[str] resource_server_identifier: Resource server identifier associated with the permission.
        :param pulumi.Input[str] description: Description of the permission.
        :param pulumi.Input[str] resource_server_name: Name of resource server that the permission is associated with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_server_identifier", resource_server_identifier)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_server_name is not None:
            pulumi.set(__self__, "resource_server_name", resource_server_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceServerIdentifier")
    def resource_server_identifier(self) -> pulumi.Input[str]:
        """
        Resource server identifier associated with the permission.
        """
        return pulumi.get(self, "resource_server_identifier")

    @resource_server_identifier.setter
    def resource_server_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_server_identifier", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the permission.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="resourceServerName")
    def resource_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of resource server that the permission is associated with.
        """
        return pulumi.get(self, "resource_server_name")

    @resource_server_name.setter
    def resource_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_server_name", value)


if not MYPY:
    class GetConnectionScimConfigurationDefaultMappingArgsDict(TypedDict):
        auth0: str
        """
        The field location in the Auth0 schema.
        """
        scim: str
        """
        The field location in the SCIM schema.
        """
elif False:
    GetConnectionScimConfigurationDefaultMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionScimConfigurationDefaultMappingArgs:
    def __init__(__self__, *,
                 auth0: str,
                 scim: str):
        """
        :param str auth0: The field location in the Auth0 schema.
        :param str scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @property
    @pulumi.getter
    def auth0(self) -> str:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @auth0.setter
    def auth0(self, value: str):
        pulumi.set(self, "auth0", value)

    @property
    @pulumi.getter
    def scim(self) -> str:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")

    @scim.setter
    def scim(self, value: str):
        pulumi.set(self, "scim", value)


if not MYPY:
    class GetConnectionScimConfigurationMappingArgsDict(TypedDict):
        auth0: str
        """
        The field location in the Auth0 schema.
        """
        scim: str
        """
        The field location in the SCIM schema.
        """
elif False:
    GetConnectionScimConfigurationMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectionScimConfigurationMappingArgs:
    def __init__(__self__, *,
                 auth0: str,
                 scim: str):
        """
        :param str auth0: The field location in the Auth0 schema.
        :param str scim: The field location in the SCIM schema.
        """
        pulumi.set(__self__, "auth0", auth0)
        pulumi.set(__self__, "scim", scim)

    @property
    @pulumi.getter
    def auth0(self) -> str:
        """
        The field location in the Auth0 schema.
        """
        return pulumi.get(self, "auth0")

    @auth0.setter
    def auth0(self, value: str):
        pulumi.set(self, "auth0", value)

    @property
    @pulumi.getter
    def scim(self) -> str:
        """
        The field location in the SCIM schema.
        """
        return pulumi.get(self, "scim")

    @scim.setter
    def scim(self, value: str):
        pulumi.set(self, "scim", value)


if not MYPY:
    class GetPromptScreenPartialsScreenPartialArgsDict(TypedDict):
        insertion_points: Sequence['GetPromptScreenPartialsScreenPartialInsertionPointArgsDict']
        screen_name: str
        """
        The name of the screen associated with the partials
        """
elif False:
    GetPromptScreenPartialsScreenPartialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPromptScreenPartialsScreenPartialArgs:
    def __init__(__self__, *,
                 insertion_points: Sequence['GetPromptScreenPartialsScreenPartialInsertionPointArgs'],
                 screen_name: str):
        """
        :param str screen_name: The name of the screen associated with the partials
        """
        pulumi.set(__self__, "insertion_points", insertion_points)
        pulumi.set(__self__, "screen_name", screen_name)

    @property
    @pulumi.getter(name="insertionPoints")
    def insertion_points(self) -> Sequence['GetPromptScreenPartialsScreenPartialInsertionPointArgs']:
        return pulumi.get(self, "insertion_points")

    @insertion_points.setter
    def insertion_points(self, value: Sequence['GetPromptScreenPartialsScreenPartialInsertionPointArgs']):
        pulumi.set(self, "insertion_points", value)

    @property
    @pulumi.getter(name="screenName")
    def screen_name(self) -> str:
        """
        The name of the screen associated with the partials
        """
        return pulumi.get(self, "screen_name")

    @screen_name.setter
    def screen_name(self, value: str):
        pulumi.set(self, "screen_name", value)


if not MYPY:
    class GetPromptScreenPartialsScreenPartialInsertionPointArgsDict(TypedDict):
        form_content_end: str
        """
        Content that goes at the end of the form.
        """
        form_content_start: str
        """
        Content that goes at the start of the form.
        """
        form_footer_end: str
        """
        Footer content for the end of the footer.
        """
        form_footer_start: str
        """
        Footer content for the start of the footer.
        """
        secondary_actions_end: str
        """
        Actions that go at the end of secondary actions.
        """
        secondary_actions_start: str
        """
        Actions that go at the start of secondary actions.
        """
elif False:
    GetPromptScreenPartialsScreenPartialInsertionPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPromptScreenPartialsScreenPartialInsertionPointArgs:
    def __init__(__self__, *,
                 form_content_end: str,
                 form_content_start: str,
                 form_footer_end: str,
                 form_footer_start: str,
                 secondary_actions_end: str,
                 secondary_actions_start: str):
        """
        :param str form_content_end: Content that goes at the end of the form.
        :param str form_content_start: Content that goes at the start of the form.
        :param str form_footer_end: Footer content for the end of the footer.
        :param str form_footer_start: Footer content for the start of the footer.
        :param str secondary_actions_end: Actions that go at the end of secondary actions.
        :param str secondary_actions_start: Actions that go at the start of secondary actions.
        """
        pulumi.set(__self__, "form_content_end", form_content_end)
        pulumi.set(__self__, "form_content_start", form_content_start)
        pulumi.set(__self__, "form_footer_end", form_footer_end)
        pulumi.set(__self__, "form_footer_start", form_footer_start)
        pulumi.set(__self__, "secondary_actions_end", secondary_actions_end)
        pulumi.set(__self__, "secondary_actions_start", secondary_actions_start)

    @property
    @pulumi.getter(name="formContentEnd")
    def form_content_end(self) -> str:
        """
        Content that goes at the end of the form.
        """
        return pulumi.get(self, "form_content_end")

    @form_content_end.setter
    def form_content_end(self, value: str):
        pulumi.set(self, "form_content_end", value)

    @property
    @pulumi.getter(name="formContentStart")
    def form_content_start(self) -> str:
        """
        Content that goes at the start of the form.
        """
        return pulumi.get(self, "form_content_start")

    @form_content_start.setter
    def form_content_start(self, value: str):
        pulumi.set(self, "form_content_start", value)

    @property
    @pulumi.getter(name="formFooterEnd")
    def form_footer_end(self) -> str:
        """
        Footer content for the end of the footer.
        """
        return pulumi.get(self, "form_footer_end")

    @form_footer_end.setter
    def form_footer_end(self, value: str):
        pulumi.set(self, "form_footer_end", value)

    @property
    @pulumi.getter(name="formFooterStart")
    def form_footer_start(self) -> str:
        """
        Footer content for the start of the footer.
        """
        return pulumi.get(self, "form_footer_start")

    @form_footer_start.setter
    def form_footer_start(self, value: str):
        pulumi.set(self, "form_footer_start", value)

    @property
    @pulumi.getter(name="secondaryActionsEnd")
    def secondary_actions_end(self) -> str:
        """
        Actions that go at the end of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_end")

    @secondary_actions_end.setter
    def secondary_actions_end(self, value: str):
        pulumi.set(self, "secondary_actions_end", value)

    @property
    @pulumi.getter(name="secondaryActionsStart")
    def secondary_actions_start(self) -> str:
        """
        Actions that go at the start of secondary actions.
        """
        return pulumi.get(self, "secondary_actions_start")

    @secondary_actions_start.setter
    def secondary_actions_start(self, value: str):
        pulumi.set(self, "secondary_actions_start", value)


