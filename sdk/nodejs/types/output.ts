// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ActionDependency {
    /**
     * Dependency name, e.g. `lodash`.
     */
    name: string;
    /**
     * Dependency version, e.g. `latest` or `4.17.21`.
     */
    version: string;
}

export interface ActionSecret {
    /**
     * Secret name.
     */
    name: string;
    /**
     * Secret value.
     */
    value: string;
}

export interface ActionSupportedTriggers {
    /**
     * The trigger ID.
     */
    id: string;
    /**
     * The trigger version. This regulates which `runtime` versions are supported.
     */
    version: string;
}

export interface AttackProtectionBreachedPasswordDetection {
    /**
     * When "adminNotification" is enabled, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
     */
    adminNotificationFrequencies: string[];
    /**
     * Whether breached password detection is active.
     */
    enabled?: boolean;
    /**
     * The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
     */
    method: string;
    /**
     * Action to take when a breached password is detected.
     */
    shields: string[];
}

export interface AttackProtectionBruteForceProtection {
    /**
     * List of trusted IP addresses that will not have attack protection enforced against them.
     */
    allowlists: string[];
    /**
     * Whether brute force attack protections are active.
     */
    enabled?: boolean;
    /**
     * Maximum number of unsuccessful attempts. Only available on public tenants.
     */
    maxAttempts: number;
    /**
     * Determines whether the IP address is used when counting failed attempts. Possible values: `countPerIdentifierAndIp` or `countPerIdentifier`.
     */
    mode: string;
    /**
     * Action to take when a brute force protection threshold is violated. Possible values: `block`, `userNotification`
     */
    shields: string[];
}

export interface AttackProtectionSuspiciousIpThrottling {
    /**
     * List of trusted IP addresses that will not have attack protection enforced against them.
     */
    allowlists: string[];
    /**
     * Whether suspicious IP throttling attack protections are active.
     */
    enabled?: boolean;
    /**
     * Configuration options that apply before every login attempt. Only available on public tenants.
     */
    preLogin: outputs.AttackProtectionSuspiciousIpThrottlingPreLogin;
    /**
     * Configuration options that apply before every user registration attempt. Only available on public tenants.
     */
    preUserRegistration: outputs.AttackProtectionSuspiciousIpThrottlingPreUserRegistration;
    /**
     * Action to take when a suspicious IP throttling threshold is violated. Possible values: `block`, `adminNotification`
     */
    shields: string[];
}

export interface AttackProtectionSuspiciousIpThrottlingPreLogin {
    maxAttempts: number;
    rate: number;
}

export interface AttackProtectionSuspiciousIpThrottlingPreUserRegistration {
    maxAttempts: number;
    rate: number;
}

export interface BrandingColors {
    /**
     * Background color of login pages in hexadecimal.
     */
    pageBackground: string;
    /**
     * Primary button background color in hexadecimal.
     */
    primary: string;
}

export interface BrandingFont {
    /**
     * URL for the custom font.
     */
    url: string;
}

export interface BrandingThemeBorders {
    /**
     * Button border radius. Value needs to be between `1` and `10`.
     */
    buttonBorderRadius: number;
    /**
     * Button border weight. Value needs to be between `0` and `10`.
     */
    buttonBorderWeight: number;
    /**
     * Buttons style. Available options: `pill`, `rounded`, `sharp`.
     */
    buttonsStyle: string;
    /**
     * Input border radius. Value needs to be between `0` and `10`.
     */
    inputBorderRadius: number;
    /**
     * Input border weight. Value needs to be between `0` and `3`.
     */
    inputBorderWeight: number;
    /**
     * Inputs style. Available options: `pill`, `rounded`, `sharp`.
     */
    inputsStyle: string;
    /**
     * Show widget shadow.
     */
    showWidgetShadow: boolean;
    /**
     * Widget border weight. Value needs to be between `0` and `10`.
     */
    widgetBorderWeight: number;
    /**
     * Widget corner radius. Value needs to be between `0` and `50`.
     */
    widgetCornerRadius: number;
}

export interface BrandingThemeColors {
    /**
     * Base focus color.
     */
    baseFocusColor?: string;
    /**
     * Base hover color.
     */
    baseHoverColor?: string;
    /**
     * Body text.
     */
    bodyText: string;
    /**
     * Error.
     */
    error: string;
    /**
     * Header.
     */
    header: string;
    /**
     * Icons.
     */
    icons: string;
    /**
     * Input background.
     */
    inputBackground: string;
    /**
     * Input border.
     */
    inputBorder: string;
    /**
     * Input filled text.
     */
    inputFilledText: string;
    /**
     * Input labels & placeholders.
     */
    inputLabelsPlaceholders: string;
    /**
     * Links & focused components.
     */
    linksFocusedComponents: string;
    /**
     * Primary button.
     */
    primaryButton: string;
    /**
     * Primary button label.
     */
    primaryButtonLabel: string;
    /**
     * Secondary button border.
     */
    secondaryButtonBorder: string;
    /**
     * Secondary button label.
     */
    secondaryButtonLabel: string;
    /**
     * Success.
     */
    success: string;
    /**
     * Widget background.
     */
    widgetBackground: string;
    /**
     * Widget border.
     */
    widgetBorder: string;
}

export interface BrandingThemeFonts {
    /**
     * Body text.
     */
    bodyText: outputs.BrandingThemeFontsBodyText;
    /**
     * Buttons text.
     */
    buttonsText: outputs.BrandingThemeFontsButtonsText;
    /**
     * Font URL.
     */
    fontUrl: string;
    /**
     * Input labels.
     */
    inputLabels: outputs.BrandingThemeFontsInputLabels;
    /**
     * Links.
     */
    links: outputs.BrandingThemeFontsLinks;
    /**
     * Links style.
     */
    linksStyle: string;
    /**
     * Reference text size. Value needs to be between `12` and `24`.
     */
    referenceTextSize: number;
    /**
     * Subtitle.
     */
    subtitle: outputs.BrandingThemeFontsSubtitle;
    /**
     * Title.
     */
    title: outputs.BrandingThemeFontsTitle;
}

export interface BrandingThemeFontsBodyText {
    bold: boolean;
    size: number;
}

export interface BrandingThemeFontsButtonsText {
    bold: boolean;
    size: number;
}

export interface BrandingThemeFontsInputLabels {
    bold: boolean;
    size: number;
}

export interface BrandingThemeFontsLinks {
    bold: boolean;
    size: number;
}

export interface BrandingThemeFontsSubtitle {
    bold: boolean;
    size: number;
}

export interface BrandingThemeFontsTitle {
    bold: boolean;
    size: number;
}

export interface BrandingThemePageBackground {
    /**
     * Background color.
     */
    backgroundColor: string;
    /**
     * Background image url.
     */
    backgroundImageUrl: string;
    /**
     * Page layout. Available options: `center`, `left`, `right`.
     */
    pageLayout: string;
}

export interface BrandingThemeWidget {
    /**
     * Header text alignment. Available options: `center`, `left`, `right`.
     */
    headerTextAlignment: string;
    /**
     * Logo height. Value needs to be between `1` and `100`.
     */
    logoHeight: number;
    /**
     * Logo position. Available options: `center`, `left`, `right`, `none`.
     */
    logoPosition: string;
    /**
     * Logo url.
     */
    logoUrl: string;
    /**
     * Social buttons layout.  Available options: `bottom`, `top`.
     */
    socialButtonsLayout: string;
}

export interface BrandingUniversalLogin {
    /**
     * The body of login pages.
     */
    body: string;
}

export interface ClientAddons {
    aws?: {[key: string]: any};
    azureBlob?: {[key: string]: any};
    azureSb?: {[key: string]: any};
    box?: {[key: string]: any};
    cloudbees?: {[key: string]: any};
    concur?: {[key: string]: any};
    dropbox?: {[key: string]: any};
    echosign?: {[key: string]: any};
    egnyte?: {[key: string]: any};
    firebase?: {[key: string]: any};
    layer?: {[key: string]: any};
    mscrm?: {[key: string]: any};
    newrelic?: {[key: string]: any};
    office365?: {[key: string]: any};
    rms?: {[key: string]: any};
    salesforce?: {[key: string]: any};
    salesforceApi?: {[key: string]: any};
    salesforceSandboxApi?: {[key: string]: any};
    /**
     * Configuration settings for a SAML add-on.
     */
    samlp?: outputs.ClientAddonsSamlp;
    sapApi?: {[key: string]: any};
    sentry?: {[key: string]: any};
    sharepoint?: {[key: string]: any};
    slack?: {[key: string]: any};
    springcm?: {[key: string]: any};
    wams?: {[key: string]: any};
    /**
     * WS-Fed (WIF) addon indicator. Actual configuration is stored in callback and `clientAliases` properties on the client.
     */
    wsfed?: {[key: string]: any};
    zendesk?: {[key: string]: any};
    zoom?: {[key: string]: any};
}

export interface ClientAddonsSamlp {
    audience?: string;
    authnContextClassRef?: string;
    binding?: string;
    createUpnClaim?: boolean;
    destination?: string;
    digestAlgorithm?: string;
    includeAttributeNameFormat?: boolean;
    issuer?: string;
    lifetimeInSeconds?: number;
    logout?: {[key: string]: any};
    mapIdentities?: boolean;
    mapUnknownClaimsAsIs?: boolean;
    mappings?: {[key: string]: any};
    nameIdentifierFormat?: string;
    nameIdentifierProbes?: string[];
    passthroughClaimsWithNoMapping?: boolean;
    recipient?: string;
    signResponse?: boolean;
    signatureAlgorithm?: string;
    signingCert?: string;
    typedAttributes?: boolean;
}

export interface ClientJwtConfiguration {
    /**
     * Algorithm used to sign JWTs.
     */
    alg?: string;
    /**
     * Number of seconds during which the JWT will be valid.
     */
    lifetimeInSeconds: number;
    /**
     * Permissions (scopes) included in JWTs.
     */
    scopes?: {[key: string]: string};
    /**
     * Indicates whether the client secret is Base64-encoded.
     */
    secretEncoded: boolean;
}

export interface ClientMobile {
    /**
     * Configuration settings for Android native apps.
     */
    android: outputs.ClientMobileAndroid;
    /**
     * Configuration settings for i0S native apps.
     */
    ios: outputs.ClientMobileIos;
}

export interface ClientMobileAndroid {
    appPackageName?: string;
    sha256CertFingerprints?: string[];
}

export interface ClientMobileIos {
    appBundleIdentifier?: string;
    teamId?: string;
}

export interface ClientNativeSocialLogin {
    apple: outputs.ClientNativeSocialLoginApple;
    facebook: outputs.ClientNativeSocialLoginFacebook;
}

export interface ClientNativeSocialLoginApple {
    enabled?: boolean;
}

export interface ClientNativeSocialLoginFacebook {
    enabled?: boolean;
}

export interface ClientRefreshToken {
    /**
     * Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
     */
    expirationType: string;
    /**
     * The time in seconds after which inactive refresh tokens will expire.
     */
    idleTokenLifetime: number;
    /**
     * Whether inactive refresh tokens should remain valid indefinitely.
     */
    infiniteIdleTokenLifetime: boolean;
    /**
     * Whether refresh tokens should remain valid indefinitely. If false, `tokenLifetime` should also be set.
     */
    infiniteTokenLifetime: boolean;
    /**
     * The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
     */
    leeway: number;
    /**
     * Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
     */
    rotationType: string;
    /**
     * The absolute lifetime of a refresh token in seconds.
     */
    tokenLifetime: number;
}

export interface ConnectionOptions {
    /**
     * ADFS Metadata source.
     */
    adfsServer?: string;
    /**
     * List of allowed audiences.
     */
    allowedAudiences: string[];
    /**
     * Enable API Access to users.
     */
    apiEnableUsers?: boolean;
    /**
     * App ID.
     */
    appId?: string;
    /**
     * Query string parameters to be included as part of the generated passwordless email link.
     */
    authParams?: {[key: string]: string};
    /**
     * Authorization endpoint.
     */
    authorizationEndpoint?: string;
    /**
     * Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
     */
    bruteForceProtection?: boolean;
    /**
     * The strategy's client ID.
     */
    clientId?: string;
    /**
     * The strategy's client secret.
     */
    clientSecret?: string;
    /**
     * Salesforce community base URL.
     */
    communityBaseUrl?: string;
    /**
     * A case-sensitive map of key value pairs used as configuration variables for the `customScript`.
     */
    configuration?: {[key: string]: any};
    /**
     * A map of scripts used to integrate with a custom database.
     */
    customScripts?: {[key: string]: string};
    /**
     * When enabled, additional debug information will be generated.
     */
    debug?: boolean;
    /**
     * Sign Request Algorithm Digest.
     */
    digestAlgorithm?: string;
    /**
     * Indicates whether to disable the cache or not.
     */
    disableCache?: boolean;
    /**
     * When enabled, will disable sign out.
     */
    disableSignOut?: boolean;
    /**
     * Indicates whether to allow user sign-ups to your application.
     */
    disableSignup?: boolean;
    /**
     * OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
     */
    discoveryUrl?: string;
    /**
     * Domain name.
     */
    domain?: string;
    /**
     * List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
     */
    domainAliases: string[];
    /**
     * Set to `true` to use a legacy user store.
     */
    enabledDatabaseCustomization?: boolean;
    /**
     * Custom Entity ID for the connection.
     */
    entityId?: string;
    /**
     * If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
     */
    fieldsMap?: string;
    /**
     * Specifies whether or not request info should be forwarded to sms gateway.
     */
    forwardRequestInfo?: boolean;
    /**
     * Address to use as the sender.
     */
    from?: string;
    /**
     * Defines the parameters used to generate the auth token for the custom gateway.
     */
    gatewayAuthentication?: outputs.ConnectionOptionsGatewayAuthentication;
    /**
     * Defines a custom sms gateway to use instead of Twilio.
     */
    gatewayUrl?: string;
    /**
     * Icon URL.
     */
    iconUrl?: string;
    /**
     * Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
     */
    identityApi?: string;
    /**
     * Configuration options for IDP Initiated Authentication. This is an object with the properties: `clientId`, `clientProtocol`, and `clientAuthorizeQuery`.
     */
    idpInitiated?: outputs.ConnectionOptionsIdpInitiated;
    /**
     * Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
     */
    importMode?: boolean;
    /**
     * A list of IPs.
     */
    ips: string[];
    /**
     * Issuer URL, e.g. `https://auth.example.com`.
     */
    issuer?: string;
    /**
     * JWKS URI.
     */
    jwksUri?: string;
    /**
     * Apple Key ID.
     */
    keyId?: string;
    /**
     * Maximum number of groups to retrieve.
     */
    maxGroupsToRetrieve?: string;
    /**
     * SID for Copilot. Used when SMS Source is Copilot.
     */
    messagingServiceSid?: string;
    /**
     * The URL of the SAML metadata document.
     */
    metadataUrl?: string;
    /**
     * The XML content for the SAML metadata document.
     */
    metadataXml?: string;
    /**
     * Configuration options for multifactor authentication.
     */
    mfa: outputs.ConnectionOptionsMfa;
    /**
     * The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
     */
    name?: string;
    /**
     * If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
     */
    nonPersistentAttrs: string[];
    /**
     * Configuration settings for password complexity.
     */
    passwordComplexityOptions: outputs.ConnectionOptionsPasswordComplexityOptions;
    /**
     * Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
     */
    passwordDictionary: outputs.ConnectionOptionsPasswordDictionary;
    /**
     * Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
     */
    passwordHistories: outputs.ConnectionOptionsPasswordHistory[];
    /**
     * Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
     */
    passwordNoPersonalInfo: outputs.ConnectionOptionsPasswordNoPersonalInfo;
    /**
     * Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
     */
    passwordPolicy: string;
    /**
     * Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
     */
    pkceEnabled?: boolean;
    /**
     * The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
     */
    protocolBinding?: string;
    /**
     * Defines the custom `smsGateway` provider.
     */
    provider?: string;
    /**
     * Template that formats the SAML request.
     */
    requestTemplate?: string;
    /**
     * Indicates whether the user is required to provide a username in addition to an email address.
     */
    requiresUsername?: boolean;
    /**
     * Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basicProfile`, `extProfile`, `extNestedGroups`, etc.
     */
    scopes: string[];
    /**
     * A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
     */
    scripts?: {[key: string]: string};
    /**
     * Determines whether the 'name', 'given*name', 'family*name', 'nickname', and 'picture' attributes can be independently updated when using an external IdP. Possible values are 'on*each*login' (default value, it configures the connection to automatically update the root attributes from the external IdP with each user login. When this setting is used, root attributes cannot be independently updated), 'on*first*login' (configures the connection to only set the root attributes on first login, allowing them to be independently updated thereafter).
     */
    setUserRootAttributes: string;
    /**
     * Choose how Auth0 sets the emailVerified field in the user profile.
     */
    shouldTrustEmailVerifiedConnection?: string;
    /**
     * SAML single login URL for the connection.
     */
    signInEndpoint?: string;
    /**
     * SAML single logout URL for the connection.
     */
    signOutEndpoint?: string;
    /**
     * When enabled, the SAML authentication request will be signed.
     */
    signSamlRequest?: boolean;
    /**
     * Sign Request Algorithm.
     */
    signatureAlgorithm?: string;
    /**
     * X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
     */
    signingCert?: string;
    /**
     * The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     */
    signingKey?: outputs.ConnectionOptionsSigningKey;
    /**
     * Version 1 is deprecated, use version 2.
     */
    strategyVersion: number;
    /**
     * Subject line of the email.
     */
    subject?: string;
    /**
     * Syntax of the template body.
     */
    syntax?: string;
    /**
     * Apple Team ID.
     */
    teamId?: string;
    /**
     * Body of the template.
     */
    template?: string;
    /**
     * Tenant domain name.
     */
    tenantDomain?: string;
    /**
     * Token endpoint.
     */
    tokenEndpoint?: string;
    /**
     * Configuration options for one-time passwords.
     */
    totp?: outputs.ConnectionOptionsTotp;
    /**
     * SID for your Twilio account.
     */
    twilioSid?: string;
    /**
     * AuthToken for your Twilio account.
     */
    twilioToken?: string;
    /**
     * Value can be `backChannel` or `frontChannel`.
     */
    type?: string;
    /**
     * You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
     */
    upstreamParams?: string;
    /**
     * Indicates whether to use cert auth or not.
     */
    useCertAuth?: boolean;
    /**
     * Indicates whether to use Kerberos or not.
     */
    useKerberos?: boolean;
    /**
     * Whether to use WS-Fed.
     */
    useWsfed?: boolean;
    /**
     * Attribute in the SAML token that will be mapped to the userId property in Auth0.
     */
    userIdAttribute?: string;
    /**
     * User info endpoint.
     */
    userinfoEndpoint?: string;
    /**
     * Validation of the minimum and maximum values allowed for a user to have as username.
     */
    validation?: outputs.ConnectionOptionsValidation;
    /**
     * Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
     */
    waadCommonEndpoint?: boolean;
    /**
     * Protocol to use.
     */
    waadProtocol?: string;
}

export interface ConnectionOptionsGatewayAuthentication {
    audience?: string;
    method?: string;
    secret?: string;
    secretBase64Encoded?: boolean;
    subject?: string;
}

export interface ConnectionOptionsIdpInitiated {
    clientAuthorizeQuery?: string;
    clientId?: string;
    clientProtocol?: string;
}

export interface ConnectionOptionsMfa {
    active?: boolean;
    returnEnrollSettings?: boolean;
}

export interface ConnectionOptionsPasswordComplexityOptions {
    minLength?: number;
}

export interface ConnectionOptionsPasswordDictionary {
    dictionaries?: string[];
    enable?: boolean;
}

export interface ConnectionOptionsPasswordHistory {
    enable?: boolean;
    size?: number;
}

export interface ConnectionOptionsPasswordNoPersonalInfo {
    enable?: boolean;
}

export interface ConnectionOptionsSigningKey {
    cert: string;
    key: string;
}

export interface ConnectionOptionsTotp {
    length?: number;
    timeStep?: number;
}

export interface ConnectionOptionsValidation {
    username?: outputs.ConnectionOptionsValidationUsername;
}

export interface ConnectionOptionsValidationUsername {
    max?: number;
    min?: number;
}

export interface CustomDomainVerification {
    methods: any[];
}

export interface EmailCredentials {
    /**
     * AWS Access Key ID. Used only for AWS.
     */
    accessKeyId?: string;
    /**
     * API Key for your email service. Will always be encrypted in our database.
     */
    apiKey?: string;
    /**
     * API User for your email service.
     *
     * @deprecated This field is not accepted by the API any more so it will be removed soon.
     */
    apiUser?: string;
    /**
     * Domain name.
     */
    domain?: string;
    /**
     * Default region. Used only for AWS, Mailgun, and SparkPost.
     */
    region?: string;
    /**
     * AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
     */
    secretAccessKey?: string;
    /**
     * Hostname or IP address of your SMTP server. Used only for SMTP.
     */
    smtpHost?: string;
    /**
     * SMTP password. Used only for SMTP.
     */
    smtpPass?: string;
    /**
     * Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
     */
    smtpPort?: number;
    /**
     * SMTP username. Used only for SMTP.
     */
    smtpUser?: string;
}

export interface EmailSettings {
    /**
     * Headers settings for the `smtp` email provider.
     */
    headers?: outputs.EmailSettingsHeaders;
    /**
     * Message settings for the `mandrill` or `ses` email provider.
     */
    message?: outputs.EmailSettingsMessage;
}

export interface EmailSettingsHeaders {
    xMcViewContentLink?: string;
    xSesConfigurationSet?: string;
}

export interface EmailSettingsMessage {
    configurationSetName?: string;
    viewContentLink?: boolean;
}

export interface GetClientAddon {
    aws: {[key: string]: any};
    azureBlob: {[key: string]: any};
    azureSb: {[key: string]: any};
    box: {[key: string]: any};
    cloudbees: {[key: string]: any};
    concur: {[key: string]: any};
    dropbox: {[key: string]: any};
    echosign: {[key: string]: any};
    egnyte: {[key: string]: any};
    firebase: {[key: string]: any};
    layer: {[key: string]: any};
    mscrm: {[key: string]: any};
    newrelic: {[key: string]: any};
    office365: {[key: string]: any};
    rms: {[key: string]: any};
    salesforce: {[key: string]: any};
    salesforceApi: {[key: string]: any};
    salesforceSandboxApi: {[key: string]: any};
    samlps: outputs.GetClientAddonSamlp[];
    sapApi: {[key: string]: any};
    sentry: {[key: string]: any};
    sharepoint: {[key: string]: any};
    slack: {[key: string]: any};
    springcm: {[key: string]: any};
    wams: {[key: string]: any};
    wsfed: {[key: string]: any};
    zendesk: {[key: string]: any};
    zoom: {[key: string]: any};
}

export interface GetClientAddonSamlp {
    audience: string;
    authnContextClassRef: string;
    binding: string;
    createUpnClaim: boolean;
    destination: string;
    digestAlgorithm: string;
    includeAttributeNameFormat: boolean;
    issuer: string;
    lifetimeInSeconds: number;
    logout: {[key: string]: any};
    mapIdentities: boolean;
    mapUnknownClaimsAsIs: boolean;
    mappings: {[key: string]: any};
    nameIdentifierFormat: string;
    nameIdentifierProbes: string[];
    passthroughClaimsWithNoMapping: boolean;
    recipient: string;
    signResponse: boolean;
    signatureAlgorithm: string;
    signingCert: string;
    typedAttributes: boolean;
}

export interface GetClientJwtConfiguration {
    alg: string;
    lifetimeInSeconds: number;
    scopes: {[key: string]: string};
    secretEncoded: boolean;
}

export interface GetClientMobile {
    androids: outputs.GetClientMobileAndroid[];
    ios: outputs.GetClientMobileIo[];
}

export interface GetClientMobileAndroid {
    appPackageName: string;
    sha256CertFingerprints: string[];
}

export interface GetClientMobileIo {
    appBundleIdentifier: string;
    teamId: string;
}

export interface GetClientNativeSocialLogin {
    apples: outputs.GetClientNativeSocialLoginApple[];
    facebooks: outputs.GetClientNativeSocialLoginFacebook[];
}

export interface GetClientNativeSocialLoginApple {
    enabled: boolean;
}

export interface GetClientNativeSocialLoginFacebook {
    enabled: boolean;
}

export interface GetClientRefreshToken {
    expirationType: string;
    idleTokenLifetime: number;
    infiniteIdleTokenLifetime: boolean;
    infiniteTokenLifetime: boolean;
    leeway: number;
    rotationType: string;
    tokenLifetime: number;
}

export interface GetGlobalClientAddon {
    aws: {[key: string]: any};
    azureBlob: {[key: string]: any};
    azureSb: {[key: string]: any};
    box: {[key: string]: any};
    cloudbees: {[key: string]: any};
    concur: {[key: string]: any};
    dropbox: {[key: string]: any};
    echosign: {[key: string]: any};
    egnyte: {[key: string]: any};
    firebase: {[key: string]: any};
    layer: {[key: string]: any};
    mscrm: {[key: string]: any};
    newrelic: {[key: string]: any};
    office365: {[key: string]: any};
    rms: {[key: string]: any};
    salesforce: {[key: string]: any};
    salesforceApi: {[key: string]: any};
    salesforceSandboxApi: {[key: string]: any};
    samlps: outputs.GetGlobalClientAddonSamlp[];
    sapApi: {[key: string]: any};
    sentry: {[key: string]: any};
    sharepoint: {[key: string]: any};
    slack: {[key: string]: any};
    springcm: {[key: string]: any};
    wams: {[key: string]: any};
    wsfed: {[key: string]: any};
    zendesk: {[key: string]: any};
    zoom: {[key: string]: any};
}

export interface GetGlobalClientAddonSamlp {
    audience: string;
    authnContextClassRef: string;
    binding: string;
    createUpnClaim: boolean;
    destination: string;
    digestAlgorithm: string;
    includeAttributeNameFormat: boolean;
    issuer: string;
    lifetimeInSeconds: number;
    logout: {[key: string]: any};
    mapIdentities: boolean;
    mapUnknownClaimsAsIs: boolean;
    mappings: {[key: string]: any};
    nameIdentifierFormat: string;
    nameIdentifierProbes: string[];
    passthroughClaimsWithNoMapping: boolean;
    recipient: string;
    signResponse: boolean;
    signatureAlgorithm: string;
    signingCert: string;
    typedAttributes: boolean;
}

export interface GetGlobalClientJwtConfiguration {
    alg: string;
    lifetimeInSeconds: number;
    scopes: {[key: string]: string};
    secretEncoded: boolean;
}

export interface GetGlobalClientMobile {
    androids: outputs.GetGlobalClientMobileAndroid[];
    ios: outputs.GetGlobalClientMobileIo[];
}

export interface GetGlobalClientMobileAndroid {
    appPackageName: string;
    sha256CertFingerprints: string[];
}

export interface GetGlobalClientMobileIo {
    appBundleIdentifier: string;
    teamId: string;
}

export interface GetGlobalClientNativeSocialLogin {
    apples: outputs.GetGlobalClientNativeSocialLoginApple[];
    facebooks: outputs.GetGlobalClientNativeSocialLoginFacebook[];
}

export interface GetGlobalClientNativeSocialLoginApple {
    enabled: boolean;
}

export interface GetGlobalClientNativeSocialLoginFacebook {
    enabled: boolean;
}

export interface GetGlobalClientRefreshToken {
    expirationType: string;
    idleTokenLifetime: number;
    infiniteIdleTokenLifetime: boolean;
    infiniteTokenLifetime: boolean;
    leeway: number;
    rotationType: string;
    tokenLifetime: number;
}

export interface GlobalClientAddons {
    aws?: {[key: string]: any};
    azureBlob?: {[key: string]: any};
    azureSb?: {[key: string]: any};
    box?: {[key: string]: any};
    cloudbees?: {[key: string]: any};
    concur?: {[key: string]: any};
    dropbox?: {[key: string]: any};
    echosign?: {[key: string]: any};
    egnyte?: {[key: string]: any};
    firebase?: {[key: string]: any};
    layer?: {[key: string]: any};
    mscrm?: {[key: string]: any};
    newrelic?: {[key: string]: any};
    office365?: {[key: string]: any};
    rms?: {[key: string]: any};
    salesforce?: {[key: string]: any};
    salesforceApi?: {[key: string]: any};
    salesforceSandboxApi?: {[key: string]: any};
    /**
     * Configuration settings for a SAML add-on.
     */
    samlp?: outputs.GlobalClientAddonsSamlp;
    sapApi?: {[key: string]: any};
    sentry?: {[key: string]: any};
    sharepoint?: {[key: string]: any};
    slack?: {[key: string]: any};
    springcm?: {[key: string]: any};
    wams?: {[key: string]: any};
    /**
     * WS-Fed (WIF) addon indicator. Actual configuration is stored in callback and `clientAliases` properties on the client.
     */
    wsfed?: {[key: string]: any};
    zendesk?: {[key: string]: any};
    zoom?: {[key: string]: any};
}

export interface GlobalClientAddonsSamlp {
    audience?: string;
    authnContextClassRef?: string;
    binding?: string;
    createUpnClaim?: boolean;
    destination?: string;
    digestAlgorithm?: string;
    includeAttributeNameFormat?: boolean;
    issuer?: string;
    lifetimeInSeconds?: number;
    logout?: {[key: string]: any};
    mapIdentities?: boolean;
    mapUnknownClaimsAsIs?: boolean;
    mappings?: {[key: string]: any};
    nameIdentifierFormat?: string;
    nameIdentifierProbes?: string[];
    passthroughClaimsWithNoMapping?: boolean;
    recipient?: string;
    signResponse?: boolean;
    signatureAlgorithm?: string;
    signingCert?: string;
    typedAttributes?: boolean;
}

export interface GlobalClientJwtConfiguration {
    /**
     * Algorithm used to sign JWTs.
     */
    alg?: string;
    /**
     * Number of seconds during which the JWT will be valid.
     */
    lifetimeInSeconds: number;
    /**
     * Permissions (scopes) included in JWTs.
     */
    scopes?: {[key: string]: string};
    /**
     * Indicates whether the client secret is Base64-encoded.
     */
    secretEncoded: boolean;
}

export interface GlobalClientMobile {
    /**
     * Configuration settings for Android native apps.
     */
    android: outputs.GlobalClientMobileAndroid;
    /**
     * Configuration settings for i0S native apps.
     */
    ios: outputs.GlobalClientMobileIos;
}

export interface GlobalClientMobileAndroid {
    appPackageName?: string;
    sha256CertFingerprints?: string[];
}

export interface GlobalClientMobileIos {
    appBundleIdentifier?: string;
    teamId?: string;
}

export interface GlobalClientNativeSocialLogin {
    apple: outputs.GlobalClientNativeSocialLoginApple;
    facebook: outputs.GlobalClientNativeSocialLoginFacebook;
}

export interface GlobalClientNativeSocialLoginApple {
    enabled?: boolean;
}

export interface GlobalClientNativeSocialLoginFacebook {
    enabled?: boolean;
}

export interface GlobalClientRefreshToken {
    /**
     * Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
     */
    expirationType: string;
    /**
     * The time in seconds after which inactive refresh tokens will expire.
     */
    idleTokenLifetime: number;
    /**
     * Whether inactive refresh tokens should remain valid indefinitely.
     */
    infiniteIdleTokenLifetime: boolean;
    /**
     * Whether refresh tokens should remain valid indefinitely. If false, `tokenLifetime` should also be set.
     */
    infiniteTokenLifetime: boolean;
    /**
     * The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
     */
    leeway: number;
    /**
     * Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
     */
    rotationType: string;
    /**
     * The absolute lifetime of a refresh token in seconds.
     */
    tokenLifetime: number;
}

export interface GuardianDuo {
    /**
     * Indicates whether Duo MFA is enabled.
     */
    enabled: boolean;
    /**
     * Duo API Hostname, see the Duo documentation for more details on Duo setup.
     */
    hostname?: string;
    /**
     * Duo client ID, see the Duo documentation for more details on Duo setup.
     */
    integrationKey?: string;
    /**
     * Duo client secret, see the Duo documentation for more details on Duo setup.
     */
    secretKey?: string;
}

export interface GuardianPhone {
    /**
     * Indicates whether Phone MFA is enabled.
     */
    enabled: boolean;
    /**
     * Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
     */
    messageTypes?: string[];
    /**
     * Options for the various providers.
     */
    options: outputs.GuardianPhoneOptions;
    /**
     * Provider to use, one of `auth0`, `twilio` or `phone-message-hook`.
     */
    provider?: string;
}

export interface GuardianPhoneOptions {
    authToken?: string;
    enrollmentMessage?: string;
    from?: string;
    messagingServiceSid?: string;
    sid?: string;
    verificationMessage?: string;
}

export interface GuardianPush {
    /**
     * Configuration for Amazon SNS.
     */
    amazonSns: outputs.GuardianPushAmazonSns;
    /**
     * Configuration for the Guardian Custom App.
     */
    customApp: outputs.GuardianPushCustomApp;
    /**
     * Indicates whether Push MFA is enabled.
     */
    enabled: boolean;
    /**
     * Provider to use, one of `guardian`, `sns`.
     */
    provider?: string;
}

export interface GuardianPushAmazonSns {
    awsAccessKeyId: string;
    awsRegion: string;
    awsSecretAccessKey: string;
    snsApnsPlatformApplicationArn: string;
    snsGcmPlatformApplicationArn: string;
}

export interface GuardianPushCustomApp {
    appName?: string;
    appleAppLink?: string;
    googleAppLink?: string;
}

export interface GuardianWebauthnPlatform {
    /**
     * Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
     */
    enabled: boolean;
    /**
     * The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
     */
    overrideRelyingParty: boolean;
    /**
     * The Relying Party should be a suffix of the custom domain.
     */
    relyingPartyIdentifier: string;
}

export interface GuardianWebauthnRoaming {
    /**
     * Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
     */
    enabled: boolean;
    /**
     * The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
     */
    overrideRelyingParty: boolean;
    /**
     * The Relying Party should be a suffix of the custom domain.
     */
    relyingPartyIdentifier: string;
    /**
     * User verification, one of `discouraged`, `preferred` or `required`.
     */
    userVerification: string;
}

export interface LogStreamSink {
    /**
     * The AWS Account ID.
     */
    awsAccountId?: string;
    /**
     * Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
     */
    awsPartnerEventSource: string;
    /**
     * The AWS Region, e.g. "us-east-2").
     */
    awsRegion?: string;
    /**
     * Name of the Partner Topic to be used with Azure. Generally should not be specified.
     */
    azurePartnerTopic: string;
    /**
     * The Azure region code, e.g. "ne")
     */
    azureRegion?: string;
    /**
     * The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
     */
    azureResourceGroup?: string;
    /**
     * The unique alphanumeric string that identifies your Azure subscription.
     */
    azureSubscriptionId?: string;
    /**
     * The Datadog API key.
     */
    datadogApiKey?: string;
    /**
     * The Datadog region. Options are ["us", "eu", "us3", "us5"].
     */
    datadogRegion?: string;
    /**
     * Sent in the HTTP "Authorization" header with each request.
     */
    httpAuthorization?: string;
    /**
     * The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
     */
    httpContentFormat?: string;
    /**
     * The "Content-Type" header to send over HTTP. Common value is "application/json".
     */
    httpContentType?: string;
    /**
     * Additional HTTP headers to be included as part of the HTTP request.
     */
    httpCustomHeaders?: {[key: string]: string}[];
    /**
     * The HTTP endpoint to send streaming logs.
     */
    httpEndpoint?: string;
    /**
     * The Mixpanel project ID, found on the Project Settings page.
     */
    mixpanelProjectId?: string;
    /**
     * The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
     */
    mixpanelRegion?: string;
    /**
     * The Mixpanel Service Account password.
     */
    mixpanelServiceAccountPassword?: string;
    /**
     * The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
     */
    mixpanelServiceAccountUsername?: string;
    /**
     * The Splunk domain name.
     */
    splunkDomain?: string;
    /**
     * The Splunk port.
     */
    splunkPort?: string;
    /**
     * This toggle should be turned off when using self-signed certificates.
     */
    splunkSecure?: boolean;
    /**
     * The Splunk access token.
     */
    splunkToken?: string;
    /**
     * Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
     */
    sumoSourceAddress?: string;
}

export interface OrganizationBranding {
    /**
     * Color scheme used to customize the login pages.
     */
    colors?: {[key: string]: string};
    /**
     * URL of logo to display on login page.
     */
    logoUrl?: string;
}

export interface ResourceServerScope {
    /**
     * Description of the permission (scope).
     */
    description?: string;
    /**
     * Name of the permission (scope). Examples include `read:appointments` or `delete:appointments`.
     */
    value: string;
}

export interface RolePermission {
    /**
     * Name of the permission (scope).
     */
    name: string;
    /**
     * Unique identifier for the resource server.
     */
    resourceServerIdentifier: string;
}

export interface TenantChangePassword {
    /**
     * Indicates whether to use the custom change password page.
     */
    enabled: boolean;
    /**
     * HTML format with supported Liquid syntax. Customized content of the change password page.
     */
    html: string;
}

export interface TenantErrorPage {
    /**
     * HTML format with supported Liquid syntax. Customized content of the error page.
     */
    html: string;
    /**
     * Indicates whether to show the link to logs as part of the default error page.
     */
    showLogLink: boolean;
    /**
     * URL to redirect to when an error occurs rather than showing the default error page.
     */
    url: string;
}

export interface TenantFlags {
    /**
     * Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
     */
    allowLegacyDelegationGrantTypes: boolean;
    /**
     * Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
     */
    allowLegacyRoGrantTypes: boolean;
    /**
     * If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
     */
    allowLegacyTokeninfoEndpoint: boolean;
    /**
     * Enables new insights activity page view.
     */
    dashboardInsightsView: boolean;
    /**
     * Enables beta access to log streaming changes.
     */
    dashboardLogStreamsNext: boolean;
    /**
     * Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
     */
    disableClickjackProtectionHeaders: boolean;
    /**
     * Disables SAML fields map fix for bad mappings with repeated attributes.
     */
    disableFieldsMapFix: boolean;
    /**
     * If true, SMS phone numbers will not be obfuscated in Management API GET calls.
     */
    disableManagementApiSmsObfuscation: boolean;
    /**
     * If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
     */
    enableAdfsWaadEmailVerification: boolean;
    /**
     * Indicates whether the APIs section is enabled for the tenant.
     */
    enableApisSection: boolean;
    /**
     * Indicates whether all current connections should be enabled when a new client is created.
     */
    enableClientConnections: boolean;
    /**
     * Indicates whether the tenant allows custom domains in emails.
     */
    enableCustomDomainInEmails: boolean;
    /**
     * Indicates whether the tenant allows dynamic client registration.
     */
    enableDynamicClientRegistration: boolean;
    /**
     * Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
     */
    enableIdtokenApi2: boolean;
    /**
     * Indicates whether to use the older v2 legacy logs search.
     */
    enableLegacyLogsSearchV2: boolean;
    /**
     * Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
     */
    enableLegacyProfile: boolean;
    /**
     * Indicates whether advanced API Authorization scenarios are enabled.
     */
    enablePipeline2: boolean;
    /**
     * Indicates whether the public sign up process shows a `userExists` error if the user already exists.
     */
    enablePublicSignupUserExistsError: boolean;
    /**
     * Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
     */
    noDiscloseEnterpriseConnections: boolean;
    /**
     * Delete underlying grant when a refresh token is revoked via the Authentication API.
     */
    revokeRefreshTokenGrant: boolean;
    /**
     * Indicates whether the tenant uses Universal Login.
     */
    universalLogin: boolean;
    /**
     * Indicates whether to use scope descriptions for consent.
     */
    useScopeDescriptionsForConsent: boolean;
}

export interface TenantGuardianMfaPage {
    /**
     * Indicates whether to use the custom Guardian page.
     */
    enabled: boolean;
    /**
     * HTML format with supported Liquid syntax. Customized content of the Guardian page.
     */
    html: string;
}

export interface TenantSessionCookie {
    /**
     * Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
     */
    mode?: string;
}

export interface TenantUniversalLogin {
    /**
     * Configuration settings for Universal Login colors.
     */
    colors?: outputs.TenantUniversalLoginColors;
}

export interface TenantUniversalLoginColors {
    pageBackground: string;
    primary: string;
}

export interface TriggerBindingAction {
    /**
     * The name of an action.
     */
    displayName: string;
    /**
     * Action ID.
     */
    id: string;
}

