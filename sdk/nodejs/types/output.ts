// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ActionDependency {
    /**
     * Dependency name, e.g. `lodash`.
     */
    name: string;
    /**
     * Dependency version, e.g. `latest` or `4.17.21`.
     */
    version: string;
}

export interface ActionSecret {
    /**
     * Secret name.
     */
    name: string;
    /**
     * Secret value.
     */
    value: string;
}

export interface ActionSupportedTriggers {
    /**
     * The trigger ID.
     */
    id: string;
    /**
     * The trigger version. This regulates which `runtime` versions are supported.
     */
    version: string;
}

export interface AttackProtectionBreachedPasswordDetection {
    /**
     * When "adminNotification" is enabled, determines how often email notifications are sent. Possible values: `immediately`, `daily`, `weekly`, `monthly`.
     */
    adminNotificationFrequencies: string[];
    /**
     * Whether breached password detection is active.
     */
    enabled?: boolean;
    /**
     * The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard. Possible values: `standard`, `enhanced`.
     */
    method: string;
    /**
     * Configuration options that apply before every user registration attempt. Only available on public tenants.
     */
    preUserRegistration: outputs.AttackProtectionBreachedPasswordDetectionPreUserRegistration;
    /**
     * Action to take when a breached password is detected.
     */
    shields: string[];
}

export interface AttackProtectionBreachedPasswordDetectionPreUserRegistration {
    shields: string[];
}

export interface AttackProtectionBruteForceProtection {
    /**
     * List of trusted IP addresses that will not have attack protection enforced against them.
     */
    allowlists: string[];
    /**
     * Whether brute force attack protections are active.
     */
    enabled?: boolean;
    /**
     * Maximum number of unsuccessful attempts. Only available on public tenants.
     */
    maxAttempts: number;
    /**
     * Determines whether the IP address is used when counting failed attempts. Possible values: `countPerIdentifierAndIp` or `countPerIdentifier`.
     */
    mode: string;
    /**
     * Action to take when a brute force protection threshold is violated. Possible values: `block`, `userNotification`
     */
    shields: string[];
}

export interface AttackProtectionSuspiciousIpThrottling {
    /**
     * List of trusted IP addresses that will not have attack protection enforced against them.
     */
    allowlists: string[];
    /**
     * Whether suspicious IP throttling attack protections are active.
     */
    enabled?: boolean;
    /**
     * Configuration options that apply before every login attempt. Only available on public tenants.
     */
    preLogin: outputs.AttackProtectionSuspiciousIpThrottlingPreLogin;
    /**
     * Configuration options that apply before every user registration attempt. Only available on public tenants.
     */
    preUserRegistration: outputs.AttackProtectionSuspiciousIpThrottlingPreUserRegistration;
    /**
     * Action to take when a suspicious IP throttling threshold is violated. Possible values: `block`, `adminNotification`
     */
    shields: string[];
}

export interface AttackProtectionSuspiciousIpThrottlingPreLogin {
    maxAttempts: number;
    rate: number;
}

export interface AttackProtectionSuspiciousIpThrottlingPreUserRegistration {
    maxAttempts: number;
    rate: number;
}

export interface BrandingColors {
    /**
     * Background color of login pages in hexadecimal.
     */
    pageBackground: string;
    /**
     * Primary button background color in hexadecimal.
     */
    primary: string;
}

export interface BrandingFont {
    /**
     * URL for the custom font.
     */
    url: string;
}

export interface BrandingThemeBorders {
    /**
     * Button border radius. Value needs to be between `1` and `10`. Defaults to `3.0`.
     */
    buttonBorderRadius?: number;
    /**
     * Button border weight. Value needs to be between `0` and `10`. Defaults to `1.0`.
     */
    buttonBorderWeight?: number;
    /**
     * Buttons style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
     */
    buttonsStyle?: string;
    /**
     * Input border radius. Value needs to be between `0` and `10`. Defaults to `3.0`.
     */
    inputBorderRadius?: number;
    /**
     * Input border weight. Value needs to be between `0` and `3`. Defaults to `1.0`.
     */
    inputBorderWeight?: number;
    /**
     * Inputs style. Available options: `pill`, `rounded`, `sharp`. Defaults to `rounded`.
     */
    inputsStyle?: string;
    /**
     * Show widget shadow. Defaults to `true`.
     */
    showWidgetShadow?: boolean;
    /**
     * Widget border weight. Value needs to be between `0` and `10`. Defaults to `0.0`.
     */
    widgetBorderWeight?: number;
    /**
     * Widget corner radius. Value needs to be between `0` and `50`. Defaults to `5.0`.
     */
    widgetCornerRadius?: number;
}

export interface BrandingThemeColors {
    /**
     * Base focus color. Defaults to `#635dff`.
     */
    baseFocusColor?: string;
    /**
     * Base hover color. Defaults to `#000000`.
     */
    baseHoverColor?: string;
    /**
     * Body text. Defaults to `#1e212a`.
     */
    bodyText?: string;
    /**
     * Error. Defaults to `#d03c38`.
     */
    error?: string;
    /**
     * Header. Defaults to `#1e212a`.
     */
    header?: string;
    /**
     * Icons. Defaults to `#65676e`.
     */
    icons?: string;
    /**
     * Input background. Defaults to `#ffffff`.
     */
    inputBackground?: string;
    /**
     * Input border. Defaults to `#c9cace`.
     */
    inputBorder?: string;
    /**
     * Input filled text. Defaults to `#000000`.
     */
    inputFilledText?: string;
    /**
     * Input labels & placeholders. Defaults to `#65676e`.
     */
    inputLabelsPlaceholders?: string;
    /**
     * Links & focused components. Defaults to `#635dff`.
     */
    linksFocusedComponents?: string;
    /**
     * Primary button. Defaults to `#635dff`.
     */
    primaryButton?: string;
    /**
     * Primary button label. Defaults to `#ffffff`.
     */
    primaryButtonLabel?: string;
    /**
     * Secondary button border. Defaults to `#c9cace`.
     */
    secondaryButtonBorder?: string;
    /**
     * Secondary button label. Defaults to `#1e212a`.
     */
    secondaryButtonLabel?: string;
    /**
     * Success. Defaults to `#13a688`.
     */
    success?: string;
    /**
     * Widget background. Defaults to `#ffffff`.
     */
    widgetBackground?: string;
    /**
     * Widget border. Defaults to `#c9cace`.
     */
    widgetBorder?: string;
}

export interface BrandingThemeFonts {
    /**
     * Body text.
     */
    bodyText: outputs.BrandingThemeFontsBodyText;
    /**
     * Buttons text.
     */
    buttonsText: outputs.BrandingThemeFontsButtonsText;
    /**
     * Font URL. Defaults to an empty string.
     */
    fontUrl?: string;
    /**
     * Input labels.
     */
    inputLabels: outputs.BrandingThemeFontsInputLabels;
    /**
     * Links.
     */
    links: outputs.BrandingThemeFontsLinks;
    /**
     * Links style. Defaults to `normal`.
     */
    linksStyle?: string;
    /**
     * Reference text size. Value needs to be between `12` and `24`. Defaults to `16.0`.
     */
    referenceTextSize?: number;
    /**
     * Subtitle.
     */
    subtitle: outputs.BrandingThemeFontsSubtitle;
    /**
     * Title.
     */
    title: outputs.BrandingThemeFontsTitle;
}

export interface BrandingThemeFontsBodyText {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemeFontsButtonsText {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemeFontsInputLabels {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemeFontsLinks {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemeFontsSubtitle {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemeFontsTitle {
    bold?: boolean;
    size?: number;
}

export interface BrandingThemePageBackground {
    /**
     * Background color. Defaults to `#000000`.
     */
    backgroundColor?: string;
    /**
     * Background image url. Defaults to an empty string.
     */
    backgroundImageUrl?: string;
    /**
     * Page layout. Available options: `center`, `left`, `right`. Defaults to `center`.
     */
    pageLayout?: string;
}

export interface BrandingThemeWidget {
    /**
     * Header text alignment. Available options: `center`, `left`, `right`. Defaults to `center`.
     */
    headerTextAlignment?: string;
    /**
     * Logo height. Value needs to be between `1` and `100`. Defaults to `52.0`.
     */
    logoHeight?: number;
    /**
     * Logo position. Available options: `center`, `left`, `right`, `none`. Defaults to `center`.
     */
    logoPosition?: string;
    /**
     * Logo url. Defaults to an empty string.
     */
    logoUrl?: string;
    /**
     * Social buttons layout. Available options: `bottom`, `top`. Defaults to `bottom`.
     */
    socialButtonsLayout?: string;
}

export interface BrandingUniversalLogin {
    /**
     * The html template for the New Universal Login Experience.
     */
    body: string;
}

export interface ClientAddons {
    aws?: {[key: string]: any};
    azureBlob?: {[key: string]: any};
    azureSb?: {[key: string]: any};
    box?: {[key: string]: any};
    cloudbees?: {[key: string]: any};
    concur?: {[key: string]: any};
    dropbox?: {[key: string]: any};
    echosign?: {[key: string]: any};
    egnyte?: {[key: string]: any};
    firebase?: {[key: string]: any};
    layer?: {[key: string]: any};
    mscrm?: {[key: string]: any};
    newrelic?: {[key: string]: any};
    office365?: {[key: string]: any};
    rms?: {[key: string]: any};
    salesforce?: {[key: string]: any};
    salesforceApi?: {[key: string]: any};
    salesforceSandboxApi?: {[key: string]: any};
    /**
     * Configuration settings for a SAML add-on.
     */
    samlp?: outputs.ClientAddonsSamlp;
    sapApi?: {[key: string]: any};
    sentry?: {[key: string]: any};
    sharepoint?: {[key: string]: any};
    slack?: {[key: string]: any};
    springcm?: {[key: string]: any};
    wams?: {[key: string]: any};
    /**
     * WS-Fed (WIF) addon indicator. Actual configuration is stored in callback and `clientAliases` properties on the client.
     */
    wsfed?: {[key: string]: any};
    zendesk?: {[key: string]: any};
    zoom?: {[key: string]: any};
}

export interface ClientAddonsSamlp {
    audience?: string;
    authnContextClassRef?: string;
    binding?: string;
    createUpnClaim?: boolean;
    destination?: string;
    digestAlgorithm?: string;
    includeAttributeNameFormat?: boolean;
    issuer?: string;
    lifetimeInSeconds?: number;
    logout?: {[key: string]: any};
    mapIdentities?: boolean;
    mapUnknownClaimsAsIs?: boolean;
    mappings?: {[key: string]: any};
    nameIdentifierFormat?: string;
    nameIdentifierProbes?: string[];
    passthroughClaimsWithNoMapping?: boolean;
    recipient?: string;
    signResponse?: boolean;
    signatureAlgorithm?: string;
    signingCert?: string;
    typedAttributes?: boolean;
}

export interface ClientCredentialsPrivateKeyJwt {
    /**
     * Client credentials available for use when Private Key JWT is in use as the client authentication method. A maximum of 2 client credentials can be set.
     */
    credentials: outputs.ClientCredentialsPrivateKeyJwtCredential[];
}

export interface ClientCredentialsPrivateKeyJwtCredential {
    algorithm?: string;
    createdAt: string;
    credentialType: string;
    expiresAt: string;
    /**
     * The ID of this resource.
     */
    id: string;
    keyId: string;
    name?: string;
    parseExpiryFromCert?: boolean;
    pem: string;
    updatedAt: string;
}

export interface ClientJwtConfiguration {
    /**
     * Algorithm used to sign JWTs.
     */
    alg?: string;
    /**
     * Number of seconds during which the JWT will be valid.
     */
    lifetimeInSeconds: number;
    /**
     * Permissions (scopes) included in JWTs.
     */
    scopes?: {[key: string]: string};
    /**
     * Indicates whether the client secret is Base64-encoded.
     */
    secretEncoded: boolean;
}

export interface ClientMobile {
    /**
     * Configuration settings for Android native apps.
     */
    android: outputs.ClientMobileAndroid;
    /**
     * Configuration settings for i0S native apps.
     */
    ios: outputs.ClientMobileIos;
}

export interface ClientMobileAndroid {
    appPackageName?: string;
    sha256CertFingerprints?: string[];
}

export interface ClientMobileIos {
    appBundleIdentifier?: string;
    teamId?: string;
}

export interface ClientNativeSocialLogin {
    apple: outputs.ClientNativeSocialLoginApple;
    facebook: outputs.ClientNativeSocialLoginFacebook;
}

export interface ClientNativeSocialLoginApple {
    enabled?: boolean;
}

export interface ClientNativeSocialLoginFacebook {
    enabled?: boolean;
}

export interface ClientRefreshToken {
    /**
     * Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
     */
    expirationType: string;
    /**
     * The time in seconds after which inactive refresh tokens will expire.
     */
    idleTokenLifetime: number;
    /**
     * Whether inactive refresh tokens should remain valid indefinitely.
     */
    infiniteIdleTokenLifetime: boolean;
    /**
     * Whether refresh tokens should remain valid indefinitely. If false, `tokenLifetime` should also be set.
     */
    infiniteTokenLifetime: boolean;
    /**
     * The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
     */
    leeway: number;
    /**
     * Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
     */
    rotationType: string;
    /**
     * The absolute lifetime of a refresh token in seconds.
     */
    tokenLifetime: number;
}

export interface ConnectionOptions {
    /**
     * ADFS URL where to fetch the metadata source.
     */
    adfsServer?: string;
    /**
     * List of allowed audiences.
     */
    allowedAudiences: string[];
    /**
     * Enable API Access to users.
     */
    apiEnableUsers?: boolean;
    /**
     * App ID.
     */
    appId?: string;
    /**
     * Query string parameters to be included as part of the generated passwordless email link.
     */
    authParams?: {[key: string]: string};
    /**
     * Authorization endpoint.
     */
    authorizationEndpoint: string;
    /**
     * Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
     */
    bruteForceProtection?: boolean;
    /**
     * The strategy's client ID.
     */
    clientId?: string;
    /**
     * The strategy's client secret.
     */
    clientSecret?: string;
    /**
     * Salesforce community base URL.
     */
    communityBaseUrl?: string;
    /**
     * A case-sensitive map of key value pairs used as configuration variables for the `customScript`.
     */
    configuration?: {[key: string]: any};
    /**
     * A map of scripts used to integrate with a custom database.
     */
    customScripts?: {[key: string]: string};
    /**
     * When enabled, additional debug information will be generated.
     */
    debug?: boolean;
    /**
     * Sign Request Algorithm Digest.
     */
    digestAlgorithm?: string;
    /**
     * Indicates whether to disable the cache or not.
     */
    disableCache?: boolean;
    /**
     * Indicates whether to remove the forgot password link within the New Universal Login.
     */
    disableSelfServiceChangePassword?: boolean;
    /**
     * When enabled, will disable sign out.
     */
    disableSignOut?: boolean;
    /**
     * Indicates whether to allow user sign-ups to your application.
     */
    disableSignup?: boolean;
    /**
     * OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
     */
    discoveryUrl?: string;
    /**
     * Domain name.
     */
    domain?: string;
    /**
     * List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
     */
    domainAliases: string[];
    /**
     * Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
     */
    enableScriptContext?: boolean;
    /**
     * Set to `true` to use a legacy user store.
     */
    enabledDatabaseCustomization?: boolean;
    /**
     * Custom Entity ID for the connection.
     */
    entityId?: string;
    /**
     * Federation Metadata for the ADFS connection.
     */
    fedMetadataXml?: string;
    /**
     * If you're configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
     */
    fieldsMap?: string;
    /**
     * Specifies whether or not request info should be forwarded to sms gateway.
     */
    forwardRequestInfo?: boolean;
    /**
     * Address to use as the sender.
     */
    from?: string;
    /**
     * Defines the parameters used to generate the auth token for the custom gateway.
     */
    gatewayAuthentication?: outputs.ConnectionOptionsGatewayAuthentication;
    /**
     * Defines a custom sms gateway to use instead of Twilio.
     */
    gatewayUrl?: string;
    /**
     * Icon URL.
     */
    iconUrl?: string;
    /**
     * Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
     */
    identityApi?: string;
    /**
     * Configuration options for IDP Initiated Authentication. This is an object with the properties: `clientId`, `clientProtocol`, and `clientAuthorizeQuery`.
     */
    idpInitiated?: outputs.ConnectionOptionsIdpInitiated;
    /**
     * Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
     */
    importMode?: boolean;
    /**
     * A list of IPs.
     */
    ips: string[];
    /**
     * Issuer URL, e.g. `https://auth.example.com`.
     */
    issuer: string;
    /**
     * JWKS URI.
     */
    jwksUri: string;
    /**
     * Apple Key ID.
     */
    keyId?: string;
    /**
     * Maximum number of groups to retrieve.
     */
    maxGroupsToRetrieve?: string;
    /**
     * SID for Copilot. Used when SMS Source is Copilot.
     */
    messagingServiceSid?: string;
    /**
     * The URL of the SAML metadata document.
     */
    metadataUrl?: string;
    /**
     * The XML content for the SAML metadata document.
     */
    metadataXml?: string;
    /**
     * Configuration options for multifactor authentication.
     */
    mfa: outputs.ConnectionOptionsMfa;
    /**
     * The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
     */
    name?: string;
    /**
     * If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
     */
    nonPersistentAttrs: string[];
    /**
     * Configuration settings for password complexity.
     */
    passwordComplexityOptions: outputs.ConnectionOptionsPasswordComplexityOptions;
    /**
     * Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
     */
    passwordDictionary: outputs.ConnectionOptionsPasswordDictionary;
    /**
     * Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
     */
    passwordHistories: outputs.ConnectionOptionsPasswordHistory[];
    /**
     * Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user's personal data, including user's `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user's `email`, or first part of the user's `email`.
     */
    passwordNoPersonalInfo: outputs.ConnectionOptionsPasswordNoPersonalInfo;
    /**
     * Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
     */
    passwordPolicy: string;
    /**
     * Ping Federate Server URL.
     */
    pingFederateBaseUrl?: string;
    /**
     * Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
     */
    pkceEnabled?: boolean;
    /**
     * The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
     */
    protocolBinding?: string;
    /**
     * Defines the custom `smsGateway` provider.
     */
    provider?: string;
    /**
     * Template that formats the SAML request.
     */
    requestTemplate?: string;
    /**
     * Indicates whether the user is required to provide a username in addition to an email address.
     */
    requiresUsername?: boolean;
    /**
     * Permissions to grant to the connection. Within the Auth0 dashboard these appear under the "Attributes" and "Extended Attributes" sections. Some examples: `basicProfile`, `extProfile`, `extNestedGroups`, etc.
     */
    scopes: string[];
    /**
     * A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
     */
    scripts?: {[key: string]: string};
    /**
     * Determines whether to sync user profile attributes (`name`, `givenName`, `familyName`, `nickname`, `picture`) at each login or only on the first login. Options include: `onEachLogin`, `onFirstLogin`. Default value: `onEachLogin`.
     */
    setUserRootAttributes?: string;
    /**
     * Choose how Auth0 sets the emailVerified field in the user profile.
     */
    shouldTrustEmailVerifiedConnection?: string;
    /**
     * SAML single login URL for the connection.
     */
    signInEndpoint: string;
    /**
     * SAML single logout URL for the connection.
     */
    signOutEndpoint: string;
    /**
     * When enabled, the SAML authentication request will be signed.
     */
    signSamlRequest?: boolean;
    /**
     * Sign Request Algorithm.
     */
    signatureAlgorithm?: string;
    /**
     * X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
     */
    signingCert: string;
    /**
     * The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     */
    signingKey?: outputs.ConnectionOptionsSigningKey;
    /**
     * Version 1 is deprecated, use version 2.
     */
    strategyVersion: number;
    /**
     * Subject line of the email.
     */
    subject?: string;
    /**
     * Syntax of the template body.
     */
    syntax?: string;
    /**
     * Apple Team ID.
     */
    teamId?: string;
    /**
     * Body of the template.
     */
    template?: string;
    /**
     * Tenant domain name.
     */
    tenantDomain?: string;
    /**
     * Token endpoint.
     */
    tokenEndpoint: string;
    /**
     * Configuration options for one-time passwords.
     */
    totp?: outputs.ConnectionOptionsTotp;
    /**
     * SID for your Twilio account.
     */
    twilioSid?: string;
    /**
     * AuthToken for your Twilio account.
     */
    twilioToken?: string;
    /**
     * Value can be `backChannel` or `frontChannel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
     */
    type?: string;
    /**
     * You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
     */
    upstreamParams?: string;
    /**
     * Indicates whether to use cert auth or not.
     */
    useCertAuth?: boolean;
    /**
     * Indicates whether to use Kerberos or not.
     */
    useKerberos?: boolean;
    /**
     * Whether to use WS-Fed.
     */
    useWsfed?: boolean;
    /**
     * Attribute in the SAML token that will be mapped to the userId property in Auth0.
     */
    userIdAttribute?: string;
    /**
     * User info endpoint.
     */
    userinfoEndpoint: string;
    /**
     * Validation of the minimum and maximum values allowed for a user to have as username.
     */
    validation?: outputs.ConnectionOptionsValidation;
    /**
     * Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you're using this for a multi-tenant application in Azure AD.
     */
    waadCommonEndpoint?: boolean;
    /**
     * Protocol to use.
     */
    waadProtocol?: string;
}

export interface ConnectionOptionsGatewayAuthentication {
    audience?: string;
    method?: string;
    secret?: string;
    secretBase64Encoded?: boolean;
    subject?: string;
}

export interface ConnectionOptionsIdpInitiated {
    clientAuthorizeQuery?: string;
    clientId?: string;
    clientProtocol?: string;
}

export interface ConnectionOptionsMfa {
    active?: boolean;
    returnEnrollSettings?: boolean;
}

export interface ConnectionOptionsPasswordComplexityOptions {
    minLength?: number;
}

export interface ConnectionOptionsPasswordDictionary {
    dictionaries?: string[];
    enable?: boolean;
}

export interface ConnectionOptionsPasswordHistory {
    enable?: boolean;
    size?: number;
}

export interface ConnectionOptionsPasswordNoPersonalInfo {
    enable?: boolean;
}

export interface ConnectionOptionsSigningKey {
    cert: string;
    key: string;
}

export interface ConnectionOptionsTotp {
    length?: number;
    timeStep?: number;
}

export interface ConnectionOptionsValidation {
    username?: outputs.ConnectionOptionsValidationUsername;
}

export interface ConnectionOptionsValidationUsername {
    max?: number;
    min?: number;
}

export interface CustomDomainVerification {
    methods: any[];
}

export interface EmailCredentials {
    /**
     * AWS Access Key ID. Used only for AWS.
     */
    accessKeyId?: string;
    /**
     * API Key for your email service. Will always be encrypted in our database.
     */
    apiKey?: string;
    /**
     * API User for your email service. This field is not accepted by the API any more so it will be removed in a future major version.
     *
     * @deprecated This field is not accepted by the API any more so it will be removed soon.
     */
    apiUser?: string;
    /**
     * Domain name.
     */
    domain?: string;
    /**
     * Default region. Used only for AWS, Mailgun, and SparkPost.
     */
    region?: string;
    /**
     * AWS Secret Key. Will always be encrypted in our database. Used only for AWS.
     */
    secretAccessKey?: string;
    /**
     * Hostname or IP address of your SMTP server. Used only for SMTP.
     */
    smtpHost?: string;
    /**
     * SMTP password. Used only for SMTP.
     */
    smtpPass?: string;
    /**
     * Port used by your SMTP server. Please avoid using port 25 if possible because many providers have limitations on this port. Used only for SMTP.
     */
    smtpPort?: number;
    /**
     * SMTP username. Used only for SMTP.
     */
    smtpUser?: string;
}

export interface EmailSettings {
    /**
     * Headers settings for the `smtp` email provider.
     */
    headers?: outputs.EmailSettingsHeaders;
    /**
     * Message settings for the `mandrill` or `ses` email provider.
     */
    message?: outputs.EmailSettingsMessage;
}

export interface EmailSettingsHeaders {
    xMcViewContentLink?: string;
    xSesConfigurationSet?: string;
}

export interface EmailSettingsMessage {
    configurationSetName?: string;
    viewContentLink?: boolean;
}

export interface GetAttackProtectionBreachedPasswordDetection {
    adminNotificationFrequencies: string[];
    enabled: boolean;
    method: string;
    preUserRegistrations: outputs.GetAttackProtectionBreachedPasswordDetectionPreUserRegistration[];
    shields: string[];
}

export interface GetAttackProtectionBreachedPasswordDetectionPreUserRegistration {
    shields: string[];
}

export interface GetAttackProtectionBruteForceProtection {
    allowlists: string[];
    enabled: boolean;
    maxAttempts: number;
    mode: string;
    shields: string[];
}

export interface GetAttackProtectionSuspiciousIpThrottling {
    allowlists: string[];
    enabled: boolean;
    preLogins: outputs.GetAttackProtectionSuspiciousIpThrottlingPreLogin[];
    preUserRegistrations: outputs.GetAttackProtectionSuspiciousIpThrottlingPreUserRegistration[];
    shields: string[];
}

export interface GetAttackProtectionSuspiciousIpThrottlingPreLogin {
    maxAttempts: number;
    rate: number;
}

export interface GetAttackProtectionSuspiciousIpThrottlingPreUserRegistration {
    maxAttempts: number;
    rate: number;
}

export interface GetBrandingColor {
    pageBackground: string;
    primary: string;
}

export interface GetBrandingFont {
    url: string;
}

export interface GetBrandingThemeBorder {
    buttonBorderRadius: number;
    buttonBorderWeight: number;
    buttonsStyle: string;
    inputBorderRadius: number;
    inputBorderWeight: number;
    inputsStyle: string;
    showWidgetShadow: boolean;
    widgetBorderWeight: number;
    widgetCornerRadius: number;
}

export interface GetBrandingThemeColor {
    baseFocusColor: string;
    baseHoverColor: string;
    bodyText: string;
    error: string;
    header: string;
    icons: string;
    inputBackground: string;
    inputBorder: string;
    inputFilledText: string;
    inputLabelsPlaceholders: string;
    linksFocusedComponents: string;
    primaryButton: string;
    primaryButtonLabel: string;
    secondaryButtonBorder: string;
    secondaryButtonLabel: string;
    success: string;
    widgetBackground: string;
    widgetBorder: string;
}

export interface GetBrandingThemeFont {
    bodyTexts: outputs.GetBrandingThemeFontBodyText[];
    buttonsTexts: outputs.GetBrandingThemeFontButtonsText[];
    fontUrl: string;
    inputLabels: outputs.GetBrandingThemeFontInputLabel[];
    links: outputs.GetBrandingThemeFontLink[];
    linksStyle: string;
    referenceTextSize: number;
    subtitles: outputs.GetBrandingThemeFontSubtitle[];
    titles: outputs.GetBrandingThemeFontTitle[];
}

export interface GetBrandingThemeFontBodyText {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemeFontButtonsText {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemeFontInputLabel {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemeFontLink {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemeFontSubtitle {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemeFontTitle {
    bold: boolean;
    size: number;
}

export interface GetBrandingThemePageBackground {
    backgroundColor: string;
    backgroundImageUrl: string;
    pageLayout: string;
}

export interface GetBrandingThemeWidget {
    headerTextAlignment: string;
    logoHeight: number;
    logoPosition: string;
    logoUrl: string;
    socialButtonsLayout: string;
}

export interface GetBrandingUniversalLogin {
    body: string;
}

export interface GetClientAddon {
    aws: {[key: string]: any};
    azureBlob: {[key: string]: any};
    azureSb: {[key: string]: any};
    box: {[key: string]: any};
    cloudbees: {[key: string]: any};
    concur: {[key: string]: any};
    dropbox: {[key: string]: any};
    echosign: {[key: string]: any};
    egnyte: {[key: string]: any};
    firebase: {[key: string]: any};
    layer: {[key: string]: any};
    mscrm: {[key: string]: any};
    newrelic: {[key: string]: any};
    office365: {[key: string]: any};
    rms: {[key: string]: any};
    salesforce: {[key: string]: any};
    salesforceApi: {[key: string]: any};
    salesforceSandboxApi: {[key: string]: any};
    samlps: outputs.GetClientAddonSamlp[];
    sapApi: {[key: string]: any};
    sentry: {[key: string]: any};
    sharepoint: {[key: string]: any};
    slack: {[key: string]: any};
    springcm: {[key: string]: any};
    wams: {[key: string]: any};
    wsfed: {[key: string]: any};
    zendesk: {[key: string]: any};
    zoom: {[key: string]: any};
}

export interface GetClientAddonSamlp {
    audience: string;
    authnContextClassRef: string;
    binding: string;
    createUpnClaim: boolean;
    destination: string;
    digestAlgorithm: string;
    includeAttributeNameFormat: boolean;
    issuer: string;
    lifetimeInSeconds: number;
    logout: {[key: string]: any};
    mapIdentities: boolean;
    mapUnknownClaimsAsIs: boolean;
    mappings: {[key: string]: any};
    nameIdentifierFormat: string;
    nameIdentifierProbes: string[];
    passthroughClaimsWithNoMapping: boolean;
    recipient: string;
    signResponse: boolean;
    signatureAlgorithm: string;
    signingCert: string;
    typedAttributes: boolean;
}

export interface GetClientJwtConfiguration {
    alg: string;
    lifetimeInSeconds: number;
    scopes: {[key: string]: string};
    secretEncoded: boolean;
}

export interface GetClientMobile {
    androids: outputs.GetClientMobileAndroid[];
    ios: outputs.GetClientMobileIo[];
}

export interface GetClientMobileAndroid {
    appPackageName: string;
    sha256CertFingerprints: string[];
}

export interface GetClientMobileIo {
    appBundleIdentifier: string;
    teamId: string;
}

export interface GetClientNativeSocialLogin {
    apples: outputs.GetClientNativeSocialLoginApple[];
    facebooks: outputs.GetClientNativeSocialLoginFacebook[];
}

export interface GetClientNativeSocialLoginApple {
    enabled: boolean;
}

export interface GetClientNativeSocialLoginFacebook {
    enabled: boolean;
}

export interface GetClientRefreshToken {
    expirationType: string;
    idleTokenLifetime: number;
    infiniteIdleTokenLifetime: boolean;
    infiniteTokenLifetime: boolean;
    leeway: number;
    rotationType: string;
    tokenLifetime: number;
}

export interface GetConnectionOption {
    adfsServer: string;
    allowedAudiences: string[];
    apiEnableUsers: boolean;
    appId: string;
    authParams: {[key: string]: string};
    authorizationEndpoint: string;
    bruteForceProtection: boolean;
    clientId: string;
    clientSecret: string;
    communityBaseUrl: string;
    configuration: {[key: string]: any};
    customScripts: {[key: string]: string};
    debug: boolean;
    digestAlgorithm: string;
    disableCache: boolean;
    disableSelfServiceChangePassword: boolean;
    disableSignOut: boolean;
    disableSignup: boolean;
    discoveryUrl: string;
    domain: string;
    domainAliases: string[];
    enableScriptContext: boolean;
    enabledDatabaseCustomization: boolean;
    entityId: string;
    fedMetadataXml: string;
    fieldsMap: string;
    forwardRequestInfo: boolean;
    from: string;
    gatewayAuthentications: outputs.GetConnectionOptionGatewayAuthentication[];
    gatewayUrl: string;
    iconUrl: string;
    identityApi: string;
    idpInitiateds: outputs.GetConnectionOptionIdpInitiated[];
    importMode: boolean;
    ips: string[];
    issuer: string;
    jwksUri: string;
    keyId: string;
    maxGroupsToRetrieve: string;
    messagingServiceSid: string;
    metadataUrl: string;
    metadataXml: string;
    mfas: outputs.GetConnectionOptionMfa[];
    /**
     * The name of the connection. If not provided, `connectionId` must be set.
     */
    name: string;
    nonPersistentAttrs: string[];
    passwordComplexityOptions: outputs.GetConnectionOptionPasswordComplexityOption[];
    passwordDictionaries: outputs.GetConnectionOptionPasswordDictionary[];
    passwordHistories: outputs.GetConnectionOptionPasswordHistory[];
    passwordNoPersonalInfos: outputs.GetConnectionOptionPasswordNoPersonalInfo[];
    passwordPolicy: string;
    pingFederateBaseUrl: string;
    pkceEnabled: boolean;
    protocolBinding: string;
    provider: string;
    requestTemplate: string;
    requiresUsername: boolean;
    scopes: string[];
    scripts: {[key: string]: string};
    setUserRootAttributes: string;
    shouldTrustEmailVerifiedConnection: string;
    signInEndpoint: string;
    signOutEndpoint: string;
    signSamlRequest: boolean;
    signatureAlgorithm: string;
    signingCert: string;
    signingKeys: outputs.GetConnectionOptionSigningKey[];
    strategyVersion: number;
    subject: string;
    syntax: string;
    teamId: string;
    template: string;
    tenantDomain: string;
    tokenEndpoint: string;
    totps: outputs.GetConnectionOptionTotp[];
    twilioSid: string;
    twilioToken: string;
    type: string;
    upstreamParams: string;
    useCertAuth: boolean;
    useKerberos: boolean;
    useWsfed: boolean;
    userIdAttribute: string;
    userinfoEndpoint: string;
    validations: outputs.GetConnectionOptionValidation[];
    waadCommonEndpoint: boolean;
    waadProtocol: string;
}

export interface GetConnectionOptionGatewayAuthentication {
    audience: string;
    method: string;
    secret: string;
    secretBase64Encoded: boolean;
    subject: string;
}

export interface GetConnectionOptionIdpInitiated {
    clientAuthorizeQuery: string;
    clientId: string;
    clientProtocol: string;
}

export interface GetConnectionOptionMfa {
    active: boolean;
    returnEnrollSettings: boolean;
}

export interface GetConnectionOptionPasswordComplexityOption {
    minLength: number;
}

export interface GetConnectionOptionPasswordDictionary {
    dictionaries: string[];
    enable: boolean;
}

export interface GetConnectionOptionPasswordHistory {
    enable: boolean;
    size: number;
}

export interface GetConnectionOptionPasswordNoPersonalInfo {
    enable: boolean;
}

export interface GetConnectionOptionSigningKey {
    cert: string;
    key: string;
}

export interface GetConnectionOptionTotp {
    length: number;
    timeStep: number;
}

export interface GetConnectionOptionValidation {
    usernames: outputs.GetConnectionOptionValidationUsername[];
}

export interface GetConnectionOptionValidationUsername {
    max: number;
    min: number;
}

export interface GetCustomDomainVerification {
    methods: any[];
}

export interface GetGlobalClientAddon {
    aws: {[key: string]: any};
    azureBlob: {[key: string]: any};
    azureSb: {[key: string]: any};
    box: {[key: string]: any};
    cloudbees: {[key: string]: any};
    concur: {[key: string]: any};
    dropbox: {[key: string]: any};
    echosign: {[key: string]: any};
    egnyte: {[key: string]: any};
    firebase: {[key: string]: any};
    layer: {[key: string]: any};
    mscrm: {[key: string]: any};
    newrelic: {[key: string]: any};
    office365: {[key: string]: any};
    rms: {[key: string]: any};
    salesforce: {[key: string]: any};
    salesforceApi: {[key: string]: any};
    salesforceSandboxApi: {[key: string]: any};
    samlps: outputs.GetGlobalClientAddonSamlp[];
    sapApi: {[key: string]: any};
    sentry: {[key: string]: any};
    sharepoint: {[key: string]: any};
    slack: {[key: string]: any};
    springcm: {[key: string]: any};
    wams: {[key: string]: any};
    wsfed: {[key: string]: any};
    zendesk: {[key: string]: any};
    zoom: {[key: string]: any};
}

export interface GetGlobalClientAddonSamlp {
    audience: string;
    authnContextClassRef: string;
    binding: string;
    createUpnClaim: boolean;
    destination: string;
    digestAlgorithm: string;
    includeAttributeNameFormat: boolean;
    issuer: string;
    lifetimeInSeconds: number;
    logout: {[key: string]: any};
    mapIdentities: boolean;
    mapUnknownClaimsAsIs: boolean;
    mappings: {[key: string]: any};
    nameIdentifierFormat: string;
    nameIdentifierProbes: string[];
    passthroughClaimsWithNoMapping: boolean;
    recipient: string;
    signResponse: boolean;
    signatureAlgorithm: string;
    signingCert: string;
    typedAttributes: boolean;
}

export interface GetGlobalClientJwtConfiguration {
    alg: string;
    lifetimeInSeconds: number;
    scopes: {[key: string]: string};
    secretEncoded: boolean;
}

export interface GetGlobalClientMobile {
    androids: outputs.GetGlobalClientMobileAndroid[];
    ios: outputs.GetGlobalClientMobileIo[];
}

export interface GetGlobalClientMobileAndroid {
    appPackageName: string;
    sha256CertFingerprints: string[];
}

export interface GetGlobalClientMobileIo {
    appBundleIdentifier: string;
    teamId: string;
}

export interface GetGlobalClientNativeSocialLogin {
    apples: outputs.GetGlobalClientNativeSocialLoginApple[];
    facebooks: outputs.GetGlobalClientNativeSocialLoginFacebook[];
}

export interface GetGlobalClientNativeSocialLoginApple {
    enabled: boolean;
}

export interface GetGlobalClientNativeSocialLoginFacebook {
    enabled: boolean;
}

export interface GetGlobalClientRefreshToken {
    expirationType: string;
    idleTokenLifetime: number;
    infiniteIdleTokenLifetime: boolean;
    infiniteTokenLifetime: boolean;
    leeway: number;
    rotationType: string;
    tokenLifetime: number;
}

export interface GetOrganizationBranding {
    colors: {[key: string]: string};
    logoUrl: string;
}

export interface GetOrganizationConnection {
    assignMembershipOnLogin: boolean;
    connectionId: string;
}

export interface GetResourceServerScope {
    description: string;
    value: string;
}

export interface GetRolePermission {
    /**
     * Description of the role.
     */
    description: string;
    /**
     * The name of the role. If not provided, `roleId` must be set.
     */
    name: string;
    resourceServerIdentifier: string;
    resourceServerName: string;
}

export interface GetTenantChangePassword {
    enabled: boolean;
    html: string;
}

export interface GetTenantErrorPage {
    html: string;
    showLogLink: boolean;
    url: string;
}

export interface GetTenantFlag {
    allowLegacyDelegationGrantTypes: boolean;
    allowLegacyRoGrantTypes: boolean;
    allowLegacyTokeninfoEndpoint: boolean;
    dashboardInsightsView: boolean;
    dashboardLogStreamsNext: boolean;
    disableClickjackProtectionHeaders: boolean;
    disableFieldsMapFix: boolean;
    disableManagementApiSmsObfuscation: boolean;
    enableAdfsWaadEmailVerification: boolean;
    enableApisSection: boolean;
    enableClientConnections: boolean;
    enableCustomDomainInEmails: boolean;
    enableDynamicClientRegistration: boolean;
    enableIdtokenApi2: boolean;
    enableLegacyLogsSearchV2: boolean;
    enableLegacyProfile: boolean;
    enablePipeline2: boolean;
    enablePublicSignupUserExistsError: boolean;
    mfaShowFactorListOnEnrollment: boolean;
    noDiscloseEnterpriseConnections: boolean;
    revokeRefreshTokenGrant: boolean;
    universalLogin: boolean;
    useScopeDescriptionsForConsent: boolean;
}

export interface GetTenantGuardianMfaPage {
    enabled: boolean;
    html: string;
}

export interface GetTenantSessionCooky {
    mode: string;
}

export interface GetTenantUniversalLogin {
    colors: outputs.GetTenantUniversalLoginColor[];
}

export interface GetTenantUniversalLoginColor {
    pageBackground: string;
    primary: string;
}

export interface GetUserPermission {
    description: string;
    /**
     * Name of the user. This value can only be updated if the connection is a database connection (using the Auth0 store), a passwordless connection (email or sms) or has disabled 'Sync user profile attributes at each login'. For more information, see: [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0).
     */
    name: string;
    resourceServerIdentifier: string;
    resourceServerName: string;
}

export interface GlobalClientAddons {
    aws?: {[key: string]: any};
    azureBlob?: {[key: string]: any};
    azureSb?: {[key: string]: any};
    box?: {[key: string]: any};
    cloudbees?: {[key: string]: any};
    concur?: {[key: string]: any};
    dropbox?: {[key: string]: any};
    echosign?: {[key: string]: any};
    egnyte?: {[key: string]: any};
    firebase?: {[key: string]: any};
    layer?: {[key: string]: any};
    mscrm?: {[key: string]: any};
    newrelic?: {[key: string]: any};
    office365?: {[key: string]: any};
    rms?: {[key: string]: any};
    salesforce?: {[key: string]: any};
    salesforceApi?: {[key: string]: any};
    salesforceSandboxApi?: {[key: string]: any};
    /**
     * Configuration settings for a SAML add-on.
     */
    samlp?: outputs.GlobalClientAddonsSamlp;
    sapApi?: {[key: string]: any};
    sentry?: {[key: string]: any};
    sharepoint?: {[key: string]: any};
    slack?: {[key: string]: any};
    springcm?: {[key: string]: any};
    wams?: {[key: string]: any};
    /**
     * WS-Fed (WIF) addon indicator. Actual configuration is stored in callback and `clientAliases` properties on the client.
     */
    wsfed?: {[key: string]: any};
    zendesk?: {[key: string]: any};
    zoom?: {[key: string]: any};
}

export interface GlobalClientAddonsSamlp {
    audience?: string;
    authnContextClassRef?: string;
    binding?: string;
    createUpnClaim?: boolean;
    destination?: string;
    digestAlgorithm?: string;
    includeAttributeNameFormat?: boolean;
    issuer?: string;
    lifetimeInSeconds?: number;
    logout?: {[key: string]: any};
    mapIdentities?: boolean;
    mapUnknownClaimsAsIs?: boolean;
    mappings?: {[key: string]: any};
    nameIdentifierFormat?: string;
    nameIdentifierProbes?: string[];
    passthroughClaimsWithNoMapping?: boolean;
    recipient?: string;
    signResponse?: boolean;
    signatureAlgorithm?: string;
    signingCert?: string;
    typedAttributes?: boolean;
}

export interface GlobalClientJwtConfiguration {
    /**
     * Algorithm used to sign JWTs.
     */
    alg?: string;
    /**
     * Number of seconds during which the JWT will be valid.
     */
    lifetimeInSeconds: number;
    /**
     * Permissions (scopes) included in JWTs.
     */
    scopes?: {[key: string]: string};
    /**
     * Indicates whether the client secret is Base64-encoded.
     */
    secretEncoded: boolean;
}

export interface GlobalClientMobile {
    /**
     * Configuration settings for Android native apps.
     */
    android: outputs.GlobalClientMobileAndroid;
    /**
     * Configuration settings for i0S native apps.
     */
    ios: outputs.GlobalClientMobileIos;
}

export interface GlobalClientMobileAndroid {
    appPackageName?: string;
    sha256CertFingerprints?: string[];
}

export interface GlobalClientMobileIos {
    appBundleIdentifier?: string;
    teamId?: string;
}

export interface GlobalClientNativeSocialLogin {
    apple: outputs.GlobalClientNativeSocialLoginApple;
    facebook: outputs.GlobalClientNativeSocialLoginFacebook;
}

export interface GlobalClientNativeSocialLoginApple {
    enabled?: boolean;
}

export interface GlobalClientNativeSocialLoginFacebook {
    enabled?: boolean;
}

export interface GlobalClientRefreshToken {
    /**
     * Options include `expiring`, `non-expiring`. Whether a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is `rotating`, this must be set to `expiring`.
     */
    expirationType: string;
    /**
     * The time in seconds after which inactive refresh tokens will expire.
     */
    idleTokenLifetime: number;
    /**
     * Whether inactive refresh tokens should remain valid indefinitely.
     */
    infiniteIdleTokenLifetime: boolean;
    /**
     * Whether refresh tokens should remain valid indefinitely. If false, `tokenLifetime` should also be set.
     */
    infiniteTokenLifetime: boolean;
    /**
     * The amount of time in seconds in which a refresh token may be reused without triggering reuse detection.
     */
    leeway: number;
    /**
     * Options include `rotating`, `non-rotating`. When `rotating`, exchanging a refresh token will cause a new refresh token to be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked.
     */
    rotationType: string;
    /**
     * The absolute lifetime of a refresh token in seconds.
     */
    tokenLifetime: number;
}

export interface GuardianDuo {
    /**
     * Indicates whether Duo MFA is enabled.
     */
    enabled: boolean;
    /**
     * Duo API Hostname, see the Duo documentation for more details on Duo setup.
     */
    hostname?: string;
    /**
     * Duo client ID, see the Duo documentation for more details on Duo setup.
     */
    integrationKey?: string;
    /**
     * Duo client secret, see the Duo documentation for more details on Duo setup.
     */
    secretKey?: string;
}

export interface GuardianPhone {
    /**
     * Indicates whether Phone MFA is enabled.
     */
    enabled: boolean;
    /**
     * Message types to use, array of `sms` and/or `voice`. Adding both to the array should enable the user to choose.
     */
    messageTypes?: string[];
    /**
     * Options for the various providers.
     */
    options: outputs.GuardianPhoneOptions;
    /**
     * Provider to use, one of `auth0`, `twilio` or `phone-message-hook`. Selecting `phone-message-hook` will require a Phone Message Action to be created before. [Learn how](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).
     */
    provider?: string;
}

export interface GuardianPhoneOptions {
    authToken?: string;
    enrollmentMessage?: string;
    from?: string;
    messagingServiceSid?: string;
    sid?: string;
    verificationMessage?: string;
}

export interface GuardianPush {
    /**
     * Configuration for Amazon SNS.
     */
    amazonSns: outputs.GuardianPushAmazonSns;
    /**
     * Configuration for the Guardian Custom App.
     */
    customApp: outputs.GuardianPushCustomApp;
    /**
     * Configuration for the Apple Push Notification service (APNs) settings.
     */
    directApns: outputs.GuardianPushDirectApns;
    /**
     * Configuration for Firebase Cloud Messaging (FCM) settings.
     */
    directFcm: outputs.GuardianPushDirectFcm;
    /**
     * Indicates whether Push MFA is enabled.
     */
    enabled: boolean;
    /**
     * Provider to use, one of `direct`, `guardian`, `sns`.
     */
    provider?: string;
}

export interface GuardianPushAmazonSns {
    awsAccessKeyId: string;
    awsRegion: string;
    awsSecretAccessKey: string;
    snsApnsPlatformApplicationArn: string;
    snsGcmPlatformApplicationArn: string;
}

export interface GuardianPushCustomApp {
    appName?: string;
    appleAppLink?: string;
    googleAppLink?: string;
}

export interface GuardianPushDirectApns {
    bundleId: string;
    enabled: boolean;
    p12: string;
    sandbox: boolean;
}

export interface GuardianPushDirectFcm {
    serverKey: string;
}

export interface GuardianWebauthnPlatform {
    /**
     * Indicates whether WebAuthn with FIDO Device Biometrics MFA is enabled.
     */
    enabled: boolean;
    /**
     * The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
     */
    overrideRelyingParty: boolean;
    /**
     * The Relying Party should be a suffix of the custom domain.
     */
    relyingPartyIdentifier: string;
}

export interface GuardianWebauthnRoaming {
    /**
     * Indicates whether WebAuthn with FIDO Security Keys MFA is enabled.
     */
    enabled: boolean;
    /**
     * The Relying Party is the domain for which the WebAuthn keys will be issued, set to `true` if you are customizing the identifier.
     */
    overrideRelyingParty: boolean;
    /**
     * The Relying Party should be a suffix of the custom domain.
     */
    relyingPartyIdentifier: string;
    /**
     * User verification, one of `discouraged`, `preferred` or `required`.
     */
    userVerification: string;
}

export interface LogStreamSink {
    /**
     * The AWS Account ID.
     */
    awsAccountId?: string;
    /**
     * Name of the Partner Event Source to be used with AWS. Generally generated by Auth0 and passed to AWS, so this should be an output attribute.
     */
    awsPartnerEventSource: string;
    /**
     * The AWS Region, e.g. "us-east-2").
     */
    awsRegion?: string;
    /**
     * Name of the Partner Topic to be used with Azure. Generally should not be specified.
     */
    azurePartnerTopic: string;
    /**
     * The Azure region code, e.g. "ne")
     */
    azureRegion?: string;
    /**
     * The Azure EventGrid resource group which allows you to manage all Azure assets within one subscription.
     */
    azureResourceGroup?: string;
    /**
     * The unique alphanumeric string that identifies your Azure subscription.
     */
    azureSubscriptionId?: string;
    /**
     * The Datadog API key.
     */
    datadogApiKey?: string;
    /**
     * The Datadog region. Options are ["us", "eu", "us3", "us5"].
     */
    datadogRegion?: string;
    /**
     * Sent in the HTTP "Authorization" header with each request.
     */
    httpAuthorization?: string;
    /**
     * The format of data sent over HTTP. Options are "JSONLINES", "JSONARRAY" or "JSONOBJECT"
     */
    httpContentFormat?: string;
    /**
     * The "Content-Type" header to send over HTTP. Common value is "application/json".
     */
    httpContentType?: string;
    /**
     * Additional HTTP headers to be included as part of the HTTP request.
     */
    httpCustomHeaders?: {[key: string]: string}[];
    /**
     * The HTTP endpoint to send streaming logs.
     */
    httpEndpoint?: string;
    /**
     * The Mixpanel project ID, found on the Project Settings page.
     */
    mixpanelProjectId?: string;
    /**
     * The Mixpanel region. Options are ["us", "eu"]. EU is required for customers with EU data residency requirements.
     */
    mixpanelRegion?: string;
    /**
     * The Mixpanel Service Account password.
     */
    mixpanelServiceAccountPassword?: string;
    /**
     * The Mixpanel Service Account username. Services Accounts can be created in the Project Settings page.
     */
    mixpanelServiceAccountUsername?: string;
    /**
     * The [Segment Write Key](https://segment.com/docs/connections/find-writekey/).
     */
    segmentWriteKey?: string;
    /**
     * The Splunk domain name.
     */
    splunkDomain?: string;
    /**
     * The Splunk port.
     */
    splunkPort?: string;
    /**
     * This toggle should be turned off when using self-signed certificates.
     */
    splunkSecure?: boolean;
    /**
     * The Splunk access token.
     */
    splunkToken?: string;
    /**
     * Generated URL for your defined HTTP source in Sumo Logic for collecting streaming data from Auth0.
     */
    sumoSourceAddress?: string;
}

export interface OrganizationBranding {
    /**
     * Color scheme used to customize the login pages.
     */
    colors?: {[key: string]: string};
    /**
     * URL of logo to display on login page.
     */
    logoUrl?: string;
}

export interface OrganizationConnectionsEnabledConnection {
    /**
     * When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection.
     */
    assignMembershipOnLogin?: boolean;
    /**
     * The ID of the connection to enable for the organization.
     */
    connectionId: string;
}

export interface PagesChangePassword {
    /**
     * Indicates whether to use the custom Reset Password HTML (`true`) or the default Auth0 page (`false`).
     */
    enabled: boolean;
    /**
     * Customized content for the Reset Password page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
     */
    html: string;
}

export interface PagesError {
    /**
     * Customized content for the Error page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
     */
    html?: string;
    /**
     * Indicates whether to show the link to logs as part of the default error page.
     */
    showLogLink: boolean;
    /**
     * URL to redirect to when an error occurs, instead of showing the default error page.
     */
    url?: string;
}

export interface PagesGuardianMfa {
    /**
     * Indicates whether to use the custom Guardian MFA HTML (`true`) or the default Auth0 page (`false`).
     */
    enabled: boolean;
    /**
     * Customized content for the Guardian MFA page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
     */
    html: string;
}

export interface PagesLogin {
    /**
     * Indicates whether to use the custom Login page HTML (`true`) or the default Auth0 page (`false`).
     */
    enabled: boolean;
    /**
     * Customized content for the Login page. HTML format with supported [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).
     */
    html: string;
}

export interface ResourceServerScope {
    /**
     * Description of the permission (scope).
     */
    description?: string;
    /**
     * Name of the permission (scope). Examples include `read:appointments` or `delete:appointments`.
     */
    value: string;
}

export interface ResourceServerScopesScope {
    /**
     * User-friendly description of the scope (permission).
     */
    description?: string;
    /**
     * Name of the scope (permission). Examples include `read:appointments` or `delete:appointments`.
     */
    name: string;
}

export interface RolePermission {
    /**
     * Description of the permission.
     */
    description: string;
    /**
     * Name of the permission (scope) configured on the resource server. If referencing a scope from an `auth0.ResourceServer` resource, use the `value` property, for example `auth0_resource_server.my_resource_server.scopes[0].value`.
     */
    name: string;
    /**
     * Unique identifier for the resource server.
     */
    resourceServerIdentifier: string;
    /**
     * Name of resource server that the permission is associated with.
     */
    resourceServerName: string;
}

export interface RolePermissionsPermission {
    /**
     * Description of the permission.
     */
    description: string;
    /**
     * Name of permission.
     */
    name: string;
    /**
     * Resource server identifier associated with the permission.
     */
    resourceServerIdentifier: string;
    /**
     * Name of resource server that the permission is associated with.
     */
    resourceServerName: string;
}

export interface TenantChangePassword {
    /**
     * Indicates whether to use the custom change password page.
     */
    enabled: boolean;
    /**
     * HTML format with supported Liquid syntax. Customized content of the change password page.
     */
    html: string;
}

export interface TenantErrorPage {
    /**
     * HTML format with supported Liquid syntax. Customized content of the error page.
     */
    html: string;
    /**
     * Indicates whether to show the link to logs as part of the default error page.
     */
    showLogLink: boolean;
    /**
     * URL to redirect to when an error occurs rather than showing the default error page.
     */
    url: string;
}

export interface TenantFlags {
    /**
     * Whether the legacy delegation endpoint will be enabled for your account (true) or not available (false).
     */
    allowLegacyDelegationGrantTypes: boolean;
    /**
     * Whether the legacy `auth/ro` endpoint (used with resource owner password and passwordless features) will be enabled for your account (true) or not available (false).
     */
    allowLegacyRoGrantTypes: boolean;
    /**
     * If enabled, customers can use Tokeninfo Endpoint, otherwise they can not use it.
     */
    allowLegacyTokeninfoEndpoint: boolean;
    /**
     * Enables new insights activity page view.
     */
    dashboardInsightsView: boolean;
    /**
     * Enables beta access to log streaming changes.
     */
    dashboardLogStreamsNext: boolean;
    /**
     * Indicates whether classic Universal Login prompts include additional security headers to prevent clickjacking.
     */
    disableClickjackProtectionHeaders: boolean;
    /**
     * Disables SAML fields map fix for bad mappings with repeated attributes.
     */
    disableFieldsMapFix: boolean;
    /**
     * If true, SMS phone numbers will not be obfuscated in Management API GET calls.
     */
    disableManagementApiSmsObfuscation: boolean;
    /**
     * If enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.
     */
    enableAdfsWaadEmailVerification: boolean;
    /**
     * Indicates whether the APIs section is enabled for the tenant.
     */
    enableApisSection: boolean;
    /**
     * Indicates whether all current connections should be enabled when a new client is created.
     */
    enableClientConnections: boolean;
    /**
     * Indicates whether the tenant allows custom domains in emails.
     */
    enableCustomDomainInEmails: boolean;
    /**
     * Indicates whether the tenant allows dynamic client registration.
     */
    enableDynamicClientRegistration: boolean;
    /**
     * Whether ID tokens can be used to authorize some types of requests to API v2 (true) or not (false).
     */
    enableIdtokenApi2: boolean;
    /**
     * Indicates whether to use the older v2 legacy logs search.
     */
    enableLegacyLogsSearchV2: boolean;
    /**
     * Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false).
     */
    enableLegacyProfile: boolean;
    /**
     * Indicates whether advanced API Authorization scenarios are enabled.
     */
    enablePipeline2: boolean;
    /**
     * Indicates whether the public sign up process shows a `userExists` error if the user already exists.
     */
    enablePublicSignupUserExistsError: boolean;
    /**
     * Used to allow users to pick which factor to enroll with from the list of available MFA factors.
     */
    mfaShowFactorListOnEnrollment: boolean;
    /**
     * Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file.
     */
    noDiscloseEnterpriseConnections: boolean;
    /**
     * Delete underlying grant when a refresh token is revoked via the Authentication API.
     */
    revokeRefreshTokenGrant: boolean;
    /**
     * Indicates whether the New Universal Login Experience is enabled.
     *
     * @deprecated This attribute is deprecated. Use the `universal_login_experience` attribute on the `auth0_prompt` resource to toggle the new or classic experience instead.
     */
    universalLogin: boolean;
    /**
     * Indicates whether to use scope descriptions for consent.
     */
    useScopeDescriptionsForConsent: boolean;
}

export interface TenantGuardianMfaPage {
    /**
     * Indicates whether to use the custom Guardian page.
     */
    enabled: boolean;
    /**
     * HTML format with supported Liquid syntax. Customized content of the Guardian page.
     */
    html: string;
}

export interface TenantSessionCookie {
    /**
     * Behavior of tenant session cookie. Accepts either "persistent" or "non-persistent".
     */
    mode?: string;
}

export interface TenantUniversalLogin {
    /**
     * Configuration settings for Universal Login colors.
     */
    colors?: outputs.TenantUniversalLoginColors;
}

export interface TenantUniversalLoginColors {
    pageBackground: string;
    primary: string;
}

export interface TriggerActionsAction {
    /**
     * The display name of the action within the flow.
     */
    displayName: string;
    /**
     * Action ID.
     */
    id: string;
}

export interface TriggerBindingAction {
    /**
     * The display name of the action within the flow.
     */
    displayName: string;
    /**
     * Action ID.
     */
    id: string;
}

export interface UserPermission {
    description: string;
    /**
     * Name of the user. This value can only be updated if the connection is a database connection (using the Auth0 store), a passwordless connection (email or sms) or has disabled 'Sync user profile attributes at each login'. For more information, see: [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0).
     */
    name: string;
    resourceServerIdentifier: string;
    resourceServerName: string;
}

export interface UserPermissionsPermission {
    /**
     * Description of the permission.
     */
    description: string;
    /**
     * Name of permission.
     */
    name: string;
    /**
     * Resource server identifier associated with the permission.
     */
    resourceServerIdentifier: string;
    /**
     * Name of resource server that the permission is associated with.
     */
    resourceServerName: string;
}

