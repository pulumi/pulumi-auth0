// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Auth0
{
    /// <summary>
    /// Client Assertion JWT is a more secure alternative to client secret authentication for OIDC and Okta Workforce connections. It uses a signed JWT instead of a shared secret to authenticate the client. The resource only supports key rotation. Use the auth0.ConnectionKeys data source to read existing keys. Removing the resource from configuration will NOT DELETE the key.
    /// 
    /// !&gt; The triggers field is only a placeholder for an arbitrary map used to signal the provider
    /// to perform a key rotation whenever any update is made.
    /// If the resource is removed from the configuration, the keys will not be deleted.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Auth0 = Pulumi.Auth0;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var myClient = new Auth0.Client("my_client", new()
    ///     {
    ///         Name = "My-Auth0-Client",
    ///     });
    /// 
    ///     var oidc = new Auth0.Connection("oidc", new()
    ///     {
    ///         Name = "OIDC-Connection",
    ///         Strategy = "oidc",
    ///         Options = new Auth0.Inputs.ConnectionOptionsArgs
    ///         {
    ///             ClientId = myClient.Id,
    ///             Scopes = new[]
    ///             {
    ///                 "ext_nested_groups",
    ///                 "openid",
    ///             },
    ///             Issuer = "https://example.com",
    ///             AuthorizationEndpoint = "https://example.com",
    ///             JwksUri = "https://example.com/jwks",
    ///             Type = "front_channel",
    ///             DiscoveryUrl = "https://www.paypalobjects.com/.well-known/openid-configuration",
    ///             TokenEndpointAuthMethod = "private_key_jwt",
    ///             TokenEndpointAuthSigningAlg = "RS256",
    ///         },
    ///     });
    /// 
    ///     // Resource used to rotate the keys for above OIDC connection
    ///     var myKeys = new Auth0.ConnectionKeys("my_keys", new()
    ///     {
    ///         ConnectionId = oidc.Id,
    ///         Triggers = 
    ///         {
    ///             { "version", "1" },
    ///             { "date", "2023-10-01T00:00:00Z" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [Auth0ResourceType("auth0:index/connectionKeys:ConnectionKeys")]
    public partial class ConnectionKeys : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The signing key algorithm.
        /// </summary>
        [Output("algorithm")]
        public Output<string> Algorithm { get; private set; } = null!;

        /// <summary>
        /// The public certificate of the signing key.
        /// </summary>
        [Output("cert")]
        public Output<string> Cert { get; private set; } = null!;

        [Output("connectionId")]
        public Output<string> ConnectionId { get; private set; } = null!;

        /// <summary>
        /// True if the key is the current key.
        /// </summary>
        [Output("current")]
        public Output<bool> Current { get; private set; } = null!;

        /// <summary>
        /// The date and time when the key became the current key.
        /// </summary>
        [Output("currentSince")]
        public Output<string> CurrentSince { get; private set; } = null!;

        /// <summary>
        /// The certificate fingerprint.
        /// </summary>
        [Output("fingerprint")]
        public Output<string> Fingerprint { get; private set; } = null!;

        /// <summary>
        /// The signing key use, whether for encryption or signing.
        /// </summary>
        [Output("keyUse")]
        public Output<string> KeyUse { get; private set; } = null!;

        /// <summary>
        /// The key ID of the signing key.
        /// </summary>
        [Output("kid")]
        public Output<string> Kid { get; private set; } = null!;

        /// <summary>
        /// True if the key is the next key.
        /// </summary>
        [Output("next")]
        public Output<bool> Next { get; private set; } = null!;

        /// <summary>
        /// The public certificate of the signing key in PKCS7 format.
        /// </summary>
        [Output("pkcs")]
        public Output<string> Pkcs { get; private set; } = null!;

        /// <summary>
        /// True if the key is the previous key.
        /// </summary>
        [Output("previous")]
        public Output<bool> Previous { get; private set; } = null!;

        /// <summary>
        /// The subject distinguished name (DN) of the certificate.
        /// </summary>
        [Output("subjectDn")]
        public Output<string> SubjectDn { get; private set; } = null!;

        /// <summary>
        /// The certificate thumbprint.
        /// </summary>
        [Output("thumbprint")]
        public Output<string> Thumbprint { get; private set; } = null!;

        /// <summary>
        /// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
        /// </summary>
        [Output("triggers")]
        public Output<ImmutableDictionary<string, string>> Triggers { get; private set; } = null!;


        /// <summary>
        /// Create a ConnectionKeys resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ConnectionKeys(string name, ConnectionKeysArgs args, CustomResourceOptions? options = null)
            : base("auth0:index/connectionKeys:ConnectionKeys", name, args ?? new ConnectionKeysArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ConnectionKeys(string name, Input<string> id, ConnectionKeysState? state = null, CustomResourceOptions? options = null)
            : base("auth0:index/connectionKeys:ConnectionKeys", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ConnectionKeys resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ConnectionKeys Get(string name, Input<string> id, ConnectionKeysState? state = null, CustomResourceOptions? options = null)
        {
            return new ConnectionKeys(name, id, state, options);
        }
    }

    public sealed class ConnectionKeysArgs : global::Pulumi.ResourceArgs
    {
        [Input("connectionId", required: true)]
        public Input<string> ConnectionId { get; set; } = null!;

        [Input("triggers", required: true)]
        private InputMap<string>? _triggers;

        /// <summary>
        /// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
        /// </summary>
        public InputMap<string> Triggers
        {
            get => _triggers ?? (_triggers = new InputMap<string>());
            set => _triggers = value;
        }

        public ConnectionKeysArgs()
        {
        }
        public static new ConnectionKeysArgs Empty => new ConnectionKeysArgs();
    }

    public sealed class ConnectionKeysState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The signing key algorithm.
        /// </summary>
        [Input("algorithm")]
        public Input<string>? Algorithm { get; set; }

        /// <summary>
        /// The public certificate of the signing key.
        /// </summary>
        [Input("cert")]
        public Input<string>? Cert { get; set; }

        [Input("connectionId")]
        public Input<string>? ConnectionId { get; set; }

        /// <summary>
        /// True if the key is the current key.
        /// </summary>
        [Input("current")]
        public Input<bool>? Current { get; set; }

        /// <summary>
        /// The date and time when the key became the current key.
        /// </summary>
        [Input("currentSince")]
        public Input<string>? CurrentSince { get; set; }

        /// <summary>
        /// The certificate fingerprint.
        /// </summary>
        [Input("fingerprint")]
        public Input<string>? Fingerprint { get; set; }

        /// <summary>
        /// The signing key use, whether for encryption or signing.
        /// </summary>
        [Input("keyUse")]
        public Input<string>? KeyUse { get; set; }

        /// <summary>
        /// The key ID of the signing key.
        /// </summary>
        [Input("kid")]
        public Input<string>? Kid { get; set; }

        /// <summary>
        /// True if the key is the next key.
        /// </summary>
        [Input("next")]
        public Input<bool>? Next { get; set; }

        /// <summary>
        /// The public certificate of the signing key in PKCS7 format.
        /// </summary>
        [Input("pkcs")]
        public Input<string>? Pkcs { get; set; }

        /// <summary>
        /// True if the key is the previous key.
        /// </summary>
        [Input("previous")]
        public Input<bool>? Previous { get; set; }

        /// <summary>
        /// The subject distinguished name (DN) of the certificate.
        /// </summary>
        [Input("subjectDn")]
        public Input<string>? SubjectDn { get; set; }

        /// <summary>
        /// The certificate thumbprint.
        /// </summary>
        [Input("thumbprint")]
        public Input<string>? Thumbprint { get; set; }

        [Input("triggers")]
        private InputMap<string>? _triggers;

        /// <summary>
        /// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
        /// </summary>
        public InputMap<string> Triggers
        {
            get => _triggers ?? (_triggers = new InputMap<string>());
            set => _triggers = value;
        }

        public ConnectionKeysState()
        {
        }
        public static new ConnectionKeysState Empty => new ConnectionKeysState();
    }
}
