// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package auth0

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-auth0/sdk/v3/go/auth0/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Client Assertion JWT is a more secure alternative to client secret authentication for OIDC and Okta Workforce connections. It uses a signed JWT instead of a shared secret to authenticate the client. The resource only supports key rotation. Use the ConnectionKeys data source to read existing keys. Removing the resource from configuration will NOT DELETE the key.
//
// !> The triggers field is only a placeholder for an arbitrary map used to signal the provider
// to perform a key rotation whenever any update is made.
// If the resource is removed from the configuration, the keys will not be deleted.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-auth0/sdk/v3/go/auth0"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myClient, err := auth0.NewClient(ctx, "my_client", &auth0.ClientArgs{
//				Name: pulumi.String("My-Auth0-Client"),
//			})
//			if err != nil {
//				return err
//			}
//			oidc, err := auth0.NewConnection(ctx, "oidc", &auth0.ConnectionArgs{
//				Name:     pulumi.String("OIDC-Connection"),
//				Strategy: pulumi.String("oidc"),
//				Options: &auth0.ConnectionOptionsArgs{
//					ClientId: myClient.ID(),
//					Scopes: pulumi.StringArray{
//						pulumi.String("ext_nested_groups"),
//						pulumi.String("openid"),
//					},
//					Issuer:                      pulumi.String("https://example.com"),
//					AuthorizationEndpoint:       pulumi.String("https://example.com"),
//					JwksUri:                     pulumi.String("https://example.com/jwks"),
//					Type:                        pulumi.String("front_channel"),
//					DiscoveryUrl:                pulumi.String("https://www.paypalobjects.com/.well-known/openid-configuration"),
//					TokenEndpointAuthMethod:     pulumi.String("private_key_jwt"),
//					TokenEndpointAuthSigningAlg: pulumi.String("RS256"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Resource used to rotate the keys for above OIDC connection
//			_, err = auth0.NewConnectionKeys(ctx, "my_keys", &auth0.ConnectionKeysArgs{
//				ConnectionId: oidc.ID(),
//				Triggers: pulumi.StringMap{
//					"version": pulumi.String("1"),
//					"date":    pulumi.String("2023-10-01T00:00:00Z"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ConnectionKeys struct {
	pulumi.CustomResourceState

	// The signing key algorithm.
	Algorithm pulumi.StringOutput `pulumi:"algorithm"`
	// The public certificate of the signing key.
	Cert         pulumi.StringOutput `pulumi:"cert"`
	ConnectionId pulumi.StringOutput `pulumi:"connectionId"`
	// True if the key is the current key.
	Current pulumi.BoolOutput `pulumi:"current"`
	// The date and time when the key became the current key.
	CurrentSince pulumi.StringOutput `pulumi:"currentSince"`
	// The certificate fingerprint.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// The signing key use, whether for encryption or signing.
	KeyUse pulumi.StringOutput `pulumi:"keyUse"`
	// The key ID of the signing key.
	Kid pulumi.StringOutput `pulumi:"kid"`
	// True if the key is the next key.
	Next pulumi.BoolOutput `pulumi:"next"`
	// The public certificate of the signing key in PKCS7 format.
	Pkcs pulumi.StringOutput `pulumi:"pkcs"`
	// True if the key is the previous key.
	Previous pulumi.BoolOutput `pulumi:"previous"`
	// The subject distinguished name (DN) of the certificate.
	SubjectDn pulumi.StringOutput `pulumi:"subjectDn"`
	// The certificate thumbprint.
	Thumbprint pulumi.StringOutput `pulumi:"thumbprint"`
	// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
	Triggers pulumi.StringMapOutput `pulumi:"triggers"`
}

// NewConnectionKeys registers a new resource with the given unique name, arguments, and options.
func NewConnectionKeys(ctx *pulumi.Context,
	name string, args *ConnectionKeysArgs, opts ...pulumi.ResourceOption) (*ConnectionKeys, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionId'")
	}
	if args.Triggers == nil {
		return nil, errors.New("invalid value for required argument 'Triggers'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ConnectionKeys
	err := ctx.RegisterResource("auth0:index/connectionKeys:ConnectionKeys", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConnectionKeys gets an existing ConnectionKeys resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConnectionKeys(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConnectionKeysState, opts ...pulumi.ResourceOption) (*ConnectionKeys, error) {
	var resource ConnectionKeys
	err := ctx.ReadResource("auth0:index/connectionKeys:ConnectionKeys", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ConnectionKeys resources.
type connectionKeysState struct {
	// The signing key algorithm.
	Algorithm *string `pulumi:"algorithm"`
	// The public certificate of the signing key.
	Cert         *string `pulumi:"cert"`
	ConnectionId *string `pulumi:"connectionId"`
	// True if the key is the current key.
	Current *bool `pulumi:"current"`
	// The date and time when the key became the current key.
	CurrentSince *string `pulumi:"currentSince"`
	// The certificate fingerprint.
	Fingerprint *string `pulumi:"fingerprint"`
	// The signing key use, whether for encryption or signing.
	KeyUse *string `pulumi:"keyUse"`
	// The key ID of the signing key.
	Kid *string `pulumi:"kid"`
	// True if the key is the next key.
	Next *bool `pulumi:"next"`
	// The public certificate of the signing key in PKCS7 format.
	Pkcs *string `pulumi:"pkcs"`
	// True if the key is the previous key.
	Previous *bool `pulumi:"previous"`
	// The subject distinguished name (DN) of the certificate.
	SubjectDn *string `pulumi:"subjectDn"`
	// The certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
	// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
	Triggers map[string]string `pulumi:"triggers"`
}

type ConnectionKeysState struct {
	// The signing key algorithm.
	Algorithm pulumi.StringPtrInput
	// The public certificate of the signing key.
	Cert         pulumi.StringPtrInput
	ConnectionId pulumi.StringPtrInput
	// True if the key is the current key.
	Current pulumi.BoolPtrInput
	// The date and time when the key became the current key.
	CurrentSince pulumi.StringPtrInput
	// The certificate fingerprint.
	Fingerprint pulumi.StringPtrInput
	// The signing key use, whether for encryption or signing.
	KeyUse pulumi.StringPtrInput
	// The key ID of the signing key.
	Kid pulumi.StringPtrInput
	// True if the key is the next key.
	Next pulumi.BoolPtrInput
	// The public certificate of the signing key in PKCS7 format.
	Pkcs pulumi.StringPtrInput
	// True if the key is the previous key.
	Previous pulumi.BoolPtrInput
	// The subject distinguished name (DN) of the certificate.
	SubjectDn pulumi.StringPtrInput
	// The certificate thumbprint.
	Thumbprint pulumi.StringPtrInput
	// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
	Triggers pulumi.StringMapInput
}

func (ConnectionKeysState) ElementType() reflect.Type {
	return reflect.TypeOf((*connectionKeysState)(nil)).Elem()
}

type connectionKeysArgs struct {
	ConnectionId string `pulumi:"connectionId"`
	// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
	Triggers map[string]string `pulumi:"triggers"`
}

// The set of arguments for constructing a ConnectionKeys resource.
type ConnectionKeysArgs struct {
	ConnectionId pulumi.StringInput
	// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
	Triggers pulumi.StringMapInput
}

func (ConnectionKeysArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*connectionKeysArgs)(nil)).Elem()
}

type ConnectionKeysInput interface {
	pulumi.Input

	ToConnectionKeysOutput() ConnectionKeysOutput
	ToConnectionKeysOutputWithContext(ctx context.Context) ConnectionKeysOutput
}

func (*ConnectionKeys) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectionKeys)(nil)).Elem()
}

func (i *ConnectionKeys) ToConnectionKeysOutput() ConnectionKeysOutput {
	return i.ToConnectionKeysOutputWithContext(context.Background())
}

func (i *ConnectionKeys) ToConnectionKeysOutputWithContext(ctx context.Context) ConnectionKeysOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectionKeysOutput)
}

// ConnectionKeysArrayInput is an input type that accepts ConnectionKeysArray and ConnectionKeysArrayOutput values.
// You can construct a concrete instance of `ConnectionKeysArrayInput` via:
//
//	ConnectionKeysArray{ ConnectionKeysArgs{...} }
type ConnectionKeysArrayInput interface {
	pulumi.Input

	ToConnectionKeysArrayOutput() ConnectionKeysArrayOutput
	ToConnectionKeysArrayOutputWithContext(context.Context) ConnectionKeysArrayOutput
}

type ConnectionKeysArray []ConnectionKeysInput

func (ConnectionKeysArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectionKeys)(nil)).Elem()
}

func (i ConnectionKeysArray) ToConnectionKeysArrayOutput() ConnectionKeysArrayOutput {
	return i.ToConnectionKeysArrayOutputWithContext(context.Background())
}

func (i ConnectionKeysArray) ToConnectionKeysArrayOutputWithContext(ctx context.Context) ConnectionKeysArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectionKeysArrayOutput)
}

// ConnectionKeysMapInput is an input type that accepts ConnectionKeysMap and ConnectionKeysMapOutput values.
// You can construct a concrete instance of `ConnectionKeysMapInput` via:
//
//	ConnectionKeysMap{ "key": ConnectionKeysArgs{...} }
type ConnectionKeysMapInput interface {
	pulumi.Input

	ToConnectionKeysMapOutput() ConnectionKeysMapOutput
	ToConnectionKeysMapOutputWithContext(context.Context) ConnectionKeysMapOutput
}

type ConnectionKeysMap map[string]ConnectionKeysInput

func (ConnectionKeysMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectionKeys)(nil)).Elem()
}

func (i ConnectionKeysMap) ToConnectionKeysMapOutput() ConnectionKeysMapOutput {
	return i.ToConnectionKeysMapOutputWithContext(context.Background())
}

func (i ConnectionKeysMap) ToConnectionKeysMapOutputWithContext(ctx context.Context) ConnectionKeysMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectionKeysMapOutput)
}

type ConnectionKeysOutput struct{ *pulumi.OutputState }

func (ConnectionKeysOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectionKeys)(nil)).Elem()
}

func (o ConnectionKeysOutput) ToConnectionKeysOutput() ConnectionKeysOutput {
	return o
}

func (o ConnectionKeysOutput) ToConnectionKeysOutputWithContext(ctx context.Context) ConnectionKeysOutput {
	return o
}

// The signing key algorithm.
func (o ConnectionKeysOutput) Algorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Algorithm }).(pulumi.StringOutput)
}

// The public certificate of the signing key.
func (o ConnectionKeysOutput) Cert() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Cert }).(pulumi.StringOutput)
}

func (o ConnectionKeysOutput) ConnectionId() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.ConnectionId }).(pulumi.StringOutput)
}

// True if the key is the current key.
func (o ConnectionKeysOutput) Current() pulumi.BoolOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.BoolOutput { return v.Current }).(pulumi.BoolOutput)
}

// The date and time when the key became the current key.
func (o ConnectionKeysOutput) CurrentSince() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.CurrentSince }).(pulumi.StringOutput)
}

// The certificate fingerprint.
func (o ConnectionKeysOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Fingerprint }).(pulumi.StringOutput)
}

// The signing key use, whether for encryption or signing.
func (o ConnectionKeysOutput) KeyUse() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.KeyUse }).(pulumi.StringOutput)
}

// The key ID of the signing key.
func (o ConnectionKeysOutput) Kid() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Kid }).(pulumi.StringOutput)
}

// True if the key is the next key.
func (o ConnectionKeysOutput) Next() pulumi.BoolOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.BoolOutput { return v.Next }).(pulumi.BoolOutput)
}

// The public certificate of the signing key in PKCS7 format.
func (o ConnectionKeysOutput) Pkcs() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Pkcs }).(pulumi.StringOutput)
}

// True if the key is the previous key.
func (o ConnectionKeysOutput) Previous() pulumi.BoolOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.BoolOutput { return v.Previous }).(pulumi.BoolOutput)
}

// The subject distinguished name (DN) of the certificate.
func (o ConnectionKeysOutput) SubjectDn() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.SubjectDn }).(pulumi.StringOutput)
}

// The certificate thumbprint.
func (o ConnectionKeysOutput) Thumbprint() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringOutput { return v.Thumbprint }).(pulumi.StringOutput)
}

// This is an arbitrary map, which when edited shall perform rotation of keys for the corresponding connection. It can host keys like version, timestamp of last rotation etc.The field has no association with API
func (o ConnectionKeysOutput) Triggers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ConnectionKeys) pulumi.StringMapOutput { return v.Triggers }).(pulumi.StringMapOutput)
}

type ConnectionKeysArrayOutput struct{ *pulumi.OutputState }

func (ConnectionKeysArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectionKeys)(nil)).Elem()
}

func (o ConnectionKeysArrayOutput) ToConnectionKeysArrayOutput() ConnectionKeysArrayOutput {
	return o
}

func (o ConnectionKeysArrayOutput) ToConnectionKeysArrayOutputWithContext(ctx context.Context) ConnectionKeysArrayOutput {
	return o
}

func (o ConnectionKeysArrayOutput) Index(i pulumi.IntInput) ConnectionKeysOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ConnectionKeys {
		return vs[0].([]*ConnectionKeys)[vs[1].(int)]
	}).(ConnectionKeysOutput)
}

type ConnectionKeysMapOutput struct{ *pulumi.OutputState }

func (ConnectionKeysMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectionKeys)(nil)).Elem()
}

func (o ConnectionKeysMapOutput) ToConnectionKeysMapOutput() ConnectionKeysMapOutput {
	return o
}

func (o ConnectionKeysMapOutput) ToConnectionKeysMapOutputWithContext(ctx context.Context) ConnectionKeysMapOutput {
	return o
}

func (o ConnectionKeysMapOutput) MapIndex(k pulumi.StringInput) ConnectionKeysOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ConnectionKeys {
		return vs[0].(map[string]*ConnectionKeys)[vs[1].(string)]
	}).(ConnectionKeysOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectionKeysInput)(nil)).Elem(), &ConnectionKeys{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectionKeysArrayInput)(nil)).Elem(), ConnectionKeysArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectionKeysMapInput)(nil)).Elem(), ConnectionKeysMap{})
	pulumi.RegisterOutputType(ConnectionKeysOutput{})
	pulumi.RegisterOutputType(ConnectionKeysArrayOutput{})
	pulumi.RegisterOutputType(ConnectionKeysMapOutput{})
}
