// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.auth0.outputs;

import com.pulumi.auth0.outputs.GetClientAddonSamlpLogout;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetClientAddonSamlp {
    /**
     * @return Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
     * 
     */
    private String audience;
    /**
     * @return Class reference of the authentication context.
     * 
     */
    private String authnContextClassRef;
    /**
     * @return Protocol binding used for SAML logout responses.
     * 
     */
    private String binding;
    /**
     * @return Indicates whether a UPN claim should be created. Defaults to `true`.
     * 
     */
    private Boolean createUpnClaim;
    /**
     * @return Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
     * 
     */
    private String destination;
    /**
     * @return Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
     * 
     */
    private String digestAlgorithm;
    /**
     * @return This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
     * 
     */
    private String flexibleMappings;
    /**
     * @return Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
     * 
     */
    private Boolean includeAttributeNameFormat;
    /**
     * @return Issuer of the SAML Assertion.
     * 
     */
    private String issuer;
    /**
     * @return Number of seconds during which the token is valid. Defaults to `3600` seconds.
     * 
     */
    private Integer lifetimeInSeconds;
    /**
     * @return Configuration settings for logout.
     * 
     */
    private List<GetClientAddonSamlpLogout> logouts;
    /**
     * @return Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
     * 
     */
    private Boolean mapIdentities;
    /**
     * @return Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
     * 
     */
    private Boolean mapUnknownClaimsAsIs;
    /**
     * @return Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
     * 
     */
    private Map<String,String> mappings;
    /**
     * @return Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
     * 
     */
    private String nameIdentifierFormat;
    /**
     * @return Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
     * 
     */
    private List<String> nameIdentifierProbes;
    /**
     * @return Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
     * 
     */
    private Boolean passthroughClaimsWithNoMapping;
    /**
     * @return Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
     * 
     */
    private String recipient;
    /**
     * @return Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
     * 
     */
    private Boolean signResponse;
    /**
     * @return Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
     * 
     */
    private String signatureAlgorithm;
    /**
     * @return Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\nMIGf...bpP/t3\n+JGNGIRMj1hF1rnb6QIDAQAB\n-----END PUBLIC KEY-----\n`.
     * 
     */
    private String signingCert;
    /**
     * @return Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
     * 
     */
    private Boolean typedAttributes;

    private GetClientAddonSamlp() {}
    /**
     * @return Audience of the SAML Assertion. Default will be the Issuer on SAMLRequest.
     * 
     */
    public String audience() {
        return this.audience;
    }
    /**
     * @return Class reference of the authentication context.
     * 
     */
    public String authnContextClassRef() {
        return this.authnContextClassRef;
    }
    /**
     * @return Protocol binding used for SAML logout responses.
     * 
     */
    public String binding() {
        return this.binding;
    }
    /**
     * @return Indicates whether a UPN claim should be created. Defaults to `true`.
     * 
     */
    public Boolean createUpnClaim() {
        return this.createUpnClaim;
    }
    /**
     * @return Destination of the SAML Response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest.
     * 
     */
    public String destination() {
        return this.destination;
    }
    /**
     * @return Algorithm used to calculate the digest of the SAML Assertion or response. Options include `sha1` and `sha256`. Defaults to `sha1`.
     * 
     */
    public String digestAlgorithm() {
        return this.digestAlgorithm;
    }
    /**
     * @return This is a supporting attribute to `mappings` field.Please note this is an experimental field. It should only be used when needed to send a map with keys as slices.
     * 
     */
    public String flexibleMappings() {
        return this.flexibleMappings;
    }
    /**
     * @return Indicates whether or not we should infer the NameFormat based on the attribute name. If set to `false`, the attribute NameFormat is not set in the assertion. Defaults to `true`.
     * 
     */
    public Boolean includeAttributeNameFormat() {
        return this.includeAttributeNameFormat;
    }
    /**
     * @return Issuer of the SAML Assertion.
     * 
     */
    public String issuer() {
        return this.issuer;
    }
    /**
     * @return Number of seconds during which the token is valid. Defaults to `3600` seconds.
     * 
     */
    public Integer lifetimeInSeconds() {
        return this.lifetimeInSeconds;
    }
    /**
     * @return Configuration settings for logout.
     * 
     */
    public List<GetClientAddonSamlpLogout> logouts() {
        return this.logouts;
    }
    /**
     * @return Indicates whether or not to add additional identity information in the token, such as the provider used and the `access_token`, if available. Defaults to `true`.
     * 
     */
    public Boolean mapIdentities() {
        return this.mapIdentities;
    }
    /**
     * @return Indicates whether to add a prefix of `http://schema.auth0.com` to any claims that are not mapped to the common profile when passed through in the output assertion. Defaults to `false`.
     * 
     */
    public Boolean mapUnknownClaimsAsIs() {
        return this.mapUnknownClaimsAsIs;
    }
    /**
     * @return Mappings between the Auth0 user profile property name (`name`) and the output attributes on the SAML attribute in the assertion (`value`).
     * 
     */
    public Map<String,String> mappings() {
        return this.mappings;
    }
    /**
     * @return Format of the name identifier. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
     * 
     */
    public String nameIdentifierFormat() {
        return this.nameIdentifierFormat;
    }
    /**
     * @return Attributes that can be used for Subject/NameID. Auth0 will try each of the attributes of this array in order and use the first value it finds.
     * 
     */
    public List<String> nameIdentifierProbes() {
        return this.nameIdentifierProbes;
    }
    /**
     * @return Indicates whether or not to passthrough claims that are not mapped to the common profile in the output assertion. Defaults to `true`.
     * 
     */
    public Boolean passthroughClaimsWithNoMapping() {
        return this.passthroughClaimsWithNoMapping;
    }
    /**
     * @return Recipient of the SAML Assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent.
     * 
     */
    public String recipient() {
        return this.recipient;
    }
    /**
     * @return Indicates whether or not the SAML Response should be signed instead of the SAML Assertion.
     * 
     */
    public Boolean signResponse() {
        return this.signResponse;
    }
    /**
     * @return Algorithm used to sign the SAML Assertion or response. Options include `rsa-sha1` and `rsa-sha256`. Defaults to `rsa-sha1`.
     * 
     */
    public String signatureAlgorithm() {
        return this.signatureAlgorithm;
    }
    /**
     * @return Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `-----BEGIN PUBLIC KEY-----\nMIGf...bpP/t3\n+JGNGIRMj1hF1rnb6QIDAQAB\n-----END PUBLIC KEY-----\n`.
     * 
     */
    public String signingCert() {
        return this.signingCert;
    }
    /**
     * @return Indicates whether or not we should infer the `xs:type` of the element. Types include `xs:string`, `xs:boolean`, `xs:double`, and `xs:anyType`. When set to `false`, all `xs:type` are `xs:anyType`. Defaults to `true`.
     * 
     */
    public Boolean typedAttributes() {
        return this.typedAttributes;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetClientAddonSamlp defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String audience;
        private String authnContextClassRef;
        private String binding;
        private Boolean createUpnClaim;
        private String destination;
        private String digestAlgorithm;
        private String flexibleMappings;
        private Boolean includeAttributeNameFormat;
        private String issuer;
        private Integer lifetimeInSeconds;
        private List<GetClientAddonSamlpLogout> logouts;
        private Boolean mapIdentities;
        private Boolean mapUnknownClaimsAsIs;
        private Map<String,String> mappings;
        private String nameIdentifierFormat;
        private List<String> nameIdentifierProbes;
        private Boolean passthroughClaimsWithNoMapping;
        private String recipient;
        private Boolean signResponse;
        private String signatureAlgorithm;
        private String signingCert;
        private Boolean typedAttributes;
        public Builder() {}
        public Builder(GetClientAddonSamlp defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.audience = defaults.audience;
    	      this.authnContextClassRef = defaults.authnContextClassRef;
    	      this.binding = defaults.binding;
    	      this.createUpnClaim = defaults.createUpnClaim;
    	      this.destination = defaults.destination;
    	      this.digestAlgorithm = defaults.digestAlgorithm;
    	      this.flexibleMappings = defaults.flexibleMappings;
    	      this.includeAttributeNameFormat = defaults.includeAttributeNameFormat;
    	      this.issuer = defaults.issuer;
    	      this.lifetimeInSeconds = defaults.lifetimeInSeconds;
    	      this.logouts = defaults.logouts;
    	      this.mapIdentities = defaults.mapIdentities;
    	      this.mapUnknownClaimsAsIs = defaults.mapUnknownClaimsAsIs;
    	      this.mappings = defaults.mappings;
    	      this.nameIdentifierFormat = defaults.nameIdentifierFormat;
    	      this.nameIdentifierProbes = defaults.nameIdentifierProbes;
    	      this.passthroughClaimsWithNoMapping = defaults.passthroughClaimsWithNoMapping;
    	      this.recipient = defaults.recipient;
    	      this.signResponse = defaults.signResponse;
    	      this.signatureAlgorithm = defaults.signatureAlgorithm;
    	      this.signingCert = defaults.signingCert;
    	      this.typedAttributes = defaults.typedAttributes;
        }

        @CustomType.Setter
        public Builder audience(String audience) {
            if (audience == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "audience");
            }
            this.audience = audience;
            return this;
        }
        @CustomType.Setter
        public Builder authnContextClassRef(String authnContextClassRef) {
            if (authnContextClassRef == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "authnContextClassRef");
            }
            this.authnContextClassRef = authnContextClassRef;
            return this;
        }
        @CustomType.Setter
        public Builder binding(String binding) {
            if (binding == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "binding");
            }
            this.binding = binding;
            return this;
        }
        @CustomType.Setter
        public Builder createUpnClaim(Boolean createUpnClaim) {
            if (createUpnClaim == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "createUpnClaim");
            }
            this.createUpnClaim = createUpnClaim;
            return this;
        }
        @CustomType.Setter
        public Builder destination(String destination) {
            if (destination == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "destination");
            }
            this.destination = destination;
            return this;
        }
        @CustomType.Setter
        public Builder digestAlgorithm(String digestAlgorithm) {
            if (digestAlgorithm == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "digestAlgorithm");
            }
            this.digestAlgorithm = digestAlgorithm;
            return this;
        }
        @CustomType.Setter
        public Builder flexibleMappings(String flexibleMappings) {
            if (flexibleMappings == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "flexibleMappings");
            }
            this.flexibleMappings = flexibleMappings;
            return this;
        }
        @CustomType.Setter
        public Builder includeAttributeNameFormat(Boolean includeAttributeNameFormat) {
            if (includeAttributeNameFormat == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "includeAttributeNameFormat");
            }
            this.includeAttributeNameFormat = includeAttributeNameFormat;
            return this;
        }
        @CustomType.Setter
        public Builder issuer(String issuer) {
            if (issuer == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "issuer");
            }
            this.issuer = issuer;
            return this;
        }
        @CustomType.Setter
        public Builder lifetimeInSeconds(Integer lifetimeInSeconds) {
            if (lifetimeInSeconds == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "lifetimeInSeconds");
            }
            this.lifetimeInSeconds = lifetimeInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder logouts(List<GetClientAddonSamlpLogout> logouts) {
            if (logouts == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "logouts");
            }
            this.logouts = logouts;
            return this;
        }
        public Builder logouts(GetClientAddonSamlpLogout... logouts) {
            return logouts(List.of(logouts));
        }
        @CustomType.Setter
        public Builder mapIdentities(Boolean mapIdentities) {
            if (mapIdentities == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "mapIdentities");
            }
            this.mapIdentities = mapIdentities;
            return this;
        }
        @CustomType.Setter
        public Builder mapUnknownClaimsAsIs(Boolean mapUnknownClaimsAsIs) {
            if (mapUnknownClaimsAsIs == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "mapUnknownClaimsAsIs");
            }
            this.mapUnknownClaimsAsIs = mapUnknownClaimsAsIs;
            return this;
        }
        @CustomType.Setter
        public Builder mappings(Map<String,String> mappings) {
            if (mappings == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "mappings");
            }
            this.mappings = mappings;
            return this;
        }
        @CustomType.Setter
        public Builder nameIdentifierFormat(String nameIdentifierFormat) {
            if (nameIdentifierFormat == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "nameIdentifierFormat");
            }
            this.nameIdentifierFormat = nameIdentifierFormat;
            return this;
        }
        @CustomType.Setter
        public Builder nameIdentifierProbes(List<String> nameIdentifierProbes) {
            if (nameIdentifierProbes == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "nameIdentifierProbes");
            }
            this.nameIdentifierProbes = nameIdentifierProbes;
            return this;
        }
        public Builder nameIdentifierProbes(String... nameIdentifierProbes) {
            return nameIdentifierProbes(List.of(nameIdentifierProbes));
        }
        @CustomType.Setter
        public Builder passthroughClaimsWithNoMapping(Boolean passthroughClaimsWithNoMapping) {
            if (passthroughClaimsWithNoMapping == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "passthroughClaimsWithNoMapping");
            }
            this.passthroughClaimsWithNoMapping = passthroughClaimsWithNoMapping;
            return this;
        }
        @CustomType.Setter
        public Builder recipient(String recipient) {
            if (recipient == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "recipient");
            }
            this.recipient = recipient;
            return this;
        }
        @CustomType.Setter
        public Builder signResponse(Boolean signResponse) {
            if (signResponse == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "signResponse");
            }
            this.signResponse = signResponse;
            return this;
        }
        @CustomType.Setter
        public Builder signatureAlgorithm(String signatureAlgorithm) {
            if (signatureAlgorithm == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "signatureAlgorithm");
            }
            this.signatureAlgorithm = signatureAlgorithm;
            return this;
        }
        @CustomType.Setter
        public Builder signingCert(String signingCert) {
            if (signingCert == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "signingCert");
            }
            this.signingCert = signingCert;
            return this;
        }
        @CustomType.Setter
        public Builder typedAttributes(Boolean typedAttributes) {
            if (typedAttributes == null) {
              throw new MissingRequiredPropertyException("GetClientAddonSamlp", "typedAttributes");
            }
            this.typedAttributes = typedAttributes;
            return this;
        }
        public GetClientAddonSamlp build() {
            final var _resultValue = new GetClientAddonSamlp();
            _resultValue.audience = audience;
            _resultValue.authnContextClassRef = authnContextClassRef;
            _resultValue.binding = binding;
            _resultValue.createUpnClaim = createUpnClaim;
            _resultValue.destination = destination;
            _resultValue.digestAlgorithm = digestAlgorithm;
            _resultValue.flexibleMappings = flexibleMappings;
            _resultValue.includeAttributeNameFormat = includeAttributeNameFormat;
            _resultValue.issuer = issuer;
            _resultValue.lifetimeInSeconds = lifetimeInSeconds;
            _resultValue.logouts = logouts;
            _resultValue.mapIdentities = mapIdentities;
            _resultValue.mapUnknownClaimsAsIs = mapUnknownClaimsAsIs;
            _resultValue.mappings = mappings;
            _resultValue.nameIdentifierFormat = nameIdentifierFormat;
            _resultValue.nameIdentifierProbes = nameIdentifierProbes;
            _resultValue.passthroughClaimsWithNoMapping = passthroughClaimsWithNoMapping;
            _resultValue.recipient = recipient;
            _resultValue.signResponse = signResponse;
            _resultValue.signatureAlgorithm = signatureAlgorithm;
            _resultValue.signingCert = signingCert;
            _resultValue.typedAttributes = typedAttributes;
            return _resultValue;
        }
    }
}
