// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.auth0.outputs;

import com.pulumi.auth0.outputs.GetCustomDomainCertificate;
import com.pulumi.auth0.outputs.GetCustomDomainVerification;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetCustomDomainResult {
    /**
     * @return The Custom Domain certificate.
     * 
     */
    private List<GetCustomDomainCertificate> certificates;
    /**
     * @return The HTTP header to fetch the client&#39;s IP address. Cannot be set on auth0Managed domains.
     * 
     */
    private String customClientIpHeader;
    /**
     * @return The ID of the Custom Domain.
     * 
     */
    private @Nullable String customDomainId;
    /**
     * @return Name of the custom domain.
     * 
     */
    private String domain;
    /**
     * @return Metadata associated with the Custom Domain. Maximum of 10 metadata properties allowed. (EA only).
     * 
     */
    private Map<String,String> domainMetadata;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return Once the configuration status is `ready`, the DNS name of the Auth0 origin server that handles traffic for the custom domain.
     * 
     */
    private String originDomainName;
    /**
     * @return Indicates whether this is a primary domain.
     * 
     */
    private Boolean primary;
    /**
     * @return Relying Party ID (rpId) to be used for Passkeys on this custom domain. If not provided or set to null, the full domain will be used.
     * 
     */
    private String relyingPartyIdentifier;
    /**
     * @return Configuration status for the custom domain. Options include `disabled`, `pending`, `pendingVerification`, `ready` and `failed`.
     * 
     */
    private String status;
    /**
     * @return TLS policy for the custom domain. Available options are: `compatible` or `recommended`. Compatible includes TLS 1.0, 1.1, 1.2, and recommended only includes TLS 1.2. Cannot be set on selfManaged domains.
     * 
     */
    private String tlsPolicy;
    /**
     * @return Provisioning type for the custom domain. Options include `auth0ManagedCerts` and `selfManagedCerts`.
     * 
     */
    private String type;
    /**
     * @return Configuration settings for verification.
     * 
     */
    private List<GetCustomDomainVerification> verifications;

    private GetCustomDomainResult() {}
    /**
     * @return The Custom Domain certificate.
     * 
     */
    public List<GetCustomDomainCertificate> certificates() {
        return this.certificates;
    }
    /**
     * @return The HTTP header to fetch the client&#39;s IP address. Cannot be set on auth0Managed domains.
     * 
     */
    public String customClientIpHeader() {
        return this.customClientIpHeader;
    }
    /**
     * @return The ID of the Custom Domain.
     * 
     */
    public Optional<String> customDomainId() {
        return Optional.ofNullable(this.customDomainId);
    }
    /**
     * @return Name of the custom domain.
     * 
     */
    public String domain() {
        return this.domain;
    }
    /**
     * @return Metadata associated with the Custom Domain. Maximum of 10 metadata properties allowed. (EA only).
     * 
     */
    public Map<String,String> domainMetadata() {
        return this.domainMetadata;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Once the configuration status is `ready`, the DNS name of the Auth0 origin server that handles traffic for the custom domain.
     * 
     */
    public String originDomainName() {
        return this.originDomainName;
    }
    /**
     * @return Indicates whether this is a primary domain.
     * 
     */
    public Boolean primary() {
        return this.primary;
    }
    /**
     * @return Relying Party ID (rpId) to be used for Passkeys on this custom domain. If not provided or set to null, the full domain will be used.
     * 
     */
    public String relyingPartyIdentifier() {
        return this.relyingPartyIdentifier;
    }
    /**
     * @return Configuration status for the custom domain. Options include `disabled`, `pending`, `pendingVerification`, `ready` and `failed`.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return TLS policy for the custom domain. Available options are: `compatible` or `recommended`. Compatible includes TLS 1.0, 1.1, 1.2, and recommended only includes TLS 1.2. Cannot be set on selfManaged domains.
     * 
     */
    public String tlsPolicy() {
        return this.tlsPolicy;
    }
    /**
     * @return Provisioning type for the custom domain. Options include `auth0ManagedCerts` and `selfManagedCerts`.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return Configuration settings for verification.
     * 
     */
    public List<GetCustomDomainVerification> verifications() {
        return this.verifications;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetCustomDomainResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetCustomDomainCertificate> certificates;
        private String customClientIpHeader;
        private @Nullable String customDomainId;
        private String domain;
        private Map<String,String> domainMetadata;
        private String id;
        private String originDomainName;
        private Boolean primary;
        private String relyingPartyIdentifier;
        private String status;
        private String tlsPolicy;
        private String type;
        private List<GetCustomDomainVerification> verifications;
        public Builder() {}
        public Builder(GetCustomDomainResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.certificates = defaults.certificates;
    	      this.customClientIpHeader = defaults.customClientIpHeader;
    	      this.customDomainId = defaults.customDomainId;
    	      this.domain = defaults.domain;
    	      this.domainMetadata = defaults.domainMetadata;
    	      this.id = defaults.id;
    	      this.originDomainName = defaults.originDomainName;
    	      this.primary = defaults.primary;
    	      this.relyingPartyIdentifier = defaults.relyingPartyIdentifier;
    	      this.status = defaults.status;
    	      this.tlsPolicy = defaults.tlsPolicy;
    	      this.type = defaults.type;
    	      this.verifications = defaults.verifications;
        }

        @CustomType.Setter
        public Builder certificates(List<GetCustomDomainCertificate> certificates) {
            if (certificates == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "certificates");
            }
            this.certificates = certificates;
            return this;
        }
        public Builder certificates(GetCustomDomainCertificate... certificates) {
            return certificates(List.of(certificates));
        }
        @CustomType.Setter
        public Builder customClientIpHeader(String customClientIpHeader) {
            if (customClientIpHeader == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "customClientIpHeader");
            }
            this.customClientIpHeader = customClientIpHeader;
            return this;
        }
        @CustomType.Setter
        public Builder customDomainId(@Nullable String customDomainId) {

            this.customDomainId = customDomainId;
            return this;
        }
        @CustomType.Setter
        public Builder domain(String domain) {
            if (domain == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "domain");
            }
            this.domain = domain;
            return this;
        }
        @CustomType.Setter
        public Builder domainMetadata(Map<String,String> domainMetadata) {
            if (domainMetadata == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "domainMetadata");
            }
            this.domainMetadata = domainMetadata;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder originDomainName(String originDomainName) {
            if (originDomainName == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "originDomainName");
            }
            this.originDomainName = originDomainName;
            return this;
        }
        @CustomType.Setter
        public Builder primary(Boolean primary) {
            if (primary == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "primary");
            }
            this.primary = primary;
            return this;
        }
        @CustomType.Setter
        public Builder relyingPartyIdentifier(String relyingPartyIdentifier) {
            if (relyingPartyIdentifier == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "relyingPartyIdentifier");
            }
            this.relyingPartyIdentifier = relyingPartyIdentifier;
            return this;
        }
        @CustomType.Setter
        public Builder status(String status) {
            if (status == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "status");
            }
            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder tlsPolicy(String tlsPolicy) {
            if (tlsPolicy == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "tlsPolicy");
            }
            this.tlsPolicy = tlsPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "type");
            }
            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder verifications(List<GetCustomDomainVerification> verifications) {
            if (verifications == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainResult", "verifications");
            }
            this.verifications = verifications;
            return this;
        }
        public Builder verifications(GetCustomDomainVerification... verifications) {
            return verifications(List.of(verifications));
        }
        public GetCustomDomainResult build() {
            final var _resultValue = new GetCustomDomainResult();
            _resultValue.certificates = certificates;
            _resultValue.customClientIpHeader = customClientIpHeader;
            _resultValue.customDomainId = customDomainId;
            _resultValue.domain = domain;
            _resultValue.domainMetadata = domainMetadata;
            _resultValue.id = id;
            _resultValue.originDomainName = originDomainName;
            _resultValue.primary = primary;
            _resultValue.relyingPartyIdentifier = relyingPartyIdentifier;
            _resultValue.status = status;
            _resultValue.tlsPolicy = tlsPolicy;
            _resultValue.type = type;
            _resultValue.verifications = verifications;
            return _resultValue;
        }
    }
}
