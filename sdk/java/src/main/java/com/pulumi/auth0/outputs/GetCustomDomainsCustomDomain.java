// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.auth0.outputs;

import com.pulumi.auth0.outputs.GetCustomDomainsCustomDomainCertificate;
import com.pulumi.auth0.outputs.GetCustomDomainsCustomDomainVerification;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetCustomDomainsCustomDomain {
    /**
     * @return The Custom Domain certificate.
     * 
     */
    private List<GetCustomDomainsCustomDomainCertificate> certificates;
    /**
     * @return The HTTP header to fetch the client&#39;s IP address. Cannot be set on auth0Managed domains.
     * 
     */
    private String customClientIpHeader;
    /**
     * @return Name of the custom domain.
     * 
     */
    private String domain;
    /**
     * @return Metadata associated with the Custom Domain. Maximum of 10 metadata properties allowed. (EA only).
     * 
     */
    private Map<String,String> domainMetadata;
    /**
     * @return Once the configuration status is `ready`, the DNS name of the Auth0 origin server that handles traffic for the custom domain.
     * 
     */
    private String originDomainName;
    /**
     * @return Indicates whether this is a primary domain.
     * 
     */
    private Boolean primary;
    /**
     * @return Configuration status for the custom domain. Options include `disabled`, `pending`, `pendingVerification`, `ready` and `failed`.
     * 
     */
    private String status;
    /**
     * @return TLS policy for the custom domain. Available options are: `compatible` or `recommended`. Compatible includes TLS 1.0, 1.1, 1.2, and recommended only includes TLS 1.2. Cannot be set on selfManaged domains.
     * 
     */
    private String tlsPolicy;
    /**
     * @return Provisioning type for the custom domain. Options include `auth0ManagedCerts` and `selfManagedCerts`.
     * 
     */
    private String type;
    /**
     * @return Configuration settings for verification.
     * 
     */
    private List<GetCustomDomainsCustomDomainVerification> verifications;

    private GetCustomDomainsCustomDomain() {}
    /**
     * @return The Custom Domain certificate.
     * 
     */
    public List<GetCustomDomainsCustomDomainCertificate> certificates() {
        return this.certificates;
    }
    /**
     * @return The HTTP header to fetch the client&#39;s IP address. Cannot be set on auth0Managed domains.
     * 
     */
    public String customClientIpHeader() {
        return this.customClientIpHeader;
    }
    /**
     * @return Name of the custom domain.
     * 
     */
    public String domain() {
        return this.domain;
    }
    /**
     * @return Metadata associated with the Custom Domain. Maximum of 10 metadata properties allowed. (EA only).
     * 
     */
    public Map<String,String> domainMetadata() {
        return this.domainMetadata;
    }
    /**
     * @return Once the configuration status is `ready`, the DNS name of the Auth0 origin server that handles traffic for the custom domain.
     * 
     */
    public String originDomainName() {
        return this.originDomainName;
    }
    /**
     * @return Indicates whether this is a primary domain.
     * 
     */
    public Boolean primary() {
        return this.primary;
    }
    /**
     * @return Configuration status for the custom domain. Options include `disabled`, `pending`, `pendingVerification`, `ready` and `failed`.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return TLS policy for the custom domain. Available options are: `compatible` or `recommended`. Compatible includes TLS 1.0, 1.1, 1.2, and recommended only includes TLS 1.2. Cannot be set on selfManaged domains.
     * 
     */
    public String tlsPolicy() {
        return this.tlsPolicy;
    }
    /**
     * @return Provisioning type for the custom domain. Options include `auth0ManagedCerts` and `selfManagedCerts`.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return Configuration settings for verification.
     * 
     */
    public List<GetCustomDomainsCustomDomainVerification> verifications() {
        return this.verifications;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetCustomDomainsCustomDomain defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetCustomDomainsCustomDomainCertificate> certificates;
        private String customClientIpHeader;
        private String domain;
        private Map<String,String> domainMetadata;
        private String originDomainName;
        private Boolean primary;
        private String status;
        private String tlsPolicy;
        private String type;
        private List<GetCustomDomainsCustomDomainVerification> verifications;
        public Builder() {}
        public Builder(GetCustomDomainsCustomDomain defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.certificates = defaults.certificates;
    	      this.customClientIpHeader = defaults.customClientIpHeader;
    	      this.domain = defaults.domain;
    	      this.domainMetadata = defaults.domainMetadata;
    	      this.originDomainName = defaults.originDomainName;
    	      this.primary = defaults.primary;
    	      this.status = defaults.status;
    	      this.tlsPolicy = defaults.tlsPolicy;
    	      this.type = defaults.type;
    	      this.verifications = defaults.verifications;
        }

        @CustomType.Setter
        public Builder certificates(List<GetCustomDomainsCustomDomainCertificate> certificates) {
            if (certificates == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "certificates");
            }
            this.certificates = certificates;
            return this;
        }
        public Builder certificates(GetCustomDomainsCustomDomainCertificate... certificates) {
            return certificates(List.of(certificates));
        }
        @CustomType.Setter
        public Builder customClientIpHeader(String customClientIpHeader) {
            if (customClientIpHeader == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "customClientIpHeader");
            }
            this.customClientIpHeader = customClientIpHeader;
            return this;
        }
        @CustomType.Setter
        public Builder domain(String domain) {
            if (domain == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "domain");
            }
            this.domain = domain;
            return this;
        }
        @CustomType.Setter
        public Builder domainMetadata(Map<String,String> domainMetadata) {
            if (domainMetadata == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "domainMetadata");
            }
            this.domainMetadata = domainMetadata;
            return this;
        }
        @CustomType.Setter
        public Builder originDomainName(String originDomainName) {
            if (originDomainName == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "originDomainName");
            }
            this.originDomainName = originDomainName;
            return this;
        }
        @CustomType.Setter
        public Builder primary(Boolean primary) {
            if (primary == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "primary");
            }
            this.primary = primary;
            return this;
        }
        @CustomType.Setter
        public Builder status(String status) {
            if (status == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "status");
            }
            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder tlsPolicy(String tlsPolicy) {
            if (tlsPolicy == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "tlsPolicy");
            }
            this.tlsPolicy = tlsPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "type");
            }
            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder verifications(List<GetCustomDomainsCustomDomainVerification> verifications) {
            if (verifications == null) {
              throw new MissingRequiredPropertyException("GetCustomDomainsCustomDomain", "verifications");
            }
            this.verifications = verifications;
            return this;
        }
        public Builder verifications(GetCustomDomainsCustomDomainVerification... verifications) {
            return verifications(List.of(verifications));
        }
        public GetCustomDomainsCustomDomain build() {
            final var _resultValue = new GetCustomDomainsCustomDomain();
            _resultValue.certificates = certificates;
            _resultValue.customClientIpHeader = customClientIpHeader;
            _resultValue.domain = domain;
            _resultValue.domainMetadata = domainMetadata;
            _resultValue.originDomainName = originDomainName;
            _resultValue.primary = primary;
            _resultValue.status = status;
            _resultValue.tlsPolicy = tlsPolicy;
            _resultValue.type = type;
            _resultValue.verifications = verifications;
            return _resultValue;
        }
    }
}
