// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.auth0.outputs;

import com.pulumi.auth0.outputs.GetConnectionOptionAttribute;
import com.pulumi.auth0.outputs.GetConnectionOptionAttributeMap;
import com.pulumi.auth0.outputs.GetConnectionOptionConnectionSetting;
import com.pulumi.auth0.outputs.GetConnectionOptionDecryptionKey;
import com.pulumi.auth0.outputs.GetConnectionOptionGatewayAuthentication;
import com.pulumi.auth0.outputs.GetConnectionOptionIdpInitiated;
import com.pulumi.auth0.outputs.GetConnectionOptionMfa;
import com.pulumi.auth0.outputs.GetConnectionOptionPasswordComplexityOption;
import com.pulumi.auth0.outputs.GetConnectionOptionPasswordDictionary;
import com.pulumi.auth0.outputs.GetConnectionOptionPasswordHistory;
import com.pulumi.auth0.outputs.GetConnectionOptionPasswordNoPersonalInfo;
import com.pulumi.auth0.outputs.GetConnectionOptionSigningKey;
import com.pulumi.auth0.outputs.GetConnectionOptionTotp;
import com.pulumi.auth0.outputs.GetConnectionOptionValidation;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetConnectionOption {
    /**
     * @return ADFS URL where to fetch the metadata source.
     * 
     */
    private String adfsServer;
    /**
     * @return List of allowed audiences.
     * 
     */
    private List<String> allowedAudiences;
    /**
     * @return Enable API Access to users.
     * 
     */
    private Boolean apiEnableUsers;
    /**
     * @return App ID.
     * 
     */
    private String appId;
    /**
     * @return OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
     * 
     */
    private List<GetConnectionOptionAttributeMap> attributeMaps;
    /**
     * @return Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
     * 
     */
    private List<GetConnectionOptionAttribute> attributes;
    /**
     * @return Query string parameters to be included as part of the generated passwordless email link.
     * 
     */
    private Map<String,String> authParams;
    /**
     * @return Authorization endpoint.
     * 
     */
    private String authorizationEndpoint;
    /**
     * @return Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
     * 
     */
    private Boolean bruteForceProtection;
    /**
     * @return The strategy&#39;s client ID.
     * 
     */
    private String clientId;
    /**
     * @return The strategy&#39;s client secret.
     * 
     */
    private String clientSecret;
    /**
     * @return Salesforce community base URL.
     * 
     */
    private String communityBaseUrl;
    /**
     * @return A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
     * 
     */
    private Map<String,String> configuration;
    /**
     * @return Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
     * 
     */
    private List<GetConnectionOptionConnectionSetting> connectionSettings;
    /**
     * @return A map of scripts used to integrate with a custom database.
     * 
     */
    private Map<String,String> customScripts;
    /**
     * @return When enabled, additional debug information will be generated.
     * 
     */
    private Boolean debug;
    /**
     * @return The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     * 
     */
    private List<GetConnectionOptionDecryptionKey> decryptionKeys;
    /**
     * @return Sign Request Algorithm Digest.
     * 
     */
    private String digestAlgorithm;
    /**
     * @return Indicates whether to disable the cache or not.
     * 
     */
    private Boolean disableCache;
    /**
     * @return Indicates whether to remove the forgot password link within the New Universal Login.
     * 
     */
    private Boolean disableSelfServiceChangePassword;
    /**
     * @return When enabled, will disable sign out.
     * 
     */
    private Boolean disableSignOut;
    /**
     * @return Indicates whether to allow user sign-ups to your application.
     * 
     */
    private Boolean disableSignup;
    /**
     * @return OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
     * 
     */
    private String discoveryUrl;
    /**
     * @return Domain name.
     * 
     */
    private String domain;
    /**
     * @return List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
     * 
     */
    private List<String> domainAliases;
    /**
     * @return Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
     * 
     */
    private Boolean enableScriptContext;
    /**
     * @return Set to `true` to use a legacy user store.
     * 
     */
    private Boolean enabledDatabaseCustomization;
    /**
     * @return Custom Entity ID for the connection.
     * 
     */
    private String entityId;
    /**
     * @return Federation Metadata for the ADFS connection.
     * 
     */
    private String fedMetadataXml;
    /**
     * @return If you&#39;re configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
     * 
     */
    private String fieldsMap;
    /**
     * @return Specifies whether or not request info should be forwarded to sms gateway.
     * 
     */
    private Boolean forwardRequestInfo;
    /**
     * @return Address to use as the sender.
     * 
     */
    private String from;
    /**
     * @return Defines the parameters used to generate the auth token for the custom gateway.
     * 
     */
    private List<GetConnectionOptionGatewayAuthentication> gatewayAuthentications;
    /**
     * @return Defines a custom sms gateway to use instead of Twilio.
     * 
     */
    private String gatewayUrl;
    /**
     * @return Icon URL.
     * 
     */
    private String iconUrl;
    /**
     * @return Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
     * 
     */
    private String identityApi;
    /**
     * @return Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
     * 
     */
    private List<GetConnectionOptionIdpInitiated> idpInitiateds;
    /**
     * @return Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
     * 
     */
    private Boolean importMode;
    /**
     * @return A list of IPs.
     * 
     */
    private List<String> ips;
    /**
     * @return Issuer URL, e.g. `https://auth.example.com`.
     * 
     */
    private String issuer;
    /**
     * @return JWKS URI.
     * 
     */
    private String jwksUri;
    /**
     * @return Apple Key ID.
     * 
     */
    private String keyId;
    /**
     * @return By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to &#39;id&#39; instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
     * 
     */
    private Boolean mapUserIdToId;
    /**
     * @return Maximum number of groups to retrieve.
     * 
     */
    private String maxGroupsToRetrieve;
    /**
     * @return SID for Copilot. Used when SMS Source is Copilot.
     * 
     */
    private String messagingServiceSid;
    /**
     * @return The URL of the SAML metadata document.
     * 
     */
    private String metadataUrl;
    /**
     * @return The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
     * 
     */
    private String metadataXml;
    /**
     * @return Configuration options for multifactor authentication.
     * 
     */
    private List<GetConnectionOptionMfa> mfas;
    /**
     * @return The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
     * 
     */
    private String name;
    /**
     * @return If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
     * 
     */
    private List<String> nonPersistentAttrs;
    /**
     * @return Configuration settings for password complexity.
     * 
     */
    private List<GetConnectionOptionPasswordComplexityOption> passwordComplexityOptions;
    /**
     * @return Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
     * 
     */
    private List<GetConnectionOptionPasswordDictionary> passwordDictionaries;
    /**
     * @return Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
     * 
     */
    private List<GetConnectionOptionPasswordHistory> passwordHistories;
    /**
     * @return Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user&#39;s personal data, including user&#39;s `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user&#39;s `email`, or first part of the user&#39;s `email`.
     * 
     */
    private List<GetConnectionOptionPasswordNoPersonalInfo> passwordNoPersonalInfos;
    /**
     * @return Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
     * 
     */
    private String passwordPolicy;
    /**
     * @return Ping Federate Server URL.
     * 
     */
    private String pingFederateBaseUrl;
    /**
     * @return Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
     * 
     */
    private Boolean pkceEnabled;
    /**
     * @return Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
     * 
     */
    private List<String> precedences;
    /**
     * @return The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
     * 
     */
    private String protocolBinding;
    /**
     * @return Defines the custom `sms_gateway` provider.
     * 
     */
    private String provider;
    /**
     * @return Template that formats the SAML request.
     * 
     */
    private String requestTemplate;
    /**
     * @return Indicates whether the user is required to provide a username in addition to an email address.
     * 
     */
    private Boolean requiresUsername;
    /**
     * @return Permissions to grant to the connection. Within the Auth0 dashboard these appear under the &#34;Attributes&#34; and &#34;Extended Attributes&#34; sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
     * 
     */
    private List<String> scopes;
    /**
     * @return A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
     * 
     */
    private Map<String,String> scripts;
    /**
     * @return Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
     * 
     */
    private String setUserRootAttributes;
    /**
     * @return Choose how Auth0 sets the email_verified field in the user profile.
     * 
     */
    private String shouldTrustEmailVerifiedConnection;
    /**
     * @return SAML single login URL for the connection.
     * 
     */
    private String signInEndpoint;
    /**
     * @return SAML single logout URL for the connection.
     * 
     */
    private String signOutEndpoint;
    /**
     * @return When enabled, the SAML authentication request will be signed.
     * 
     */
    private Boolean signSamlRequest;
    /**
     * @return Sign Request Algorithm.
     * 
     */
    private String signatureAlgorithm;
    /**
     * @return X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
     * 
     */
    private String signingCert;
    /**
     * @return The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     * 
     */
    private List<GetConnectionOptionSigningKey> signingKeys;
    /**
     * @return Version 1 is deprecated, use version 2.
     * 
     */
    private Integer strategyVersion;
    /**
     * @return Subject line of the email.
     * 
     */
    private String subject;
    /**
     * @return Syntax of the template body.
     * 
     */
    private String syntax;
    /**
     * @return Apple Team ID.
     * 
     */
    private String teamId;
    /**
     * @return Body of the template.
     * 
     */
    private String template;
    /**
     * @return Tenant domain name.
     * 
     */
    private String tenantDomain;
    /**
     * @return Token endpoint.
     * 
     */
    private String tokenEndpoint;
    /**
     * @return Configuration options for one-time passwords.
     * 
     */
    private List<GetConnectionOptionTotp> totps;
    /**
     * @return SID for your Twilio account.
     * 
     */
    private String twilioSid;
    /**
     * @return AuthToken for your Twilio account.
     * 
     */
    private String twilioToken;
    /**
     * @return Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
     * 
     */
    private String type;
    /**
     * @return You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
     * 
     */
    private String upstreamParams;
    /**
     * @return Indicates whether to use cert auth or not.
     * 
     */
    private Boolean useCertAuth;
    /**
     * @return Indicates whether to use Kerberos or not.
     * 
     */
    private Boolean useKerberos;
    /**
     * @return Whether to use WS-Fed.
     * 
     */
    private Boolean useWsfed;
    /**
     * @return Attribute in the token that will be mapped to the user_id property in Auth0.
     * 
     */
    private String userIdAttribute;
    /**
     * @return User info endpoint.
     * 
     */
    private String userinfoEndpoint;
    /**
     * @return Validation of the minimum and maximum values allowed for a user to have as username.
     * 
     */
    private List<GetConnectionOptionValidation> validations;
    /**
     * @return Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you&#39;re using this for a multi-tenant application in Azure AD.
     * 
     */
    private Boolean waadCommonEndpoint;
    /**
     * @return Protocol to use.
     * 
     */
    private String waadProtocol;

    private GetConnectionOption() {}
    /**
     * @return ADFS URL where to fetch the metadata source.
     * 
     */
    public String adfsServer() {
        return this.adfsServer;
    }
    /**
     * @return List of allowed audiences.
     * 
     */
    public List<String> allowedAudiences() {
        return this.allowedAudiences;
    }
    /**
     * @return Enable API Access to users.
     * 
     */
    public Boolean apiEnableUsers() {
        return this.apiEnableUsers;
    }
    /**
     * @return App ID.
     * 
     */
    public String appId() {
        return this.appId;
    }
    /**
     * @return OpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly. Click [here](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc#map-claims-for-oidc-connections) for more info.
     * 
     */
    public List<GetConnectionOptionAttributeMap> attributeMaps() {
        return this.attributeMaps;
    }
    /**
     * @return Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
     * 
     */
    public List<GetConnectionOptionAttribute> attributes() {
        return this.attributes;
    }
    /**
     * @return Query string parameters to be included as part of the generated passwordless email link.
     * 
     */
    public Map<String,String> authParams() {
        return this.authParams;
    }
    /**
     * @return Authorization endpoint.
     * 
     */
    public String authorizationEndpoint() {
        return this.authorizationEndpoint;
    }
    /**
     * @return Indicates whether to enable brute force protection, which will limit the number of signups and failed logins from a suspicious IP address.
     * 
     */
    public Boolean bruteForceProtection() {
        return this.bruteForceProtection;
    }
    /**
     * @return The strategy&#39;s client ID.
     * 
     */
    public String clientId() {
        return this.clientId;
    }
    /**
     * @return The strategy&#39;s client secret.
     * 
     */
    public String clientSecret() {
        return this.clientSecret;
    }
    /**
     * @return Salesforce community base URL.
     * 
     */
    public String communityBaseUrl() {
        return this.communityBaseUrl;
    }
    /**
     * @return A case-sensitive map of key value pairs used as configuration variables for the `custom_script`.
     * 
     */
    public Map<String,String> configuration() {
        return this.configuration;
    }
    /**
     * @return Proof Key for Code Exchange (PKCE) configuration settings for an OIDC or Okta Workforce connection.
     * 
     */
    public List<GetConnectionOptionConnectionSetting> connectionSettings() {
        return this.connectionSettings;
    }
    /**
     * @return A map of scripts used to integrate with a custom database.
     * 
     */
    public Map<String,String> customScripts() {
        return this.customScripts;
    }
    /**
     * @return When enabled, additional debug information will be generated.
     * 
     */
    public Boolean debug() {
        return this.debug;
    }
    /**
     * @return The key used to decrypt encrypted responses from the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     * 
     */
    public List<GetConnectionOptionDecryptionKey> decryptionKeys() {
        return this.decryptionKeys;
    }
    /**
     * @return Sign Request Algorithm Digest.
     * 
     */
    public String digestAlgorithm() {
        return this.digestAlgorithm;
    }
    /**
     * @return Indicates whether to disable the cache or not.
     * 
     */
    public Boolean disableCache() {
        return this.disableCache;
    }
    /**
     * @return Indicates whether to remove the forgot password link within the New Universal Login.
     * 
     */
    public Boolean disableSelfServiceChangePassword() {
        return this.disableSelfServiceChangePassword;
    }
    /**
     * @return When enabled, will disable sign out.
     * 
     */
    public Boolean disableSignOut() {
        return this.disableSignOut;
    }
    /**
     * @return Indicates whether to allow user sign-ups to your application.
     * 
     */
    public Boolean disableSignup() {
        return this.disableSignup;
    }
    /**
     * @return OpenID discovery URL, e.g. `https://auth.example.com/.well-known/openid-configuration`.
     * 
     */
    public String discoveryUrl() {
        return this.discoveryUrl;
    }
    /**
     * @return Domain name.
     * 
     */
    public String domain() {
        return this.domain;
    }
    /**
     * @return List of the domains that can be authenticated using the identity provider. Only needed for Identifier First authentication flows.
     * 
     */
    public List<String> domainAliases() {
        return this.domainAliases;
    }
    /**
     * @return Set to `true` to inject context into custom DB scripts (warning: cannot be disabled once enabled).
     * 
     */
    public Boolean enableScriptContext() {
        return this.enableScriptContext;
    }
    /**
     * @return Set to `true` to use a legacy user store.
     * 
     */
    public Boolean enabledDatabaseCustomization() {
        return this.enabledDatabaseCustomization;
    }
    /**
     * @return Custom Entity ID for the connection.
     * 
     */
    public String entityId() {
        return this.entityId;
    }
    /**
     * @return Federation Metadata for the ADFS connection.
     * 
     */
    public String fedMetadataXml() {
        return this.fedMetadataXml;
    }
    /**
     * @return If you&#39;re configuring a SAML enterprise connection for a non-standard PingFederate Server, you must update the attribute mappings.
     * 
     */
    public String fieldsMap() {
        return this.fieldsMap;
    }
    /**
     * @return Specifies whether or not request info should be forwarded to sms gateway.
     * 
     */
    public Boolean forwardRequestInfo() {
        return this.forwardRequestInfo;
    }
    /**
     * @return Address to use as the sender.
     * 
     */
    public String from() {
        return this.from;
    }
    /**
     * @return Defines the parameters used to generate the auth token for the custom gateway.
     * 
     */
    public List<GetConnectionOptionGatewayAuthentication> gatewayAuthentications() {
        return this.gatewayAuthentications;
    }
    /**
     * @return Defines a custom sms gateway to use instead of Twilio.
     * 
     */
    public String gatewayUrl() {
        return this.gatewayUrl;
    }
    /**
     * @return Icon URL.
     * 
     */
    public String iconUrl() {
        return this.iconUrl;
    }
    /**
     * @return Azure AD Identity API. Available options are: `microsoft-identity-platform-v2.0` or `azure-active-directory-v1.0`.
     * 
     */
    public String identityApi() {
        return this.identityApi;
    }
    /**
     * @return Configuration options for IDP Initiated Authentication. This is an object with the properties: `client_id`, `client_protocol`, and `client_authorize_query`.
     * 
     */
    public List<GetConnectionOptionIdpInitiated> idpInitiateds() {
        return this.idpInitiateds;
    }
    /**
     * @return Indicates whether you have a legacy user store and want to gradually migrate those users to the Auth0 user store.
     * 
     */
    public Boolean importMode() {
        return this.importMode;
    }
    /**
     * @return A list of IPs.
     * 
     */
    public List<String> ips() {
        return this.ips;
    }
    /**
     * @return Issuer URL, e.g. `https://auth.example.com`.
     * 
     */
    public String issuer() {
        return this.issuer;
    }
    /**
     * @return JWKS URI.
     * 
     */
    public String jwksUri() {
        return this.jwksUri;
    }
    /**
     * @return Apple Key ID.
     * 
     */
    public String keyId() {
        return this.keyId;
    }
    /**
     * @return By default Auth0 maps `user_id` to `email`. Enabling this setting changes the behavior to map `user_id` to &#39;id&#39; instead. This can only be defined on a new Google Workspace connection and can not be changed once set.
     * 
     */
    public Boolean mapUserIdToId() {
        return this.mapUserIdToId;
    }
    /**
     * @return Maximum number of groups to retrieve.
     * 
     */
    public String maxGroupsToRetrieve() {
        return this.maxGroupsToRetrieve;
    }
    /**
     * @return SID for Copilot. Used when SMS Source is Copilot.
     * 
     */
    public String messagingServiceSid() {
        return this.messagingServiceSid;
    }
    /**
     * @return The URL of the SAML metadata document.
     * 
     */
    public String metadataUrl() {
        return this.metadataUrl;
    }
    /**
     * @return The XML content for the SAML metadata document. Values within the xml will take precedence over other attributes set on the options block.
     * 
     */
    public String metadataXml() {
        return this.metadataXml;
    }
    /**
     * @return Configuration options for multifactor authentication.
     * 
     */
    public List<GetConnectionOptionMfa> mfas() {
        return this.mfas;
    }
    /**
     * @return The public name of the email or SMS Connection. In most cases this is the same name as the connection name.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the DenyList here.
     * 
     */
    public List<String> nonPersistentAttrs() {
        return this.nonPersistentAttrs;
    }
    /**
     * @return Configuration settings for password complexity.
     * 
     */
    public List<GetConnectionOptionPasswordComplexityOption> passwordComplexityOptions() {
        return this.passwordComplexityOptions;
    }
    /**
     * @return Configuration settings for the password dictionary check, which does not allow passwords that are part of the password dictionary.
     * 
     */
    public List<GetConnectionOptionPasswordDictionary> passwordDictionaries() {
        return this.passwordDictionaries;
    }
    /**
     * @return Configuration settings for the password history that is maintained for each user to prevent the reuse of passwords.
     * 
     */
    public List<GetConnectionOptionPasswordHistory> passwordHistories() {
        return this.passwordHistories;
    }
    /**
     * @return Configuration settings for the password personal info check, which does not allow passwords that contain any part of the user&#39;s personal data, including user&#39;s `name`, `username`, `nickname`, `user_metadata.name`, `user_metadata.first`, `user_metadata.last`, user&#39;s `email`, or first part of the user&#39;s `email`.
     * 
     */
    public List<GetConnectionOptionPasswordNoPersonalInfo> passwordNoPersonalInfos() {
        return this.passwordNoPersonalInfos;
    }
    /**
     * @return Indicates level of password strength to enforce during authentication. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means. Options include `none`, `low`, `fair`, `good`, `excellent`.
     * 
     */
    public String passwordPolicy() {
        return this.passwordPolicy;
    }
    /**
     * @return Ping Federate Server URL.
     * 
     */
    public String pingFederateBaseUrl() {
        return this.pingFederateBaseUrl;
    }
    /**
     * @return Enables Proof Key for Code Exchange (PKCE) functionality for OAuth2 connections.
     * 
     */
    public Boolean pkceEnabled() {
        return this.pkceEnabled;
    }
    /**
     * @return Order of attributes for precedence in identification.Valid values: email, phone_number, username. If Precedence is set, it must contain all values (email, phone_number, username) in specific order
     * 
     */
    public List<String> precedences() {
        return this.precedences;
    }
    /**
     * @return The SAML Response Binding: how the SAML token is received by Auth0 from the IdP.
     * 
     */
    public String protocolBinding() {
        return this.protocolBinding;
    }
    /**
     * @return Defines the custom `sms_gateway` provider.
     * 
     */
    public String provider() {
        return this.provider;
    }
    /**
     * @return Template that formats the SAML request.
     * 
     */
    public String requestTemplate() {
        return this.requestTemplate;
    }
    /**
     * @return Indicates whether the user is required to provide a username in addition to an email address.
     * 
     */
    public Boolean requiresUsername() {
        return this.requiresUsername;
    }
    /**
     * @return Permissions to grant to the connection. Within the Auth0 dashboard these appear under the &#34;Attributes&#34; and &#34;Extended Attributes&#34; sections. Some examples: `basic_profile`, `ext_profile`, `ext_nested_groups`, etc.
     * 
     */
    public List<String> scopes() {
        return this.scopes;
    }
    /**
     * @return A map of scripts used for an OAuth connection. Only accepts a `fetchUserProfile` script.
     * 
     */
    public Map<String,String> scripts() {
        return this.scripts;
    }
    /**
     * @return Determines whether to sync user profile attributes (`name`, `given_name`, `family_name`, `nickname`, `picture`) at each login or only on the first login. Options include: `on_each_login`, `on_first_login`, `never_on_login`. Default value: `on_each_login`.
     * 
     */
    public String setUserRootAttributes() {
        return this.setUserRootAttributes;
    }
    /**
     * @return Choose how Auth0 sets the email_verified field in the user profile.
     * 
     */
    public String shouldTrustEmailVerifiedConnection() {
        return this.shouldTrustEmailVerifiedConnection;
    }
    /**
     * @return SAML single login URL for the connection.
     * 
     */
    public String signInEndpoint() {
        return this.signInEndpoint;
    }
    /**
     * @return SAML single logout URL for the connection.
     * 
     */
    public String signOutEndpoint() {
        return this.signOutEndpoint;
    }
    /**
     * @return When enabled, the SAML authentication request will be signed.
     * 
     */
    public Boolean signSamlRequest() {
        return this.signSamlRequest;
    }
    /**
     * @return Sign Request Algorithm.
     * 
     */
    public String signatureAlgorithm() {
        return this.signatureAlgorithm;
    }
    /**
     * @return X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP, Base64-encoded.
     * 
     */
    public String signingCert() {
        return this.signingCert;
    }
    /**
     * @return The key used to sign requests in the connection. Uses the `key` and `cert` properties to provide the private key and certificate respectively.
     * 
     */
    public List<GetConnectionOptionSigningKey> signingKeys() {
        return this.signingKeys;
    }
    /**
     * @return Version 1 is deprecated, use version 2.
     * 
     */
    public Integer strategyVersion() {
        return this.strategyVersion;
    }
    /**
     * @return Subject line of the email.
     * 
     */
    public String subject() {
        return this.subject;
    }
    /**
     * @return Syntax of the template body.
     * 
     */
    public String syntax() {
        return this.syntax;
    }
    /**
     * @return Apple Team ID.
     * 
     */
    public String teamId() {
        return this.teamId;
    }
    /**
     * @return Body of the template.
     * 
     */
    public String template() {
        return this.template;
    }
    /**
     * @return Tenant domain name.
     * 
     */
    public String tenantDomain() {
        return this.tenantDomain;
    }
    /**
     * @return Token endpoint.
     * 
     */
    public String tokenEndpoint() {
        return this.tokenEndpoint;
    }
    /**
     * @return Configuration options for one-time passwords.
     * 
     */
    public List<GetConnectionOptionTotp> totps() {
        return this.totps;
    }
    /**
     * @return SID for your Twilio account.
     * 
     */
    public String twilioSid() {
        return this.twilioSid;
    }
    /**
     * @return AuthToken for your Twilio account.
     * 
     */
    public String twilioToken() {
        return this.twilioToken;
    }
    /**
     * @return Value can be `back_channel` or `front_channel`. Front Channel will use OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel will use `response_type=code`.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return You can pass provider-specific parameters to an identity provider during authentication. The values can either be static per connection or dynamic per user.
     * 
     */
    public String upstreamParams() {
        return this.upstreamParams;
    }
    /**
     * @return Indicates whether to use cert auth or not.
     * 
     */
    public Boolean useCertAuth() {
        return this.useCertAuth;
    }
    /**
     * @return Indicates whether to use Kerberos or not.
     * 
     */
    public Boolean useKerberos() {
        return this.useKerberos;
    }
    /**
     * @return Whether to use WS-Fed.
     * 
     */
    public Boolean useWsfed() {
        return this.useWsfed;
    }
    /**
     * @return Attribute in the token that will be mapped to the user_id property in Auth0.
     * 
     */
    public String userIdAttribute() {
        return this.userIdAttribute;
    }
    /**
     * @return User info endpoint.
     * 
     */
    public String userinfoEndpoint() {
        return this.userinfoEndpoint;
    }
    /**
     * @return Validation of the minimum and maximum values allowed for a user to have as username.
     * 
     */
    public List<GetConnectionOptionValidation> validations() {
        return this.validations;
    }
    /**
     * @return Indicates whether to use the common endpoint rather than the default endpoint. Typically enabled if you&#39;re using this for a multi-tenant application in Azure AD.
     * 
     */
    public Boolean waadCommonEndpoint() {
        return this.waadCommonEndpoint;
    }
    /**
     * @return Protocol to use.
     * 
     */
    public String waadProtocol() {
        return this.waadProtocol;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetConnectionOption defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String adfsServer;
        private List<String> allowedAudiences;
        private Boolean apiEnableUsers;
        private String appId;
        private List<GetConnectionOptionAttributeMap> attributeMaps;
        private List<GetConnectionOptionAttribute> attributes;
        private Map<String,String> authParams;
        private String authorizationEndpoint;
        private Boolean bruteForceProtection;
        private String clientId;
        private String clientSecret;
        private String communityBaseUrl;
        private Map<String,String> configuration;
        private List<GetConnectionOptionConnectionSetting> connectionSettings;
        private Map<String,String> customScripts;
        private Boolean debug;
        private List<GetConnectionOptionDecryptionKey> decryptionKeys;
        private String digestAlgorithm;
        private Boolean disableCache;
        private Boolean disableSelfServiceChangePassword;
        private Boolean disableSignOut;
        private Boolean disableSignup;
        private String discoveryUrl;
        private String domain;
        private List<String> domainAliases;
        private Boolean enableScriptContext;
        private Boolean enabledDatabaseCustomization;
        private String entityId;
        private String fedMetadataXml;
        private String fieldsMap;
        private Boolean forwardRequestInfo;
        private String from;
        private List<GetConnectionOptionGatewayAuthentication> gatewayAuthentications;
        private String gatewayUrl;
        private String iconUrl;
        private String identityApi;
        private List<GetConnectionOptionIdpInitiated> idpInitiateds;
        private Boolean importMode;
        private List<String> ips;
        private String issuer;
        private String jwksUri;
        private String keyId;
        private Boolean mapUserIdToId;
        private String maxGroupsToRetrieve;
        private String messagingServiceSid;
        private String metadataUrl;
        private String metadataXml;
        private List<GetConnectionOptionMfa> mfas;
        private String name;
        private List<String> nonPersistentAttrs;
        private List<GetConnectionOptionPasswordComplexityOption> passwordComplexityOptions;
        private List<GetConnectionOptionPasswordDictionary> passwordDictionaries;
        private List<GetConnectionOptionPasswordHistory> passwordHistories;
        private List<GetConnectionOptionPasswordNoPersonalInfo> passwordNoPersonalInfos;
        private String passwordPolicy;
        private String pingFederateBaseUrl;
        private Boolean pkceEnabled;
        private List<String> precedences;
        private String protocolBinding;
        private String provider;
        private String requestTemplate;
        private Boolean requiresUsername;
        private List<String> scopes;
        private Map<String,String> scripts;
        private String setUserRootAttributes;
        private String shouldTrustEmailVerifiedConnection;
        private String signInEndpoint;
        private String signOutEndpoint;
        private Boolean signSamlRequest;
        private String signatureAlgorithm;
        private String signingCert;
        private List<GetConnectionOptionSigningKey> signingKeys;
        private Integer strategyVersion;
        private String subject;
        private String syntax;
        private String teamId;
        private String template;
        private String tenantDomain;
        private String tokenEndpoint;
        private List<GetConnectionOptionTotp> totps;
        private String twilioSid;
        private String twilioToken;
        private String type;
        private String upstreamParams;
        private Boolean useCertAuth;
        private Boolean useKerberos;
        private Boolean useWsfed;
        private String userIdAttribute;
        private String userinfoEndpoint;
        private List<GetConnectionOptionValidation> validations;
        private Boolean waadCommonEndpoint;
        private String waadProtocol;
        public Builder() {}
        public Builder(GetConnectionOption defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.adfsServer = defaults.adfsServer;
    	      this.allowedAudiences = defaults.allowedAudiences;
    	      this.apiEnableUsers = defaults.apiEnableUsers;
    	      this.appId = defaults.appId;
    	      this.attributeMaps = defaults.attributeMaps;
    	      this.attributes = defaults.attributes;
    	      this.authParams = defaults.authParams;
    	      this.authorizationEndpoint = defaults.authorizationEndpoint;
    	      this.bruteForceProtection = defaults.bruteForceProtection;
    	      this.clientId = defaults.clientId;
    	      this.clientSecret = defaults.clientSecret;
    	      this.communityBaseUrl = defaults.communityBaseUrl;
    	      this.configuration = defaults.configuration;
    	      this.connectionSettings = defaults.connectionSettings;
    	      this.customScripts = defaults.customScripts;
    	      this.debug = defaults.debug;
    	      this.decryptionKeys = defaults.decryptionKeys;
    	      this.digestAlgorithm = defaults.digestAlgorithm;
    	      this.disableCache = defaults.disableCache;
    	      this.disableSelfServiceChangePassword = defaults.disableSelfServiceChangePassword;
    	      this.disableSignOut = defaults.disableSignOut;
    	      this.disableSignup = defaults.disableSignup;
    	      this.discoveryUrl = defaults.discoveryUrl;
    	      this.domain = defaults.domain;
    	      this.domainAliases = defaults.domainAliases;
    	      this.enableScriptContext = defaults.enableScriptContext;
    	      this.enabledDatabaseCustomization = defaults.enabledDatabaseCustomization;
    	      this.entityId = defaults.entityId;
    	      this.fedMetadataXml = defaults.fedMetadataXml;
    	      this.fieldsMap = defaults.fieldsMap;
    	      this.forwardRequestInfo = defaults.forwardRequestInfo;
    	      this.from = defaults.from;
    	      this.gatewayAuthentications = defaults.gatewayAuthentications;
    	      this.gatewayUrl = defaults.gatewayUrl;
    	      this.iconUrl = defaults.iconUrl;
    	      this.identityApi = defaults.identityApi;
    	      this.idpInitiateds = defaults.idpInitiateds;
    	      this.importMode = defaults.importMode;
    	      this.ips = defaults.ips;
    	      this.issuer = defaults.issuer;
    	      this.jwksUri = defaults.jwksUri;
    	      this.keyId = defaults.keyId;
    	      this.mapUserIdToId = defaults.mapUserIdToId;
    	      this.maxGroupsToRetrieve = defaults.maxGroupsToRetrieve;
    	      this.messagingServiceSid = defaults.messagingServiceSid;
    	      this.metadataUrl = defaults.metadataUrl;
    	      this.metadataXml = defaults.metadataXml;
    	      this.mfas = defaults.mfas;
    	      this.name = defaults.name;
    	      this.nonPersistentAttrs = defaults.nonPersistentAttrs;
    	      this.passwordComplexityOptions = defaults.passwordComplexityOptions;
    	      this.passwordDictionaries = defaults.passwordDictionaries;
    	      this.passwordHistories = defaults.passwordHistories;
    	      this.passwordNoPersonalInfos = defaults.passwordNoPersonalInfos;
    	      this.passwordPolicy = defaults.passwordPolicy;
    	      this.pingFederateBaseUrl = defaults.pingFederateBaseUrl;
    	      this.pkceEnabled = defaults.pkceEnabled;
    	      this.precedences = defaults.precedences;
    	      this.protocolBinding = defaults.protocolBinding;
    	      this.provider = defaults.provider;
    	      this.requestTemplate = defaults.requestTemplate;
    	      this.requiresUsername = defaults.requiresUsername;
    	      this.scopes = defaults.scopes;
    	      this.scripts = defaults.scripts;
    	      this.setUserRootAttributes = defaults.setUserRootAttributes;
    	      this.shouldTrustEmailVerifiedConnection = defaults.shouldTrustEmailVerifiedConnection;
    	      this.signInEndpoint = defaults.signInEndpoint;
    	      this.signOutEndpoint = defaults.signOutEndpoint;
    	      this.signSamlRequest = defaults.signSamlRequest;
    	      this.signatureAlgorithm = defaults.signatureAlgorithm;
    	      this.signingCert = defaults.signingCert;
    	      this.signingKeys = defaults.signingKeys;
    	      this.strategyVersion = defaults.strategyVersion;
    	      this.subject = defaults.subject;
    	      this.syntax = defaults.syntax;
    	      this.teamId = defaults.teamId;
    	      this.template = defaults.template;
    	      this.tenantDomain = defaults.tenantDomain;
    	      this.tokenEndpoint = defaults.tokenEndpoint;
    	      this.totps = defaults.totps;
    	      this.twilioSid = defaults.twilioSid;
    	      this.twilioToken = defaults.twilioToken;
    	      this.type = defaults.type;
    	      this.upstreamParams = defaults.upstreamParams;
    	      this.useCertAuth = defaults.useCertAuth;
    	      this.useKerberos = defaults.useKerberos;
    	      this.useWsfed = defaults.useWsfed;
    	      this.userIdAttribute = defaults.userIdAttribute;
    	      this.userinfoEndpoint = defaults.userinfoEndpoint;
    	      this.validations = defaults.validations;
    	      this.waadCommonEndpoint = defaults.waadCommonEndpoint;
    	      this.waadProtocol = defaults.waadProtocol;
        }

        @CustomType.Setter
        public Builder adfsServer(String adfsServer) {
            if (adfsServer == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "adfsServer");
            }
            this.adfsServer = adfsServer;
            return this;
        }
        @CustomType.Setter
        public Builder allowedAudiences(List<String> allowedAudiences) {
            if (allowedAudiences == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "allowedAudiences");
            }
            this.allowedAudiences = allowedAudiences;
            return this;
        }
        public Builder allowedAudiences(String... allowedAudiences) {
            return allowedAudiences(List.of(allowedAudiences));
        }
        @CustomType.Setter
        public Builder apiEnableUsers(Boolean apiEnableUsers) {
            if (apiEnableUsers == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "apiEnableUsers");
            }
            this.apiEnableUsers = apiEnableUsers;
            return this;
        }
        @CustomType.Setter
        public Builder appId(String appId) {
            if (appId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "appId");
            }
            this.appId = appId;
            return this;
        }
        @CustomType.Setter
        public Builder attributeMaps(List<GetConnectionOptionAttributeMap> attributeMaps) {
            if (attributeMaps == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "attributeMaps");
            }
            this.attributeMaps = attributeMaps;
            return this;
        }
        public Builder attributeMaps(GetConnectionOptionAttributeMap... attributeMaps) {
            return attributeMaps(List.of(attributeMaps));
        }
        @CustomType.Setter
        public Builder attributes(List<GetConnectionOptionAttribute> attributes) {
            if (attributes == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "attributes");
            }
            this.attributes = attributes;
            return this;
        }
        public Builder attributes(GetConnectionOptionAttribute... attributes) {
            return attributes(List.of(attributes));
        }
        @CustomType.Setter
        public Builder authParams(Map<String,String> authParams) {
            if (authParams == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "authParams");
            }
            this.authParams = authParams;
            return this;
        }
        @CustomType.Setter
        public Builder authorizationEndpoint(String authorizationEndpoint) {
            if (authorizationEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "authorizationEndpoint");
            }
            this.authorizationEndpoint = authorizationEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder bruteForceProtection(Boolean bruteForceProtection) {
            if (bruteForceProtection == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "bruteForceProtection");
            }
            this.bruteForceProtection = bruteForceProtection;
            return this;
        }
        @CustomType.Setter
        public Builder clientId(String clientId) {
            if (clientId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "clientId");
            }
            this.clientId = clientId;
            return this;
        }
        @CustomType.Setter
        public Builder clientSecret(String clientSecret) {
            if (clientSecret == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "clientSecret");
            }
            this.clientSecret = clientSecret;
            return this;
        }
        @CustomType.Setter
        public Builder communityBaseUrl(String communityBaseUrl) {
            if (communityBaseUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "communityBaseUrl");
            }
            this.communityBaseUrl = communityBaseUrl;
            return this;
        }
        @CustomType.Setter
        public Builder configuration(Map<String,String> configuration) {
            if (configuration == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "configuration");
            }
            this.configuration = configuration;
            return this;
        }
        @CustomType.Setter
        public Builder connectionSettings(List<GetConnectionOptionConnectionSetting> connectionSettings) {
            if (connectionSettings == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "connectionSettings");
            }
            this.connectionSettings = connectionSettings;
            return this;
        }
        public Builder connectionSettings(GetConnectionOptionConnectionSetting... connectionSettings) {
            return connectionSettings(List.of(connectionSettings));
        }
        @CustomType.Setter
        public Builder customScripts(Map<String,String> customScripts) {
            if (customScripts == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "customScripts");
            }
            this.customScripts = customScripts;
            return this;
        }
        @CustomType.Setter
        public Builder debug(Boolean debug) {
            if (debug == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "debug");
            }
            this.debug = debug;
            return this;
        }
        @CustomType.Setter
        public Builder decryptionKeys(List<GetConnectionOptionDecryptionKey> decryptionKeys) {
            if (decryptionKeys == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "decryptionKeys");
            }
            this.decryptionKeys = decryptionKeys;
            return this;
        }
        public Builder decryptionKeys(GetConnectionOptionDecryptionKey... decryptionKeys) {
            return decryptionKeys(List.of(decryptionKeys));
        }
        @CustomType.Setter
        public Builder digestAlgorithm(String digestAlgorithm) {
            if (digestAlgorithm == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "digestAlgorithm");
            }
            this.digestAlgorithm = digestAlgorithm;
            return this;
        }
        @CustomType.Setter
        public Builder disableCache(Boolean disableCache) {
            if (disableCache == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "disableCache");
            }
            this.disableCache = disableCache;
            return this;
        }
        @CustomType.Setter
        public Builder disableSelfServiceChangePassword(Boolean disableSelfServiceChangePassword) {
            if (disableSelfServiceChangePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "disableSelfServiceChangePassword");
            }
            this.disableSelfServiceChangePassword = disableSelfServiceChangePassword;
            return this;
        }
        @CustomType.Setter
        public Builder disableSignOut(Boolean disableSignOut) {
            if (disableSignOut == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "disableSignOut");
            }
            this.disableSignOut = disableSignOut;
            return this;
        }
        @CustomType.Setter
        public Builder disableSignup(Boolean disableSignup) {
            if (disableSignup == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "disableSignup");
            }
            this.disableSignup = disableSignup;
            return this;
        }
        @CustomType.Setter
        public Builder discoveryUrl(String discoveryUrl) {
            if (discoveryUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "discoveryUrl");
            }
            this.discoveryUrl = discoveryUrl;
            return this;
        }
        @CustomType.Setter
        public Builder domain(String domain) {
            if (domain == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "domain");
            }
            this.domain = domain;
            return this;
        }
        @CustomType.Setter
        public Builder domainAliases(List<String> domainAliases) {
            if (domainAliases == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "domainAliases");
            }
            this.domainAliases = domainAliases;
            return this;
        }
        public Builder domainAliases(String... domainAliases) {
            return domainAliases(List.of(domainAliases));
        }
        @CustomType.Setter
        public Builder enableScriptContext(Boolean enableScriptContext) {
            if (enableScriptContext == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "enableScriptContext");
            }
            this.enableScriptContext = enableScriptContext;
            return this;
        }
        @CustomType.Setter
        public Builder enabledDatabaseCustomization(Boolean enabledDatabaseCustomization) {
            if (enabledDatabaseCustomization == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "enabledDatabaseCustomization");
            }
            this.enabledDatabaseCustomization = enabledDatabaseCustomization;
            return this;
        }
        @CustomType.Setter
        public Builder entityId(String entityId) {
            if (entityId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "entityId");
            }
            this.entityId = entityId;
            return this;
        }
        @CustomType.Setter
        public Builder fedMetadataXml(String fedMetadataXml) {
            if (fedMetadataXml == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "fedMetadataXml");
            }
            this.fedMetadataXml = fedMetadataXml;
            return this;
        }
        @CustomType.Setter
        public Builder fieldsMap(String fieldsMap) {
            if (fieldsMap == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "fieldsMap");
            }
            this.fieldsMap = fieldsMap;
            return this;
        }
        @CustomType.Setter
        public Builder forwardRequestInfo(Boolean forwardRequestInfo) {
            if (forwardRequestInfo == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "forwardRequestInfo");
            }
            this.forwardRequestInfo = forwardRequestInfo;
            return this;
        }
        @CustomType.Setter
        public Builder from(String from) {
            if (from == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "from");
            }
            this.from = from;
            return this;
        }
        @CustomType.Setter
        public Builder gatewayAuthentications(List<GetConnectionOptionGatewayAuthentication> gatewayAuthentications) {
            if (gatewayAuthentications == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "gatewayAuthentications");
            }
            this.gatewayAuthentications = gatewayAuthentications;
            return this;
        }
        public Builder gatewayAuthentications(GetConnectionOptionGatewayAuthentication... gatewayAuthentications) {
            return gatewayAuthentications(List.of(gatewayAuthentications));
        }
        @CustomType.Setter
        public Builder gatewayUrl(String gatewayUrl) {
            if (gatewayUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "gatewayUrl");
            }
            this.gatewayUrl = gatewayUrl;
            return this;
        }
        @CustomType.Setter
        public Builder iconUrl(String iconUrl) {
            if (iconUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "iconUrl");
            }
            this.iconUrl = iconUrl;
            return this;
        }
        @CustomType.Setter
        public Builder identityApi(String identityApi) {
            if (identityApi == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "identityApi");
            }
            this.identityApi = identityApi;
            return this;
        }
        @CustomType.Setter
        public Builder idpInitiateds(List<GetConnectionOptionIdpInitiated> idpInitiateds) {
            if (idpInitiateds == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "idpInitiateds");
            }
            this.idpInitiateds = idpInitiateds;
            return this;
        }
        public Builder idpInitiateds(GetConnectionOptionIdpInitiated... idpInitiateds) {
            return idpInitiateds(List.of(idpInitiateds));
        }
        @CustomType.Setter
        public Builder importMode(Boolean importMode) {
            if (importMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "importMode");
            }
            this.importMode = importMode;
            return this;
        }
        @CustomType.Setter
        public Builder ips(List<String> ips) {
            if (ips == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "ips");
            }
            this.ips = ips;
            return this;
        }
        public Builder ips(String... ips) {
            return ips(List.of(ips));
        }
        @CustomType.Setter
        public Builder issuer(String issuer) {
            if (issuer == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "issuer");
            }
            this.issuer = issuer;
            return this;
        }
        @CustomType.Setter
        public Builder jwksUri(String jwksUri) {
            if (jwksUri == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "jwksUri");
            }
            this.jwksUri = jwksUri;
            return this;
        }
        @CustomType.Setter
        public Builder keyId(String keyId) {
            if (keyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "keyId");
            }
            this.keyId = keyId;
            return this;
        }
        @CustomType.Setter
        public Builder mapUserIdToId(Boolean mapUserIdToId) {
            if (mapUserIdToId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "mapUserIdToId");
            }
            this.mapUserIdToId = mapUserIdToId;
            return this;
        }
        @CustomType.Setter
        public Builder maxGroupsToRetrieve(String maxGroupsToRetrieve) {
            if (maxGroupsToRetrieve == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "maxGroupsToRetrieve");
            }
            this.maxGroupsToRetrieve = maxGroupsToRetrieve;
            return this;
        }
        @CustomType.Setter
        public Builder messagingServiceSid(String messagingServiceSid) {
            if (messagingServiceSid == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "messagingServiceSid");
            }
            this.messagingServiceSid = messagingServiceSid;
            return this;
        }
        @CustomType.Setter
        public Builder metadataUrl(String metadataUrl) {
            if (metadataUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "metadataUrl");
            }
            this.metadataUrl = metadataUrl;
            return this;
        }
        @CustomType.Setter
        public Builder metadataXml(String metadataXml) {
            if (metadataXml == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "metadataXml");
            }
            this.metadataXml = metadataXml;
            return this;
        }
        @CustomType.Setter
        public Builder mfas(List<GetConnectionOptionMfa> mfas) {
            if (mfas == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "mfas");
            }
            this.mfas = mfas;
            return this;
        }
        public Builder mfas(GetConnectionOptionMfa... mfas) {
            return mfas(List.of(mfas));
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder nonPersistentAttrs(List<String> nonPersistentAttrs) {
            if (nonPersistentAttrs == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "nonPersistentAttrs");
            }
            this.nonPersistentAttrs = nonPersistentAttrs;
            return this;
        }
        public Builder nonPersistentAttrs(String... nonPersistentAttrs) {
            return nonPersistentAttrs(List.of(nonPersistentAttrs));
        }
        @CustomType.Setter
        public Builder passwordComplexityOptions(List<GetConnectionOptionPasswordComplexityOption> passwordComplexityOptions) {
            if (passwordComplexityOptions == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "passwordComplexityOptions");
            }
            this.passwordComplexityOptions = passwordComplexityOptions;
            return this;
        }
        public Builder passwordComplexityOptions(GetConnectionOptionPasswordComplexityOption... passwordComplexityOptions) {
            return passwordComplexityOptions(List.of(passwordComplexityOptions));
        }
        @CustomType.Setter
        public Builder passwordDictionaries(List<GetConnectionOptionPasswordDictionary> passwordDictionaries) {
            if (passwordDictionaries == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "passwordDictionaries");
            }
            this.passwordDictionaries = passwordDictionaries;
            return this;
        }
        public Builder passwordDictionaries(GetConnectionOptionPasswordDictionary... passwordDictionaries) {
            return passwordDictionaries(List.of(passwordDictionaries));
        }
        @CustomType.Setter
        public Builder passwordHistories(List<GetConnectionOptionPasswordHistory> passwordHistories) {
            if (passwordHistories == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "passwordHistories");
            }
            this.passwordHistories = passwordHistories;
            return this;
        }
        public Builder passwordHistories(GetConnectionOptionPasswordHistory... passwordHistories) {
            return passwordHistories(List.of(passwordHistories));
        }
        @CustomType.Setter
        public Builder passwordNoPersonalInfos(List<GetConnectionOptionPasswordNoPersonalInfo> passwordNoPersonalInfos) {
            if (passwordNoPersonalInfos == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "passwordNoPersonalInfos");
            }
            this.passwordNoPersonalInfos = passwordNoPersonalInfos;
            return this;
        }
        public Builder passwordNoPersonalInfos(GetConnectionOptionPasswordNoPersonalInfo... passwordNoPersonalInfos) {
            return passwordNoPersonalInfos(List.of(passwordNoPersonalInfos));
        }
        @CustomType.Setter
        public Builder passwordPolicy(String passwordPolicy) {
            if (passwordPolicy == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "passwordPolicy");
            }
            this.passwordPolicy = passwordPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder pingFederateBaseUrl(String pingFederateBaseUrl) {
            if (pingFederateBaseUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "pingFederateBaseUrl");
            }
            this.pingFederateBaseUrl = pingFederateBaseUrl;
            return this;
        }
        @CustomType.Setter
        public Builder pkceEnabled(Boolean pkceEnabled) {
            if (pkceEnabled == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "pkceEnabled");
            }
            this.pkceEnabled = pkceEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder precedences(List<String> precedences) {
            if (precedences == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "precedences");
            }
            this.precedences = precedences;
            return this;
        }
        public Builder precedences(String... precedences) {
            return precedences(List.of(precedences));
        }
        @CustomType.Setter
        public Builder protocolBinding(String protocolBinding) {
            if (protocolBinding == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "protocolBinding");
            }
            this.protocolBinding = protocolBinding;
            return this;
        }
        @CustomType.Setter
        public Builder provider(String provider) {
            if (provider == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "provider");
            }
            this.provider = provider;
            return this;
        }
        @CustomType.Setter
        public Builder requestTemplate(String requestTemplate) {
            if (requestTemplate == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "requestTemplate");
            }
            this.requestTemplate = requestTemplate;
            return this;
        }
        @CustomType.Setter
        public Builder requiresUsername(Boolean requiresUsername) {
            if (requiresUsername == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "requiresUsername");
            }
            this.requiresUsername = requiresUsername;
            return this;
        }
        @CustomType.Setter
        public Builder scopes(List<String> scopes) {
            if (scopes == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "scopes");
            }
            this.scopes = scopes;
            return this;
        }
        public Builder scopes(String... scopes) {
            return scopes(List.of(scopes));
        }
        @CustomType.Setter
        public Builder scripts(Map<String,String> scripts) {
            if (scripts == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "scripts");
            }
            this.scripts = scripts;
            return this;
        }
        @CustomType.Setter
        public Builder setUserRootAttributes(String setUserRootAttributes) {
            if (setUserRootAttributes == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "setUserRootAttributes");
            }
            this.setUserRootAttributes = setUserRootAttributes;
            return this;
        }
        @CustomType.Setter
        public Builder shouldTrustEmailVerifiedConnection(String shouldTrustEmailVerifiedConnection) {
            if (shouldTrustEmailVerifiedConnection == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "shouldTrustEmailVerifiedConnection");
            }
            this.shouldTrustEmailVerifiedConnection = shouldTrustEmailVerifiedConnection;
            return this;
        }
        @CustomType.Setter
        public Builder signInEndpoint(String signInEndpoint) {
            if (signInEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signInEndpoint");
            }
            this.signInEndpoint = signInEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder signOutEndpoint(String signOutEndpoint) {
            if (signOutEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signOutEndpoint");
            }
            this.signOutEndpoint = signOutEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder signSamlRequest(Boolean signSamlRequest) {
            if (signSamlRequest == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signSamlRequest");
            }
            this.signSamlRequest = signSamlRequest;
            return this;
        }
        @CustomType.Setter
        public Builder signatureAlgorithm(String signatureAlgorithm) {
            if (signatureAlgorithm == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signatureAlgorithm");
            }
            this.signatureAlgorithm = signatureAlgorithm;
            return this;
        }
        @CustomType.Setter
        public Builder signingCert(String signingCert) {
            if (signingCert == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signingCert");
            }
            this.signingCert = signingCert;
            return this;
        }
        @CustomType.Setter
        public Builder signingKeys(List<GetConnectionOptionSigningKey> signingKeys) {
            if (signingKeys == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "signingKeys");
            }
            this.signingKeys = signingKeys;
            return this;
        }
        public Builder signingKeys(GetConnectionOptionSigningKey... signingKeys) {
            return signingKeys(List.of(signingKeys));
        }
        @CustomType.Setter
        public Builder strategyVersion(Integer strategyVersion) {
            if (strategyVersion == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "strategyVersion");
            }
            this.strategyVersion = strategyVersion;
            return this;
        }
        @CustomType.Setter
        public Builder subject(String subject) {
            if (subject == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "subject");
            }
            this.subject = subject;
            return this;
        }
        @CustomType.Setter
        public Builder syntax(String syntax) {
            if (syntax == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "syntax");
            }
            this.syntax = syntax;
            return this;
        }
        @CustomType.Setter
        public Builder teamId(String teamId) {
            if (teamId == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "teamId");
            }
            this.teamId = teamId;
            return this;
        }
        @CustomType.Setter
        public Builder template(String template) {
            if (template == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "template");
            }
            this.template = template;
            return this;
        }
        @CustomType.Setter
        public Builder tenantDomain(String tenantDomain) {
            if (tenantDomain == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "tenantDomain");
            }
            this.tenantDomain = tenantDomain;
            return this;
        }
        @CustomType.Setter
        public Builder tokenEndpoint(String tokenEndpoint) {
            if (tokenEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "tokenEndpoint");
            }
            this.tokenEndpoint = tokenEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder totps(List<GetConnectionOptionTotp> totps) {
            if (totps == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "totps");
            }
            this.totps = totps;
            return this;
        }
        public Builder totps(GetConnectionOptionTotp... totps) {
            return totps(List.of(totps));
        }
        @CustomType.Setter
        public Builder twilioSid(String twilioSid) {
            if (twilioSid == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "twilioSid");
            }
            this.twilioSid = twilioSid;
            return this;
        }
        @CustomType.Setter
        public Builder twilioToken(String twilioToken) {
            if (twilioToken == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "twilioToken");
            }
            this.twilioToken = twilioToken;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "type");
            }
            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder upstreamParams(String upstreamParams) {
            if (upstreamParams == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "upstreamParams");
            }
            this.upstreamParams = upstreamParams;
            return this;
        }
        @CustomType.Setter
        public Builder useCertAuth(Boolean useCertAuth) {
            if (useCertAuth == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "useCertAuth");
            }
            this.useCertAuth = useCertAuth;
            return this;
        }
        @CustomType.Setter
        public Builder useKerberos(Boolean useKerberos) {
            if (useKerberos == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "useKerberos");
            }
            this.useKerberos = useKerberos;
            return this;
        }
        @CustomType.Setter
        public Builder useWsfed(Boolean useWsfed) {
            if (useWsfed == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "useWsfed");
            }
            this.useWsfed = useWsfed;
            return this;
        }
        @CustomType.Setter
        public Builder userIdAttribute(String userIdAttribute) {
            if (userIdAttribute == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "userIdAttribute");
            }
            this.userIdAttribute = userIdAttribute;
            return this;
        }
        @CustomType.Setter
        public Builder userinfoEndpoint(String userinfoEndpoint) {
            if (userinfoEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "userinfoEndpoint");
            }
            this.userinfoEndpoint = userinfoEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder validations(List<GetConnectionOptionValidation> validations) {
            if (validations == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "validations");
            }
            this.validations = validations;
            return this;
        }
        public Builder validations(GetConnectionOptionValidation... validations) {
            return validations(List.of(validations));
        }
        @CustomType.Setter
        public Builder waadCommonEndpoint(Boolean waadCommonEndpoint) {
            if (waadCommonEndpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "waadCommonEndpoint");
            }
            this.waadCommonEndpoint = waadCommonEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder waadProtocol(String waadProtocol) {
            if (waadProtocol == null) {
              throw new MissingRequiredPropertyException("GetConnectionOption", "waadProtocol");
            }
            this.waadProtocol = waadProtocol;
            return this;
        }
        public GetConnectionOption build() {
            final var _resultValue = new GetConnectionOption();
            _resultValue.adfsServer = adfsServer;
            _resultValue.allowedAudiences = allowedAudiences;
            _resultValue.apiEnableUsers = apiEnableUsers;
            _resultValue.appId = appId;
            _resultValue.attributeMaps = attributeMaps;
            _resultValue.attributes = attributes;
            _resultValue.authParams = authParams;
            _resultValue.authorizationEndpoint = authorizationEndpoint;
            _resultValue.bruteForceProtection = bruteForceProtection;
            _resultValue.clientId = clientId;
            _resultValue.clientSecret = clientSecret;
            _resultValue.communityBaseUrl = communityBaseUrl;
            _resultValue.configuration = configuration;
            _resultValue.connectionSettings = connectionSettings;
            _resultValue.customScripts = customScripts;
            _resultValue.debug = debug;
            _resultValue.decryptionKeys = decryptionKeys;
            _resultValue.digestAlgorithm = digestAlgorithm;
            _resultValue.disableCache = disableCache;
            _resultValue.disableSelfServiceChangePassword = disableSelfServiceChangePassword;
            _resultValue.disableSignOut = disableSignOut;
            _resultValue.disableSignup = disableSignup;
            _resultValue.discoveryUrl = discoveryUrl;
            _resultValue.domain = domain;
            _resultValue.domainAliases = domainAliases;
            _resultValue.enableScriptContext = enableScriptContext;
            _resultValue.enabledDatabaseCustomization = enabledDatabaseCustomization;
            _resultValue.entityId = entityId;
            _resultValue.fedMetadataXml = fedMetadataXml;
            _resultValue.fieldsMap = fieldsMap;
            _resultValue.forwardRequestInfo = forwardRequestInfo;
            _resultValue.from = from;
            _resultValue.gatewayAuthentications = gatewayAuthentications;
            _resultValue.gatewayUrl = gatewayUrl;
            _resultValue.iconUrl = iconUrl;
            _resultValue.identityApi = identityApi;
            _resultValue.idpInitiateds = idpInitiateds;
            _resultValue.importMode = importMode;
            _resultValue.ips = ips;
            _resultValue.issuer = issuer;
            _resultValue.jwksUri = jwksUri;
            _resultValue.keyId = keyId;
            _resultValue.mapUserIdToId = mapUserIdToId;
            _resultValue.maxGroupsToRetrieve = maxGroupsToRetrieve;
            _resultValue.messagingServiceSid = messagingServiceSid;
            _resultValue.metadataUrl = metadataUrl;
            _resultValue.metadataXml = metadataXml;
            _resultValue.mfas = mfas;
            _resultValue.name = name;
            _resultValue.nonPersistentAttrs = nonPersistentAttrs;
            _resultValue.passwordComplexityOptions = passwordComplexityOptions;
            _resultValue.passwordDictionaries = passwordDictionaries;
            _resultValue.passwordHistories = passwordHistories;
            _resultValue.passwordNoPersonalInfos = passwordNoPersonalInfos;
            _resultValue.passwordPolicy = passwordPolicy;
            _resultValue.pingFederateBaseUrl = pingFederateBaseUrl;
            _resultValue.pkceEnabled = pkceEnabled;
            _resultValue.precedences = precedences;
            _resultValue.protocolBinding = protocolBinding;
            _resultValue.provider = provider;
            _resultValue.requestTemplate = requestTemplate;
            _resultValue.requiresUsername = requiresUsername;
            _resultValue.scopes = scopes;
            _resultValue.scripts = scripts;
            _resultValue.setUserRootAttributes = setUserRootAttributes;
            _resultValue.shouldTrustEmailVerifiedConnection = shouldTrustEmailVerifiedConnection;
            _resultValue.signInEndpoint = signInEndpoint;
            _resultValue.signOutEndpoint = signOutEndpoint;
            _resultValue.signSamlRequest = signSamlRequest;
            _resultValue.signatureAlgorithm = signatureAlgorithm;
            _resultValue.signingCert = signingCert;
            _resultValue.signingKeys = signingKeys;
            _resultValue.strategyVersion = strategyVersion;
            _resultValue.subject = subject;
            _resultValue.syntax = syntax;
            _resultValue.teamId = teamId;
            _resultValue.template = template;
            _resultValue.tenantDomain = tenantDomain;
            _resultValue.tokenEndpoint = tokenEndpoint;
            _resultValue.totps = totps;
            _resultValue.twilioSid = twilioSid;
            _resultValue.twilioToken = twilioToken;
            _resultValue.type = type;
            _resultValue.upstreamParams = upstreamParams;
            _resultValue.useCertAuth = useCertAuth;
            _resultValue.useKerberos = useKerberos;
            _resultValue.useWsfed = useWsfed;
            _resultValue.userIdAttribute = userIdAttribute;
            _resultValue.userinfoEndpoint = userinfoEndpoint;
            _resultValue.validations = validations;
            _resultValue.waadCommonEndpoint = waadCommonEndpoint;
            _resultValue.waadProtocol = waadProtocol;
            return _resultValue;
        }
    }
}
